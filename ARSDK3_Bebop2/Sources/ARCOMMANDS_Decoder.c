/*
    Copyright (C) 2014 Parrot SA

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
    * Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in
    the documentation and/or other materials provided with the
    distribution.
    * Neither the name of Parrot nor the names
    of its contributors may be used to endorse or promote products
    derived from this software without specific prior written
    permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
    OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
    OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.
*/
/********************************************
 *            AUTOGENERATED FILE            *
 *             DO NOT MODIFY IT             *
 *                                          *
 * To add new commands :                    *
 *  - Modify ../Xml/commands.xml file       *
 *  - Re-run generateCommandsList.py script *
 *                                          *
 ********************************************/
#include <config.h>
#include <stdio.h>
#include "ARCOMMANDS_ReadWrite.h"
#include <libARCommands/ARCOMMANDS_Types.h>
#include <libARCommands/ARCOMMANDS_Decoder.h>
#include <libARCommands/ARCOMMANDS_Ids.h>
#include <libARSAL/ARSAL_Mutex.h>

// ARCOMMANDS_Decoder_t structure definition
struct ARCOMMANDS_Decoder_t
{
    ARSAL_Mutex_t mutex;

    // Feature generic
    ARCOMMANDS_Decoder_GenericDefaultCallback_t GenericDefaultCallback;
    void *GenericDefaultCustom;

    // Feature ARDrone3
    ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCallback_t ARDrone3PilotingFlatTrimCallback;
    void *ARDrone3PilotingFlatTrimCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCallback_t ARDrone3PilotingTakeOffCallback;
    void *ARDrone3PilotingTakeOffCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCallback_t ARDrone3PilotingPCMDCallback;
    void *ARDrone3PilotingPCMDCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingLandingCallback_t ARDrone3PilotingLandingCallback;
    void *ARDrone3PilotingLandingCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCallback_t ARDrone3PilotingEmergencyCallback;
    void *ARDrone3PilotingEmergencyCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCallback_t ARDrone3PilotingNavigateHomeCallback;
    void *ARDrone3PilotingNavigateHomeCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCallback_t ARDrone3PilotingAutoTakeOffModeCallback;
    void *ARDrone3PilotingAutoTakeOffModeCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCallback_t ARDrone3PilotingMoveByCallback;
    void *ARDrone3PilotingMoveByCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCallback_t ARDrone3PilotingUserTakeOffCallback;
    void *ARDrone3PilotingUserTakeOffCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingCircleCallback_t ARDrone3PilotingCircleCallback;
    void *ARDrone3PilotingCircleCustom;
    ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCallback_t ARDrone3AnimationsFlipCallback;
    void *ARDrone3AnimationsFlipCustom;
    ARCOMMANDS_Decoder_ARDrone3CameraOrientationCallback_t ARDrone3CameraOrientationCallback;
    void *ARDrone3CameraOrientationCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCallback_t ARDrone3MediaRecordPictureCallback;
    void *ARDrone3MediaRecordPictureCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCallback_t ARDrone3MediaRecordVideoCallback;
    void *ARDrone3MediaRecordVideoCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Callback_t ARDrone3MediaRecordPictureV2Callback;
    void *ARDrone3MediaRecordPictureV2Custom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Callback_t ARDrone3MediaRecordVideoV2Callback;
    void *ARDrone3MediaRecordVideoV2Custom;
    ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCallback_t ARDrone3NetworkWifiScanCallback;
    void *ARDrone3NetworkWifiScanCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCallback_t ARDrone3NetworkWifiAuthChannelCallback;
    void *ARDrone3NetworkWifiAuthChannelCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCallback_t ARDrone3PilotingSettingsMaxAltitudeCallback;
    void *ARDrone3PilotingSettingsMaxAltitudeCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCallback_t ARDrone3PilotingSettingsMaxTiltCallback;
    void *ARDrone3PilotingSettingsMaxTiltCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCallback_t ARDrone3PilotingSettingsAbsolutControlCallback;
    void *ARDrone3PilotingSettingsAbsolutControlCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCallback_t ARDrone3PilotingSettingsMaxDistanceCallback;
    void *ARDrone3PilotingSettingsMaxDistanceCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback_t ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback;
    void *ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback_t ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback;
    void *ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback_t ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback;
    void *ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback_t ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback;
    void *ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback_t ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback;
    void *ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback_t ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback;
    void *ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCallback_t ARDrone3PilotingSettingsBankedTurnCallback;
    void *ARDrone3PilotingSettingsBankedTurnCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCallback_t ARDrone3PilotingSettingsMinAltitudeCallback;
    void *ARDrone3PilotingSettingsMinAltitudeCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCallback_t ARDrone3PilotingSettingsCirclingDirectionCallback;
    void *ARDrone3PilotingSettingsCirclingDirectionCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCallback_t ARDrone3PilotingSettingsCirclingRadiusCallback;
    void *ARDrone3PilotingSettingsCirclingRadiusCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCallback_t ARDrone3PilotingSettingsCirclingAltitudeCallback;
    void *ARDrone3PilotingSettingsCirclingAltitudeCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCallback_t ARDrone3PilotingSettingsPitchModeCallback;
    void *ARDrone3PilotingSettingsPitchModeCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCallback_t ARDrone3SpeedSettingsMaxVerticalSpeedCallback;
    void *ARDrone3SpeedSettingsMaxVerticalSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCallback_t ARDrone3SpeedSettingsMaxRotationSpeedCallback;
    void *ARDrone3SpeedSettingsMaxRotationSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCallback_t ARDrone3SpeedSettingsHullProtectionCallback;
    void *ARDrone3SpeedSettingsHullProtectionCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCallback_t ARDrone3SpeedSettingsOutdoorCallback;
    void *ARDrone3SpeedSettingsOutdoorCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback_t ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback;
    void *ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCallback_t ARDrone3NetworkSettingsWifiSelectionCallback;
    void *ARDrone3NetworkSettingsWifiSelectionCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCallback_t ARDrone3NetworkSettingsWifiSecurityCallback;
    void *ARDrone3NetworkSettingsWifiSecurityCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCallback_t ARDrone3PictureSettingsPictureFormatSelectionCallback;
    void *ARDrone3PictureSettingsPictureFormatSelectionCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback_t ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback;
    void *ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCallback_t ARDrone3PictureSettingsExpositionSelectionCallback;
    void *ARDrone3PictureSettingsExpositionSelectionCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCallback_t ARDrone3PictureSettingsSaturationSelectionCallback;
    void *ARDrone3PictureSettingsSaturationSelectionCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCallback_t ARDrone3PictureSettingsTimelapseSelectionCallback;
    void *ARDrone3PictureSettingsTimelapseSelectionCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCallback_t ARDrone3PictureSettingsVideoAutorecordSelectionCallback;
    void *ARDrone3PictureSettingsVideoAutorecordSelectionCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCallback_t ARDrone3PictureSettingsVideoStabilizationModeCallback;
    void *ARDrone3PictureSettingsVideoStabilizationModeCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCallback_t ARDrone3PictureSettingsVideoRecordingModeCallback;
    void *ARDrone3PictureSettingsVideoRecordingModeCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCallback_t ARDrone3PictureSettingsVideoFramerateCallback;
    void *ARDrone3PictureSettingsVideoFramerateCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCallback_t ARDrone3PictureSettingsVideoResolutionsCallback;
    void *ARDrone3PictureSettingsVideoResolutionsCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCallback_t ARDrone3MediaStreamingVideoEnableCallback;
    void *ARDrone3MediaStreamingVideoEnableCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCallback_t ARDrone3MediaStreamingVideoStreamModeCallback;
    void *ARDrone3MediaStreamingVideoStreamModeCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCallback_t ARDrone3GPSSettingsSetHomeCallback;
    void *ARDrone3GPSSettingsSetHomeCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCallback_t ARDrone3GPSSettingsResetHomeCallback;
    void *ARDrone3GPSSettingsResetHomeCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCallback_t ARDrone3GPSSettingsSendControllerGPSCallback;
    void *ARDrone3GPSSettingsSendControllerGPSCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCallback_t ARDrone3GPSSettingsHomeTypeCallback;
    void *ARDrone3GPSSettingsHomeTypeCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCallback_t ARDrone3GPSSettingsReturnHomeDelayCallback;
    void *ARDrone3GPSSettingsReturnHomeDelayCustom;
    ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCallback_t ARDrone3AntiflickeringElectricFrequencyCallback;
    void *ARDrone3AntiflickeringElectricFrequencyCustom;
    ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCallback_t ARDrone3AntiflickeringSetModeCallback;
    void *ARDrone3AntiflickeringSetModeCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCallback_t ARDrone3MediaRecordStatePictureStateChangedCallback;
    void *ARDrone3MediaRecordStatePictureStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCallback_t ARDrone3MediaRecordStateVideoStateChangedCallback;
    void *ARDrone3MediaRecordStateVideoStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Callback_t ARDrone3MediaRecordStatePictureStateChangedV2Callback;
    void *ARDrone3MediaRecordStatePictureStateChangedV2Custom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Callback_t ARDrone3MediaRecordStateVideoStateChangedV2Callback;
    void *ARDrone3MediaRecordStateVideoStateChangedV2Custom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCallback_t ARDrone3MediaRecordStateVideoResolutionStateCallback;
    void *ARDrone3MediaRecordStateVideoResolutionStateCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCallback_t ARDrone3MediaRecordEventPictureEventChangedCallback;
    void *ARDrone3MediaRecordEventPictureEventChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCallback_t ARDrone3MediaRecordEventVideoEventChangedCallback;
    void *ARDrone3MediaRecordEventVideoEventChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCallback_t ARDrone3PilotingStateFlatTrimChangedCallback;
    void *ARDrone3PilotingStateFlatTrimChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCallback_t ARDrone3PilotingStateFlyingStateChangedCallback;
    void *ARDrone3PilotingStateFlyingStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCallback_t ARDrone3PilotingStateAlertStateChangedCallback;
    void *ARDrone3PilotingStateAlertStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCallback_t ARDrone3PilotingStateNavigateHomeStateChangedCallback;
    void *ARDrone3PilotingStateNavigateHomeStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCallback_t ARDrone3PilotingStatePositionChangedCallback;
    void *ARDrone3PilotingStatePositionChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCallback_t ARDrone3PilotingStateSpeedChangedCallback;
    void *ARDrone3PilotingStateSpeedChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCallback_t ARDrone3PilotingStateAttitudeChangedCallback;
    void *ARDrone3PilotingStateAttitudeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCallback_t ARDrone3PilotingStateAutoTakeOffModeChangedCallback;
    void *ARDrone3PilotingStateAutoTakeOffModeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCallback_t ARDrone3PilotingStateAltitudeChangedCallback;
    void *ARDrone3PilotingStateAltitudeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCallback_t ARDrone3PilotingStateGpsLocationChangedCallback;
    void *ARDrone3PilotingStateGpsLocationChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCallback_t ARDrone3PilotingStateLandingStateChangedCallback;
    void *ARDrone3PilotingStateLandingStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCallback_t ARDrone3PilotingEventMoveByEndCallback;
    void *ARDrone3PilotingEventMoveByEndCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCallback_t ARDrone3NetworkStateWifiScanListChangedCallback;
    void *ARDrone3NetworkStateWifiScanListChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCallback_t ARDrone3NetworkStateAllWifiScanChangedCallback;
    void *ARDrone3NetworkStateAllWifiScanChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCallback_t ARDrone3NetworkStateWifiAuthChannelListChangedCallback;
    void *ARDrone3NetworkStateWifiAuthChannelListChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCallback_t ARDrone3NetworkStateAllWifiAuthChannelChangedCallback;
    void *ARDrone3NetworkStateAllWifiAuthChannelChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback_t ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback;
    void *ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCallback_t ARDrone3PilotingSettingsStateMaxTiltChangedCallback;
    void *ARDrone3PilotingSettingsStateMaxTiltChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCallback_t ARDrone3PilotingSettingsStateAbsolutControlChangedCallback;
    void *ARDrone3PilotingSettingsStateAbsolutControlChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCallback_t ARDrone3PilotingSettingsStateMaxDistanceChangedCallback;
    void *ARDrone3PilotingSettingsStateMaxDistanceChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback_t ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback;
    void *ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback_t ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback;
    void *ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback_t ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback;
    void *ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback_t ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback;
    void *ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback_t ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback;
    void *ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback_t ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback;
    void *ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCallback_t ARDrone3PilotingSettingsStateBankedTurnChangedCallback;
    void *ARDrone3PilotingSettingsStateBankedTurnChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCallback_t ARDrone3PilotingSettingsStateMinAltitudeChangedCallback;
    void *ARDrone3PilotingSettingsStateMinAltitudeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback_t ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback;
    void *ARDrone3PilotingSettingsStateCirclingDirectionChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback_t ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback;
    void *ARDrone3PilotingSettingsStateCirclingRadiusChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback_t ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback;
    void *ARDrone3PilotingSettingsStateCirclingAltitudeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCallback_t ARDrone3PilotingSettingsStatePitchModeChangedCallback;
    void *ARDrone3PilotingSettingsStatePitchModeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback_t ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback;
    void *ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback_t ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback;
    void *ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCallback_t ARDrone3SpeedSettingsStateHullProtectionChangedCallback;
    void *ARDrone3SpeedSettingsStateHullProtectionChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCallback_t ARDrone3SpeedSettingsStateOutdoorChangedCallback;
    void *ARDrone3SpeedSettingsStateOutdoorChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback_t ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback;
    void *ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCallback_t ARDrone3NetworkSettingsStateWifiSelectionChangedCallback;
    void *ARDrone3NetworkSettingsStateWifiSelectionChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCallback_t ARDrone3NetworkSettingsStateWifiSecurityChangedCallback;
    void *ARDrone3NetworkSettingsStateWifiSecurityChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCallback_t ARDrone3NetworkSettingsStateWifiSecurityCallback;
    void *ARDrone3NetworkSettingsStateWifiSecurityCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCallback_t ARDrone3SettingsStateProductMotorVersionListChangedCallback;
    void *ARDrone3SettingsStateProductMotorVersionListChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCallback_t ARDrone3SettingsStateProductGPSVersionChangedCallback;
    void *ARDrone3SettingsStateProductGPSVersionChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCallback_t ARDrone3SettingsStateMotorErrorStateChangedCallback;
    void *ARDrone3SettingsStateMotorErrorStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCallback_t ARDrone3SettingsStateMotorSoftwareVersionChangedCallback;
    void *ARDrone3SettingsStateMotorSoftwareVersionChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCallback_t ARDrone3SettingsStateMotorFlightsStatusChangedCallback;
    void *ARDrone3SettingsStateMotorFlightsStatusChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCallback_t ARDrone3SettingsStateMotorErrorLastErrorChangedCallback;
    void *ARDrone3SettingsStateMotorErrorLastErrorChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCallback_t ARDrone3SettingsStateP7IDCallback;
    void *ARDrone3SettingsStateP7IDCustom;
    ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCallback_t ARDrone3SettingsStateCPUIDCallback;
    void *ARDrone3SettingsStateCPUIDCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCallback_t ARDrone3PictureSettingsStatePictureFormatChangedCallback;
    void *ARDrone3PictureSettingsStatePictureFormatChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback_t ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback;
    void *ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCallback_t ARDrone3PictureSettingsStateExpositionChangedCallback;
    void *ARDrone3PictureSettingsStateExpositionChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCallback_t ARDrone3PictureSettingsStateSaturationChangedCallback;
    void *ARDrone3PictureSettingsStateSaturationChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCallback_t ARDrone3PictureSettingsStateTimelapseChangedCallback;
    void *ARDrone3PictureSettingsStateTimelapseChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCallback_t ARDrone3PictureSettingsStateVideoAutorecordChangedCallback;
    void *ARDrone3PictureSettingsStateVideoAutorecordChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback_t ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback;
    void *ARDrone3PictureSettingsStateVideoStabilizationModeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback_t ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback;
    void *ARDrone3PictureSettingsStateVideoRecordingModeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCallback_t ARDrone3PictureSettingsStateVideoFramerateChangedCallback;
    void *ARDrone3PictureSettingsStateVideoFramerateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCallback_t ARDrone3PictureSettingsStateVideoResolutionsChangedCallback;
    void *ARDrone3PictureSettingsStateVideoResolutionsChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCallback_t ARDrone3MediaStreamingStateVideoEnableChangedCallback;
    void *ARDrone3MediaStreamingStateVideoEnableChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCallback_t ARDrone3MediaStreamingStateVideoStreamModeChangedCallback;
    void *ARDrone3MediaStreamingStateVideoStreamModeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCallback_t ARDrone3GPSSettingsStateHomeChangedCallback;
    void *ARDrone3GPSSettingsStateHomeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCallback_t ARDrone3GPSSettingsStateResetHomeChangedCallback;
    void *ARDrone3GPSSettingsStateResetHomeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCallback_t ARDrone3GPSSettingsStateGPSFixStateChangedCallback;
    void *ARDrone3GPSSettingsStateGPSFixStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback_t ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback;
    void *ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCallback_t ARDrone3GPSSettingsStateHomeTypeChangedCallback;
    void *ARDrone3GPSSettingsStateHomeTypeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback_t ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback;
    void *ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCallback_t ARDrone3CameraStateOrientationCallback;
    void *ARDrone3CameraStateOrientationCustom;
    ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCallback_t ARDrone3CameraStateDefaultCameraOrientationCallback;
    void *ARDrone3CameraStateDefaultCameraOrientationCustom;
    ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCallback_t ARDrone3AntiflickeringStateElectricFrequencyChangedCallback;
    void *ARDrone3AntiflickeringStateElectricFrequencyChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCallback_t ARDrone3AntiflickeringStateModeChangedCallback;
    void *ARDrone3AntiflickeringStateModeChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCallback_t ARDrone3GPSStateNumberOfSatelliteChangedCallback;
    void *ARDrone3GPSStateNumberOfSatelliteChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCallback_t ARDrone3GPSStateHomeTypeAvailabilityChangedCallback;
    void *ARDrone3GPSStateHomeTypeAvailabilityChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCallback_t ARDrone3GPSStateHomeTypeChosenChangedCallback;
    void *ARDrone3GPSStateHomeTypeChosenChangedCustom;
    ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCallback_t ARDrone3PROStateFeaturesCallback;
    void *ARDrone3PROStateFeaturesCustom;

    // Feature common
    ARCOMMANDS_Decoder_CommonNetworkDisconnectCallback_t CommonNetworkDisconnectCallback;
    void *CommonNetworkDisconnectCustom;
    ARCOMMANDS_Decoder_CommonSettingsAllSettingsCallback_t CommonSettingsAllSettingsCallback;
    void *CommonSettingsAllSettingsCustom;
    ARCOMMANDS_Decoder_CommonSettingsResetCallback_t CommonSettingsResetCallback;
    void *CommonSettingsResetCustom;
    ARCOMMANDS_Decoder_CommonSettingsProductNameCallback_t CommonSettingsProductNameCallback;
    void *CommonSettingsProductNameCustom;
    ARCOMMANDS_Decoder_CommonSettingsCountryCallback_t CommonSettingsCountryCallback;
    void *CommonSettingsCountryCustom;
    ARCOMMANDS_Decoder_CommonSettingsAutoCountryCallback_t CommonSettingsAutoCountryCallback;
    void *CommonSettingsAutoCountryCustom;
    ARCOMMANDS_Decoder_CommonCommonAllStatesCallback_t CommonCommonAllStatesCallback;
    void *CommonCommonAllStatesCustom;
    ARCOMMANDS_Decoder_CommonCommonCurrentDateCallback_t CommonCommonCurrentDateCallback;
    void *CommonCommonCurrentDateCustom;
    ARCOMMANDS_Decoder_CommonCommonCurrentTimeCallback_t CommonCommonCurrentTimeCallback;
    void *CommonCommonCurrentTimeCustom;
    ARCOMMANDS_Decoder_CommonCommonRebootCallback_t CommonCommonRebootCallback;
    void *CommonCommonRebootCustom;
    ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCallback_t CommonOverHeatSwitchOffCallback;
    void *CommonOverHeatSwitchOffCustom;
    ARCOMMANDS_Decoder_CommonOverHeatVentilateCallback_t CommonOverHeatVentilateCallback;
    void *CommonOverHeatVentilateCustom;
    ARCOMMANDS_Decoder_CommonControllerIsPilotingCallback_t CommonControllerIsPilotingCallback;
    void *CommonControllerIsPilotingCustom;
    ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCallback_t CommonWifiSettingsOutdoorSettingCallback;
    void *CommonWifiSettingsOutdoorSettingCustom;
    ARCOMMANDS_Decoder_CommonMavlinkStartCallback_t CommonMavlinkStartCallback;
    void *CommonMavlinkStartCustom;
    ARCOMMANDS_Decoder_CommonMavlinkPauseCallback_t CommonMavlinkPauseCallback;
    void *CommonMavlinkPauseCustom;
    ARCOMMANDS_Decoder_CommonMavlinkStopCallback_t CommonMavlinkStopCallback;
    void *CommonMavlinkStopCustom;
    ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCallback_t CommonCalibrationMagnetoCalibrationCallback;
    void *CommonCalibrationMagnetoCalibrationCustom;
    ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCallback_t CommonCalibrationPitotCalibrationCallback;
    void *CommonCalibrationPitotCalibrationCustom;
    ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCallback_t CommonGPSControllerPositionForRunCallback;
    void *CommonGPSControllerPositionForRunCustom;
    ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCallback_t CommonAudioControllerReadyForStreamingCallback;
    void *CommonAudioControllerReadyForStreamingCustom;
    ARCOMMANDS_Decoder_CommonHeadlightsIntensityCallback_t CommonHeadlightsIntensityCallback;
    void *CommonHeadlightsIntensityCustom;
    ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCallback_t CommonAnimationsStartAnimationCallback;
    void *CommonAnimationsStartAnimationCustom;
    ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCallback_t CommonAnimationsStopAnimationCallback;
    void *CommonAnimationsStopAnimationCustom;
    ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCallback_t CommonAnimationsStopAllAnimationsCallback;
    void *CommonAnimationsStopAllAnimationsCustom;
    ARCOMMANDS_Decoder_CommonAccessoryConfigCallback_t CommonAccessoryConfigCallback;
    void *CommonAccessoryConfigCustom;
    ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCallback_t CommonChargerSetMaxChargeRateCallback;
    void *CommonChargerSetMaxChargeRateCustom;
    ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCallback_t CommonNetworkEventDisconnectionCallback;
    void *CommonNetworkEventDisconnectionCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCallback_t CommonSettingsStateAllSettingsChangedCallback;
    void *CommonSettingsStateAllSettingsChangedCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCallback_t CommonSettingsStateResetChangedCallback;
    void *CommonSettingsStateResetChangedCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCallback_t CommonSettingsStateProductNameChangedCallback;
    void *CommonSettingsStateProductNameChangedCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCallback_t CommonSettingsStateProductVersionChangedCallback;
    void *CommonSettingsStateProductVersionChangedCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCallback_t CommonSettingsStateProductSerialHighChangedCallback;
    void *CommonSettingsStateProductSerialHighChangedCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCallback_t CommonSettingsStateProductSerialLowChangedCallback;
    void *CommonSettingsStateProductSerialLowChangedCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCallback_t CommonSettingsStateCountryChangedCallback;
    void *CommonSettingsStateCountryChangedCustom;
    ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCallback_t CommonSettingsStateAutoCountryChangedCallback;
    void *CommonSettingsStateAutoCountryChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCallback_t CommonCommonStateAllStatesChangedCallback;
    void *CommonCommonStateAllStatesChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCallback_t CommonCommonStateBatteryStateChangedCallback;
    void *CommonCommonStateBatteryStateChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCallback_t CommonCommonStateMassStorageStateListChangedCallback;
    void *CommonCommonStateMassStorageStateListChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCallback_t CommonCommonStateMassStorageInfoStateListChangedCallback;
    void *CommonCommonStateMassStorageInfoStateListChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCallback_t CommonCommonStateCurrentDateChangedCallback;
    void *CommonCommonStateCurrentDateChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCallback_t CommonCommonStateCurrentTimeChangedCallback;
    void *CommonCommonStateCurrentTimeChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCallback_t CommonCommonStateMassStorageInfoRemainingListChangedCallback;
    void *CommonCommonStateMassStorageInfoRemainingListChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCallback_t CommonCommonStateWifiSignalChangedCallback;
    void *CommonCommonStateWifiSignalChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCallback_t CommonCommonStateSensorsStatesListChangedCallback;
    void *CommonCommonStateSensorsStatesListChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateProductModelCallback_t CommonCommonStateProductModelCallback;
    void *CommonCommonStateProductModelCustom;
    ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCallback_t CommonCommonStateCountryListKnownCallback;
    void *CommonCommonStateCountryListKnownCustom;
    ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCallback_t CommonCommonStateDeprecatedMassStorageContentChangedCallback;
    void *CommonCommonStateDeprecatedMassStorageContentChangedCustom;
    ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCallback_t CommonCommonStateMassStorageContentCallback;
    void *CommonCommonStateMassStorageContentCustom;
    ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCallback_t CommonCommonStateMassStorageContentForCurrentRunCallback;
    void *CommonCommonStateMassStorageContentForCurrentRunCustom;
    ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCallback_t CommonOverHeatStateOverHeatChangedCallback;
    void *CommonOverHeatStateOverHeatChangedCustom;
    ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCallback_t CommonOverHeatStateOverHeatRegulationChangedCallback;
    void *CommonOverHeatStateOverHeatRegulationChangedCustom;
    ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCallback_t CommonWifiSettingsStateOutdoorSettingsChangedCallback;
    void *CommonWifiSettingsStateOutdoorSettingsChangedCustom;
    ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCallback_t CommonMavlinkStateMavlinkFilePlayingStateChangedCallback;
    void *CommonMavlinkStateMavlinkFilePlayingStateChangedCustom;
    ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCallback_t CommonMavlinkStateMavlinkPlayErrorStateChangedCallback;
    void *CommonMavlinkStateMavlinkPlayErrorStateChangedCustom;
    ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCallback_t CommonCalibrationStateMagnetoCalibrationStateChangedCallback;
    void *CommonCalibrationStateMagnetoCalibrationStateChangedCustom;
    ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCallback_t CommonCalibrationStateMagnetoCalibrationRequiredStateCallback;
    void *CommonCalibrationStateMagnetoCalibrationRequiredStateCustom;
    ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback_t CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback;
    void *CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom;
    ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCallback_t CommonCalibrationStateMagnetoCalibrationStartedChangedCallback;
    void *CommonCalibrationStateMagnetoCalibrationStartedChangedCustom;
    ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCallback_t CommonCalibrationStatePitotCalibrationStateChangedCallback;
    void *CommonCalibrationStatePitotCalibrationStateChangedCustom;
    ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCallback_t CommonCameraSettingsStateCameraSettingsChangedCallback;
    void *CommonCameraSettingsStateCameraSettingsChangedCustom;
    ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCallback_t CommonFlightPlanStateAvailabilityStateChangedCallback;
    void *CommonFlightPlanStateAvailabilityStateChangedCustom;
    ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCallback_t CommonFlightPlanStateComponentStateListChangedCallback;
    void *CommonFlightPlanStateComponentStateListChangedCustom;
    ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCallback_t CommonFlightPlanStateLockStateChangedCallback;
    void *CommonFlightPlanStateLockStateChangedCustom;
    ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCallback_t CommonFlightPlanEventStartingErrorEventCallback;
    void *CommonFlightPlanEventStartingErrorEventCustom;
    ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCallback_t CommonFlightPlanEventSpeedBridleEventCallback;
    void *CommonFlightPlanEventSpeedBridleEventCustom;
    ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCallback_t CommonARLibsVersionsStateControllerLibARCommandsVersionCallback;
    void *CommonARLibsVersionsStateControllerLibARCommandsVersionCustom;
    ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback_t CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback;
    void *CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom;
    ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback_t CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback;
    void *CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom;
    ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCallback_t CommonAudioStateAudioStreamingRunningCallback;
    void *CommonAudioStateAudioStreamingRunningCustom;
    ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCallback_t CommonHeadlightsStateIntensityChangedCallback;
    void *CommonHeadlightsStateIntensityChangedCustom;
    ARCOMMANDS_Decoder_CommonAnimationsStateListCallback_t CommonAnimationsStateListCallback;
    void *CommonAnimationsStateListCustom;
    ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCallback_t CommonAccessoryStateSupportedAccessoriesListChangedCallback;
    void *CommonAccessoryStateSupportedAccessoriesListChangedCustom;
    ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCallback_t CommonAccessoryStateAccessoryConfigChangedCallback;
    void *CommonAccessoryStateAccessoryConfigChangedCustom;
    ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCallback_t CommonAccessoryStateAccessoryConfigModificationEnabledCallback;
    void *CommonAccessoryStateAccessoryConfigModificationEnabledCustom;
    ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCallback_t CommonChargerStateMaxChargeRateChangedCallback;
    void *CommonChargerStateMaxChargeRateChangedCustom;
    ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCallback_t CommonChargerStateCurrentChargeStateChangedCallback;
    void *CommonChargerStateCurrentChargeStateChangedCustom;
    ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCallback_t CommonChargerStateLastChargeRateChangedCallback;
    void *CommonChargerStateLastChargeRateChangedCustom;
    ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCallback_t CommonChargerStateChargingInfoCallback;
    void *CommonChargerStateChargingInfoCustom;
    ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCallback_t CommonRunStateRunIdChangedCallback;
    void *CommonRunStateRunIdChangedCustom;

    // Feature controller_info
    ARCOMMANDS_Decoder_ControllerInfoGpsCallback_t ControllerInfoGpsCallback;
    void *ControllerInfoGpsCustom;
    ARCOMMANDS_Decoder_ControllerInfoBarometerCallback_t ControllerInfoBarometerCallback;
    void *ControllerInfoBarometerCustom;

    // Feature debug
    ARCOMMANDS_Decoder_DebugGetAllSettingsCallback_t DebugGetAllSettingsCallback;
    void *DebugGetAllSettingsCustom;
    ARCOMMANDS_Decoder_DebugSetSettingCallback_t DebugSetSettingCallback;
    void *DebugSetSettingCustom;
    ARCOMMANDS_Decoder_DebugSettingsInfoCallback_t DebugSettingsInfoCallback;
    void *DebugSettingsInfoCustom;
    ARCOMMANDS_Decoder_DebugSettingsListCallback_t DebugSettingsListCallback;
    void *DebugSettingsListCustom;

    // Feature drone_manager
    ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCallback_t DroneManagerDiscoverDronesCallback;
    void *DroneManagerDiscoverDronesCustom;
    ARCOMMANDS_Decoder_DroneManagerConnectCallback_t DroneManagerConnectCallback;
    void *DroneManagerConnectCustom;
    ARCOMMANDS_Decoder_DroneManagerForgetCallback_t DroneManagerForgetCallback;
    void *DroneManagerForgetCustom;
    ARCOMMANDS_Decoder_DroneManagerDroneListItemCallback_t DroneManagerDroneListItemCallback;
    void *DroneManagerDroneListItemCustom;
    ARCOMMANDS_Decoder_DroneManagerConnectionStateCallback_t DroneManagerConnectionStateCallback;
    void *DroneManagerConnectionStateCustom;
    ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCallback_t DroneManagerAuthenticationFailedCallback;
    void *DroneManagerAuthenticationFailedCustom;
    ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCallback_t DroneManagerConnectionRefusedCallback;
    void *DroneManagerConnectionRefusedCustom;

    // Feature mapper
    ARCOMMANDS_Decoder_MapperGrabCallback_t MapperGrabCallback;
    void *MapperGrabCustom;
    ARCOMMANDS_Decoder_MapperMapButtonActionCallback_t MapperMapButtonActionCallback;
    void *MapperMapButtonActionCustom;
    ARCOMMANDS_Decoder_MapperMapAxisActionCallback_t MapperMapAxisActionCallback;
    void *MapperMapAxisActionCustom;
    ARCOMMANDS_Decoder_MapperResetMappingCallback_t MapperResetMappingCallback;
    void *MapperResetMappingCustom;
    ARCOMMANDS_Decoder_MapperSetExpoCallback_t MapperSetExpoCallback;
    void *MapperSetExpoCustom;
    ARCOMMANDS_Decoder_MapperSetInvertedCallback_t MapperSetInvertedCallback;
    void *MapperSetInvertedCustom;
    ARCOMMANDS_Decoder_MapperGrabStateCallback_t MapperGrabStateCallback;
    void *MapperGrabStateCustom;
    ARCOMMANDS_Decoder_MapperGrabButtonEventCallback_t MapperGrabButtonEventCallback;
    void *MapperGrabButtonEventCustom;
    ARCOMMANDS_Decoder_MapperGrabAxisEventCallback_t MapperGrabAxisEventCallback;
    void *MapperGrabAxisEventCustom;
    ARCOMMANDS_Decoder_MapperButtonMappingItemCallback_t MapperButtonMappingItemCallback;
    void *MapperButtonMappingItemCustom;
    ARCOMMANDS_Decoder_MapperAxisMappingItemCallback_t MapperAxisMappingItemCallback;
    void *MapperAxisMappingItemCustom;
    ARCOMMANDS_Decoder_MapperApplicationAxisEventCallback_t MapperApplicationAxisEventCallback;
    void *MapperApplicationAxisEventCustom;
    ARCOMMANDS_Decoder_MapperApplicationButtonEventCallback_t MapperApplicationButtonEventCallback;
    void *MapperApplicationButtonEventCustom;
    ARCOMMANDS_Decoder_MapperExpoMapItemCallback_t MapperExpoMapItemCallback;
    void *MapperExpoMapItemCustom;
    ARCOMMANDS_Decoder_MapperInvertedMapItemCallback_t MapperInvertedMapItemCallback;
    void *MapperInvertedMapItemCustom;

	// Feature powerup
    ARCOMMANDS_Decoder_PowerupPilotingPCMDCallback_t PowerupPilotingPCMDCallback;
    void *PowerupPilotingPCMDCustom;
    ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCallback_t PowerupPilotingUserTakeOffCallback;
    void *PowerupPilotingUserTakeOffCustom;
    ARCOMMANDS_Decoder_PowerupPilotingMotorModeCallback_t PowerupPilotingMotorModeCallback;
    void *PowerupPilotingMotorModeCustom;
    ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCallback_t PowerupPilotingSettingsSetCallback;
    void *PowerupPilotingSettingsSetCustom;
    ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Callback_t PowerupMediaRecordPictureV2Callback;
    void *PowerupMediaRecordPictureV2Custom;
    ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Callback_t PowerupMediaRecordVideoV2Callback;
    void *PowerupMediaRecordVideoV2Custom;
    ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCallback_t PowerupNetworkSettingsWifiSelectionCallback;
    void *PowerupNetworkSettingsWifiSelectionCustom;
    ARCOMMANDS_Decoder_PowerupNetworkWifiScanCallback_t PowerupNetworkWifiScanCallback;
    void *PowerupNetworkWifiScanCustom;
    ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCallback_t PowerupNetworkWifiAuthChannelCallback;
    void *PowerupNetworkWifiAuthChannelCustom;
    ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCallback_t PowerupMediaStreamingVideoEnableCallback;
    void *PowerupMediaStreamingVideoEnableCustom;
    ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCallback_t PowerupVideoSettingsAutorecordCallback;
    void *PowerupVideoSettingsAutorecordCustom;
    ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCallback_t PowerupVideoSettingsVideoModeCallback;
    void *PowerupVideoSettingsVideoModeCustom;
    ARCOMMANDS_Decoder_PowerupSoundsBuzzCallback_t PowerupSoundsBuzzCallback;
    void *PowerupSoundsBuzzCustom;
    ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCallback_t PowerupPilotingStateAlertStateChangedCallback;
    void *PowerupPilotingStateAlertStateChangedCustom;
    ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCallback_t PowerupPilotingStateFlyingStateChangedCallback;
    void *PowerupPilotingStateFlyingStateChangedCustom;
    ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCallback_t PowerupPilotingStateMotorModeChangedCallback;
    void *PowerupPilotingStateMotorModeChangedCustom;
    ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCallback_t PowerupPilotingStateAttitudeChangedCallback;
    void *PowerupPilotingStateAttitudeChangedCustom;
    ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCallback_t PowerupPilotingStateAltitudeChangedCallback;
    void *PowerupPilotingStateAltitudeChangedCustom;
    ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCallback_t PowerupPilotingSettingsStateSettingChangedCallback;
    void *PowerupPilotingSettingsStateSettingChangedCustom;
    ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Callback_t PowerupMediaRecordStatePictureStateChangedV2Callback;
    void *PowerupMediaRecordStatePictureStateChangedV2Custom;
    ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Callback_t PowerupMediaRecordStateVideoStateChangedV2Callback;
    void *PowerupMediaRecordStateVideoStateChangedV2Custom;
    ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCallback_t PowerupMediaRecordEventPictureEventChangedCallback;
    void *PowerupMediaRecordEventPictureEventChangedCustom;
    ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCallback_t PowerupMediaRecordEventVideoEventChangedCallback;
    void *PowerupMediaRecordEventVideoEventChangedCustom;
    ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCallback_t PowerupNetworkSettingsStateWifiSelectionChangedCallback;
    void *PowerupNetworkSettingsStateWifiSelectionChangedCustom;
    ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCallback_t PowerupNetworkStateWifiScanListChangedCallback;
    void *PowerupNetworkStateWifiScanListChangedCustom;
    ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCallback_t PowerupNetworkStateAllWifiScanChangedCallback;
    void *PowerupNetworkStateAllWifiScanChangedCustom;
    ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCallback_t PowerupNetworkStateWifiAuthChannelListChangedCallback;
    void *PowerupNetworkStateWifiAuthChannelListChangedCustom;
    ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCallback_t PowerupNetworkStateAllWifiAuthChannelChangedCallback;
    void *PowerupNetworkStateAllWifiAuthChannelChangedCustom;
    ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCallback_t PowerupNetworkStateLinkQualityChangedCallback;
    void *PowerupNetworkStateLinkQualityChangedCustom;
    ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCallback_t PowerupMediaStreamingStateVideoEnableChangedCallback;
    void *PowerupMediaStreamingStateVideoEnableChangedCustom;
    ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCallback_t PowerupVideoSettingsStateAutorecordChangedCallback;
    void *PowerupVideoSettingsStateAutorecordChangedCustom;
    ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCallback_t PowerupVideoSettingsStateVideoModeChangedCallback;
    void *PowerupVideoSettingsStateVideoModeChangedCustom;
    ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCallback_t PowerupSoundsStateBuzzChangedCallback;
    void *PowerupSoundsStateBuzzChangedCustom;

    // Feature pro
    ARCOMMANDS_Decoder_ProProBoughtFeaturesCallback_t ProProBoughtFeaturesCallback;
    void *ProProBoughtFeaturesCustom;
    ARCOMMANDS_Decoder_ProProResponseCallback_t ProProResponseCallback;
    void *ProProResponseCustom;
    ARCOMMANDS_Decoder_ProProActivateFeaturesCallback_t ProProActivateFeaturesCallback;
    void *ProProActivateFeaturesCustom;
    ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCallback_t ProProStateSupportedFeaturesCallback;
    void *ProProStateSupportedFeaturesCustom;
    ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCallback_t ProProStateFeaturesActivatedCallback;
    void *ProProStateFeaturesActivatedCustom;
    ARCOMMANDS_Decoder_ProProEventChallengeEventCallback_t ProProEventChallengeEventCallback;
    void *ProProEventChallengeEventCustom;

    // Feature rc
    ARCOMMANDS_Decoder_RcMonitorChannelsCallback_t RcMonitorChannelsCallback;
    void *RcMonitorChannelsCustom;
    ARCOMMANDS_Decoder_RcStartCalibrationCallback_t RcStartCalibrationCallback;
    void *RcStartCalibrationCustom;
    ARCOMMANDS_Decoder_RcInvertChannelCallback_t RcInvertChannelCallback;
    void *RcInvertChannelCustom;
    ARCOMMANDS_Decoder_RcAbortCalibrationCallback_t RcAbortCalibrationCallback;
    void *RcAbortCalibrationCustom;
    ARCOMMANDS_Decoder_RcResetCalibrationCallback_t RcResetCalibrationCallback;
    void *RcResetCalibrationCustom;
    ARCOMMANDS_Decoder_RcReceiverStateCallback_t RcReceiverStateCallback;
    void *RcReceiverStateCustom;
    ARCOMMANDS_Decoder_RcChannelsMonitorStateCallback_t RcChannelsMonitorStateCallback;
    void *RcChannelsMonitorStateCustom;
    ARCOMMANDS_Decoder_RcChannelValueCallback_t RcChannelValueCallback;
    void *RcChannelValueCustom;
    ARCOMMANDS_Decoder_RcCalibrationStateCallback_t RcCalibrationStateCallback;
    void *RcCalibrationStateCustom;
    ARCOMMANDS_Decoder_RcReceiverQualityCallback_t RcReceiverQualityCallback;
    void *RcReceiverQualityCustom;

	// Feature unknown_feature_1
    ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCallback_t UnknownFeature1GeographicRunCallback;
    void *UnknownFeature1GeographicRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCallback_t UnknownFeature1RelativeRunCallback;
    void *UnknownFeature1RelativeRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCallback_t UnknownFeature1LookAtRunCallback;
    void *UnknownFeature1LookAtRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCallback_t UnknownFeature1SpiralAnimRunCallback;
    void *UnknownFeature1SpiralAnimRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCallback_t UnknownFeature1SwingAnimRunCallback;
    void *UnknownFeature1SwingAnimRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCallback_t UnknownFeature1BoomerangAnimRunCallback;
    void *UnknownFeature1BoomerangAnimRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCallback_t UnknownFeature1CandleAnimRunCallback;
    void *UnknownFeature1CandleAnimRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCallback_t UnknownFeature1DollySlideAnimRunCallback;
    void *UnknownFeature1DollySlideAnimRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCallback_t UnknownFeature1UserFramingPositionCallback;
    void *UnknownFeature1UserFramingPositionCustom;
    ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCallback_t UnknownFeature1UserGPSDataCallback;
    void *UnknownFeature1UserGPSDataCustom;
    ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCallback_t UnknownFeature1UserBaroDataCallback;
    void *UnknownFeature1UserBaroDataCustom;
    ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCallback_t UnknownFeature1LynxDetectionCallback;
    void *UnknownFeature1LynxDetectionCustom;
    ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCallback_t UnknownFeature1AvailabilityCallback;
    void *UnknownFeature1AvailabilityCustom;
    ARCOMMANDS_Decoder_UnknownFeature1RunCallback_t UnknownFeature1RunCallback;
    void *UnknownFeature1RunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCallback_t UnknownFeature1GeographicConfigChangedCallback;
    void *UnknownFeature1GeographicConfigChangedCustom;
    ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCallback_t UnknownFeature1RelativeConfigChangedCallback;
    void *UnknownFeature1RelativeConfigChangedCustom;
    ARCOMMANDS_Decoder_UnknownFeature1AnimRunCallback_t UnknownFeature1AnimRunCallback;
    void *UnknownFeature1AnimRunCustom;
    ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCallback_t UnknownFeature1SpiralAnimConfigChangedCallback;
    void *UnknownFeature1SpiralAnimConfigChangedCustom;
    ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCallback_t UnknownFeature1SwingAnimConfigChangedCallback;
    void *UnknownFeature1SwingAnimConfigChangedCustom;
    ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCallback_t UnknownFeature1BoomerangAnimConfigChangedCallback;
    void *UnknownFeature1BoomerangAnimConfigChangedCustom;
    ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCallback_t UnknownFeature1CandleAnimConfigChangedCallback;
    void *UnknownFeature1CandleAnimConfigChangedCustom;
    ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCallback_t UnknownFeature1DollySlideAnimConfigChangedCallback;
    void *UnknownFeature1DollySlideAnimConfigChangedCustom;
    ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCallback_t UnknownFeature1UserFramingPositionChangedCallback;
    void *UnknownFeature1UserFramingPositionChangedCustom;

    // Feature wifi
    ARCOMMANDS_Decoder_WifiScanCallback_t WifiScanCallback;
    void *WifiScanCustom;
    ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCallback_t WifiUpdateAuthorizedChannelsCallback;
    void *WifiUpdateAuthorizedChannelsCustom;
    ARCOMMANDS_Decoder_WifiSetApChannelCallback_t WifiSetApChannelCallback;
    void *WifiSetApChannelCustom;
    ARCOMMANDS_Decoder_WifiSetSecurityCallback_t WifiSetSecurityCallback;
    void *WifiSetSecurityCustom;
    ARCOMMANDS_Decoder_WifiSetCountryCallback_t WifiSetCountryCallback;
    void *WifiSetCountryCustom;
    ARCOMMANDS_Decoder_WifiSetEnvironmentCallback_t WifiSetEnvironmentCallback;
    void *WifiSetEnvironmentCustom;
    ARCOMMANDS_Decoder_WifiScannedItemCallback_t WifiScannedItemCallback;
    void *WifiScannedItemCustom;
    ARCOMMANDS_Decoder_WifiAuthorizedChannelCallback_t WifiAuthorizedChannelCallback;
    void *WifiAuthorizedChannelCustom;
    ARCOMMANDS_Decoder_WifiApChannelChangedCallback_t WifiApChannelChangedCallback;
    void *WifiApChannelChangedCustom;
    ARCOMMANDS_Decoder_WifiSecurityChangedCallback_t WifiSecurityChangedCallback;
    void *WifiSecurityChangedCustom;
    ARCOMMANDS_Decoder_WifiCountryChangedCallback_t WifiCountryChangedCallback;
    void *WifiCountryChangedCustom;
    ARCOMMANDS_Decoder_WifiEnvironmentChangedCallback_t WifiEnvironmentChangedCallback;
    void *WifiEnvironmentChangedCustom;
    ARCOMMANDS_Decoder_WifiRssiChangedCallback_t WifiRssiChangedCallback;
    void *WifiRssiChangedCustom;

};


// Constructor
ARCOMMANDS_Decoder_t* ARCOMMANDS_Decoder_NewDecoder (eARCOMMANDS_DECODER_ERROR *error)
{
    ARCOMMANDS_Decoder_t *decoder = NULL;

    decoder = calloc(1, sizeof(*decoder));
    if (decoder)
        ARSAL_Mutex_Init (&decoder->mutex);

    if (error)
        *error = decoder ? ARCOMMANDS_DECODER_OK : ARCOMMANDS_DECODER_ERROR;

    return decoder;
}

// Destructor
void ARCOMMANDS_Decoder_DeleteDecoder (ARCOMMANDS_Decoder_t **decoder)
{
    if (decoder && (*decoder)) {
        ARSAL_Mutex_Destroy(&(*decoder)->mutex);
        free(*decoder);
        *decoder = NULL;
    }
}

// CALLBACK VARIABLES + SETTERS

static ARSAL_Mutex_t ARCOMMANDS_Decoder_Mutex;
static int ARCOMMANDS_Decoder_IsInit = 0;
static int ARCOMMANDS_Decoder_Init (void)
{
    if ((ARCOMMANDS_Decoder_IsInit == 0) &&
        (ARSAL_Mutex_Init (&ARCOMMANDS_Decoder_Mutex) == 0))
    {
        ARCOMMANDS_Decoder_IsInit = 1;
    } // No else --> Do nothing if already initialized
    return ARCOMMANDS_Decoder_IsInit;
}

// Feature generic

void ARCOMMANDS_Decoder_SetGenericDefaultCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_GenericDefaultCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->GenericDefaultCallback = callback;
    decoder->GenericDefaultCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_GenericDefaultCallback_t ARCOMMANDS_Decoder_GenericDefaultCb = NULL;
static void *ARCOMMANDS_Decoder_GenericDefaultCustom = NULL;
void ARCOMMANDS_Decoder_SetGenericDefaultCallback (ARCOMMANDS_Decoder_GenericDefaultCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_GenericDefaultCb = callback;
        ARCOMMANDS_Decoder_GenericDefaultCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature ARDrone3

void ARCOMMANDS_Decoder_SetARDrone3PilotingFlatTrimCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingFlatTrimCallback = callback;
    decoder->ARDrone3PilotingFlatTrimCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingFlatTrimCallback (ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingTakeOffCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingTakeOffCallback = callback;
    decoder->ARDrone3PilotingTakeOffCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingTakeOffCallback (ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingPCMDCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingPCMDCallback = callback;
    decoder->ARDrone3PilotingPCMDCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingPCMDCallback (ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingLandingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingLandingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingLandingCallback = callback;
    decoder->ARDrone3PilotingLandingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingLandingCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingLandingCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingLandingCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingLandingCallback (ARCOMMANDS_Decoder_ARDrone3PilotingLandingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingLandingCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingLandingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingEmergencyCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingEmergencyCallback = callback;
    decoder->ARDrone3PilotingEmergencyCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingEmergencyCallback (ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingNavigateHomeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingNavigateHomeCallback = callback;
    decoder->ARDrone3PilotingNavigateHomeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingNavigateHomeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingAutoTakeOffModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingAutoTakeOffModeCallback = callback;
    decoder->ARDrone3PilotingAutoTakeOffModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingAutoTakeOffModeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingMoveByCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingMoveByCallback = callback;
    decoder->ARDrone3PilotingMoveByCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingMoveByCallback (ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingUserTakeOffCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingUserTakeOffCallback = callback;
    decoder->ARDrone3PilotingUserTakeOffCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingUserTakeOffCallback (ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingCircleCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingCircleCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingCircleCallback = callback;
    decoder->ARDrone3PilotingCircleCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingCircleCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingCircleCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingCircleCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingCircleCallback (ARCOMMANDS_Decoder_ARDrone3PilotingCircleCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingCircleCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingCircleCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3AnimationsFlipCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3AnimationsFlipCallback = callback;
    decoder->ARDrone3AnimationsFlipCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCallback_t ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AnimationsFlipCallback (ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3CameraOrientationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3CameraOrientationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3CameraOrientationCallback = callback;
    decoder->ARDrone3CameraOrientationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3CameraOrientationCallback_t ARCOMMANDS_Decoder_ARDrone3CameraOrientationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3CameraOrientationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3CameraOrientationCallback (ARCOMMANDS_Decoder_ARDrone3CameraOrientationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3CameraOrientationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3CameraOrientationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordPictureCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordPictureCallback = callback;
    decoder->ARDrone3MediaRecordPictureCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordPictureCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordVideoCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordVideoCallback = callback;
    decoder->ARDrone3MediaRecordVideoCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordVideoCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordPictureV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordPictureV2Callback = callback;
    decoder->ARDrone3MediaRecordPictureV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Callback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Cb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Custom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordPictureV2Callback (ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Cb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordVideoV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordVideoV2Callback = callback;
    decoder->ARDrone3MediaRecordVideoV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Callback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Cb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Custom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordVideoV2Callback (ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Cb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkWifiScanCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkWifiScanCallback = callback;
    decoder->ARDrone3NetworkWifiScanCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkWifiScanCallback (ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkWifiAuthChannelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkWifiAuthChannelCallback = callback;
    decoder->ARDrone3NetworkWifiAuthChannelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkWifiAuthChannelCallback (ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxAltitudeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsMaxAltitudeCallback = callback;
    decoder->ARDrone3PilotingSettingsMaxAltitudeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxAltitudeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxTiltCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsMaxTiltCallback = callback;
    decoder->ARDrone3PilotingSettingsMaxTiltCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxTiltCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsAbsolutControlCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsAbsolutControlCallback = callback;
    decoder->ARDrone3PilotingSettingsAbsolutControlCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsAbsolutControlCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxDistanceCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsMaxDistanceCallback = callback;
    decoder->ARDrone3PilotingSettingsMaxDistanceCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMaxDistanceCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsNoFlyOverMaxDistanceCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback = callback;
    decoder->ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback = callback;
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback = callback;
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback = callback;
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback = callback;
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback = callback;
    decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsBankedTurnCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsBankedTurnCallback = callback;
    decoder->ARDrone3PilotingSettingsBankedTurnCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsBankedTurnCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMinAltitudeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsMinAltitudeCallback = callback;
    decoder->ARDrone3PilotingSettingsMinAltitudeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsMinAltitudeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsCirclingDirectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsCirclingDirectionCallback = callback;
    decoder->ARDrone3PilotingSettingsCirclingDirectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsCirclingDirectionCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsCirclingRadiusCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsCirclingRadiusCallback = callback;
    decoder->ARDrone3PilotingSettingsCirclingRadiusCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsCirclingRadiusCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsCirclingAltitudeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsCirclingAltitudeCallback = callback;
    decoder->ARDrone3PilotingSettingsCirclingAltitudeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsCirclingAltitudeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsPitchModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsPitchModeCallback = callback;
    decoder->ARDrone3PilotingSettingsPitchModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsPitchModeCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsMaxVerticalSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsMaxVerticalSpeedCallback = callback;
    decoder->ARDrone3SpeedSettingsMaxVerticalSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsMaxVerticalSpeedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsMaxRotationSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsMaxRotationSpeedCallback = callback;
    decoder->ARDrone3SpeedSettingsMaxRotationSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsMaxRotationSpeedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsHullProtectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsHullProtectionCallback = callback;
    decoder->ARDrone3SpeedSettingsHullProtectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsHullProtectionCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsOutdoorCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsOutdoorCallback = callback;
    decoder->ARDrone3SpeedSettingsOutdoorCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsOutdoorCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsMaxPitchRollRotationSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback = callback;
    decoder->ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsWifiSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkSettingsWifiSelectionCallback = callback;
    decoder->ARDrone3NetworkSettingsWifiSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsWifiSelectionCallback (ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsWifiSecurityCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkSettingsWifiSecurityCallback = callback;
    decoder->ARDrone3NetworkSettingsWifiSecurityCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsWifiSecurityCallback (ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsPictureFormatSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsPictureFormatSelectionCallback = callback;
    decoder->ARDrone3PictureSettingsPictureFormatSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsPictureFormatSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsAutoWhiteBalanceSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback = callback;
    decoder->ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsExpositionSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsExpositionSelectionCallback = callback;
    decoder->ARDrone3PictureSettingsExpositionSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsExpositionSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsSaturationSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsSaturationSelectionCallback = callback;
    decoder->ARDrone3PictureSettingsSaturationSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsSaturationSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsTimelapseSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsTimelapseSelectionCallback = callback;
    decoder->ARDrone3PictureSettingsTimelapseSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsTimelapseSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoAutorecordSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsVideoAutorecordSelectionCallback = callback;
    decoder->ARDrone3PictureSettingsVideoAutorecordSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoAutorecordSelectionCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoStabilizationModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsVideoStabilizationModeCallback = callback;
    decoder->ARDrone3PictureSettingsVideoStabilizationModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoStabilizationModeCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoRecordingModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsVideoRecordingModeCallback = callback;
    decoder->ARDrone3PictureSettingsVideoRecordingModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoRecordingModeCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoFramerateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsVideoFramerateCallback = callback;
    decoder->ARDrone3PictureSettingsVideoFramerateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoFramerateCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoResolutionsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsVideoResolutionsCallback = callback;
    decoder->ARDrone3PictureSettingsVideoResolutionsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsVideoResolutionsCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingVideoEnableCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaStreamingVideoEnableCallback = callback;
    decoder->ARDrone3MediaStreamingVideoEnableCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCallback_t ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingVideoEnableCallback (ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingVideoStreamModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaStreamingVideoStreamModeCallback = callback;
    decoder->ARDrone3MediaStreamingVideoStreamModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCallback_t ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingVideoStreamModeCallback (ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsSetHomeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsSetHomeCallback = callback;
    decoder->ARDrone3GPSSettingsSetHomeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsSetHomeCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsResetHomeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsResetHomeCallback = callback;
    decoder->ARDrone3GPSSettingsResetHomeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsResetHomeCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsSendControllerGPSCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsSendControllerGPSCallback = callback;
    decoder->ARDrone3GPSSettingsSendControllerGPSCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsSendControllerGPSCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsHomeTypeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsHomeTypeCallback = callback;
    decoder->ARDrone3GPSSettingsHomeTypeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsHomeTypeCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsReturnHomeDelayCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsReturnHomeDelayCallback = callback;
    decoder->ARDrone3GPSSettingsReturnHomeDelayCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsReturnHomeDelayCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringElectricFrequencyCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3AntiflickeringElectricFrequencyCallback = callback;
    decoder->ARDrone3AntiflickeringElectricFrequencyCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCallback_t ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringElectricFrequencyCallback (ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringSetModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3AntiflickeringSetModeCallback = callback;
    decoder->ARDrone3AntiflickeringSetModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCallback_t ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringSetModeCallback (ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordStatePictureStateChangedCallback = callback;
    decoder->ARDrone3MediaRecordStatePictureStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordStateVideoStateChangedCallback = callback;
    decoder->ARDrone3MediaRecordStateVideoStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordStatePictureStateChangedV2Callback = callback;
    decoder->ARDrone3MediaRecordStatePictureStateChangedV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Callback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedV2Callback (ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordStateVideoStateChangedV2Callback = callback;
    decoder->ARDrone3MediaRecordStateVideoStateChangedV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Callback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedV2Callback (ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoResolutionStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordStateVideoResolutionStateCallback = callback;
    decoder->ARDrone3MediaRecordStateVideoResolutionStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoResolutionStateCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventPictureEventChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordEventPictureEventChangedCallback = callback;
    decoder->ARDrone3MediaRecordEventPictureEventChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventPictureEventChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventVideoEventChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaRecordEventVideoEventChangedCallback = callback;
    decoder->ARDrone3MediaRecordEventVideoEventChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventVideoEventChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlatTrimChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateFlatTrimChangedCallback = callback;
    decoder->ARDrone3PilotingStateFlatTrimChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlatTrimChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlyingStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateFlyingStateChangedCallback = callback;
    decoder->ARDrone3PilotingStateFlyingStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlyingStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAlertStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateAlertStateChangedCallback = callback;
    decoder->ARDrone3PilotingStateAlertStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAlertStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateNavigateHomeStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateNavigateHomeStateChangedCallback = callback;
    decoder->ARDrone3PilotingStateNavigateHomeStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateNavigateHomeStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStatePositionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStatePositionChangedCallback = callback;
    decoder->ARDrone3PilotingStatePositionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStatePositionChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateSpeedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateSpeedChangedCallback = callback;
    decoder->ARDrone3PilotingStateSpeedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateSpeedChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAttitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateAttitudeChangedCallback = callback;
    decoder->ARDrone3PilotingStateAttitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAttitudeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAutoTakeOffModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateAutoTakeOffModeChangedCallback = callback;
    decoder->ARDrone3PilotingStateAutoTakeOffModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAutoTakeOffModeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAltitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateAltitudeChangedCallback = callback;
    decoder->ARDrone3PilotingStateAltitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateAltitudeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateGpsLocationChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateGpsLocationChangedCallback = callback;
    decoder->ARDrone3PilotingStateGpsLocationChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateGpsLocationChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateLandingStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingStateLandingStateChangedCallback = callback;
    decoder->ARDrone3PilotingStateLandingStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingStateLandingStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingEventMoveByEndCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingEventMoveByEndCallback = callback;
    decoder->ARDrone3PilotingEventMoveByEndCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingEventMoveByEndCallback (ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiScanListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkStateWifiScanListChangedCallback = callback;
    decoder->ARDrone3NetworkStateWifiScanListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiScanListChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiScanChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkStateAllWifiScanChangedCallback = callback;
    decoder->ARDrone3NetworkStateAllWifiScanChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiScanChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiAuthChannelListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkStateWifiAuthChannelListChangedCallback = callback;
    decoder->ARDrone3NetworkStateWifiAuthChannelListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiAuthChannelListChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkStateAllWifiAuthChannelChangedCallback = callback;
    decoder->ARDrone3NetworkStateAllWifiAuthChannelChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiAuthChannelChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxAltitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxAltitudeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxTiltChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateMaxTiltChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateMaxTiltChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxTiltChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAbsolutControlChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateAbsolutControlChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateAbsolutControlChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAbsolutControlChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxDistanceChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateMaxDistanceChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateMaxDistanceChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxDistanceChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback = callback;
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback = callback;
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateBankedTurnChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateBankedTurnChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateBankedTurnChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateBankedTurnChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMinAltitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateMinAltitudeChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateMinAltitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMinAltitudeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingDirectionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateCirclingDirectionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingDirectionChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingRadiusChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateCirclingRadiusChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingRadiusChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingAltitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStateCirclingAltitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStatePitchModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PilotingSettingsStatePitchModeChangedCallback = callback;
    decoder->ARDrone3PilotingSettingsStatePitchModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStatePitchModeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback = callback;
    decoder->ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback = callback;
    decoder->ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateHullProtectionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsStateHullProtectionChangedCallback = callback;
    decoder->ARDrone3SpeedSettingsStateHullProtectionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateHullProtectionChangedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateOutdoorChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsStateOutdoorChangedCallback = callback;
    decoder->ARDrone3SpeedSettingsStateOutdoorChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateOutdoorChangedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback = callback;
    decoder->ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback (ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSelectionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkSettingsStateWifiSelectionChangedCallback = callback;
    decoder->ARDrone3NetworkSettingsStateWifiSelectionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSelectionChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkSettingsStateWifiSecurityChangedCallback = callback;
    decoder->ARDrone3NetworkSettingsStateWifiSecurityChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityChangedCallback (ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3NetworkSettingsStateWifiSecurityCallback = callback;
    decoder->ARDrone3NetworkSettingsStateWifiSecurityCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCallback_t ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityCallback (ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCb = callback;
        ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductMotorVersionListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateProductMotorVersionListChangedCallback = callback;
    decoder->ARDrone3SettingsStateProductMotorVersionListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductMotorVersionListChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductGPSVersionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateProductGPSVersionChangedCallback = callback;
    decoder->ARDrone3SettingsStateProductGPSVersionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductGPSVersionChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateMotorErrorStateChangedCallback = callback;
    decoder->ARDrone3SettingsStateMotorErrorStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorSoftwareVersionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateMotorSoftwareVersionChangedCallback = callback;
    decoder->ARDrone3SettingsStateMotorSoftwareVersionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorSoftwareVersionChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorFlightsStatusChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateMotorFlightsStatusChangedCallback = callback;
    decoder->ARDrone3SettingsStateMotorFlightsStatusChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorFlightsStatusChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorLastErrorChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateMotorErrorLastErrorChangedCallback = callback;
    decoder->ARDrone3SettingsStateMotorErrorLastErrorChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorLastErrorChangedCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateP7IDCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateP7IDCallback = callback;
    decoder->ARDrone3SettingsStateP7IDCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateP7IDCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateCPUIDCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3SettingsStateCPUIDCallback = callback;
    decoder->ARDrone3SettingsStateCPUIDCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCallback_t ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3SettingsStateCPUIDCallback (ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCb = callback;
        ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStatePictureFormatChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStatePictureFormatChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStatePictureFormatChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStatePictureFormatChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateExpositionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateExpositionChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateExpositionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateExpositionChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateSaturationChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateSaturationChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateSaturationChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateSaturationChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateTimelapseChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateTimelapseChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateTimelapseChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateTimelapseChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoAutorecordChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateVideoAutorecordChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateVideoAutorecordChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoAutorecordChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoStabilizationModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateVideoStabilizationModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoRecordingModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateVideoRecordingModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoRecordingModeChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoFramerateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateVideoFramerateChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateVideoFramerateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoFramerateChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoResolutionsChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PictureSettingsStateVideoResolutionsChangedCallback = callback;
    decoder->ARDrone3PictureSettingsStateVideoResolutionsChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCallback_t ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoResolutionsChangedCallback (ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoEnableChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaStreamingStateVideoEnableChangedCallback = callback;
    decoder->ARDrone3MediaStreamingStateVideoEnableChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoEnableChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoStreamModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3MediaStreamingStateVideoStreamModeChangedCallback = callback;
    decoder->ARDrone3MediaStreamingStateVideoStreamModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoStreamModeChangedCallback (ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsStateHomeChangedCallback = callback;
    decoder->ARDrone3GPSSettingsStateHomeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateResetHomeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsStateResetHomeChangedCallback = callback;
    decoder->ARDrone3GPSSettingsStateResetHomeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateResetHomeChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSFixStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsStateGPSFixStateChangedCallback = callback;
    decoder->ARDrone3GPSSettingsStateGPSFixStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSFixStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSUpdateStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback = callback;
    decoder->ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSUpdateStateChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeTypeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsStateHomeTypeChangedCallback = callback;
    decoder->ARDrone3GPSSettingsStateHomeTypeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeTypeChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateReturnHomeDelayChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback = callback;
    decoder->ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateReturnHomeDelayChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3CameraStateOrientationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3CameraStateOrientationCallback = callback;
    decoder->ARDrone3CameraStateOrientationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCallback_t ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3CameraStateOrientationCallback (ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3CameraStateDefaultCameraOrientationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3CameraStateDefaultCameraOrientationCallback = callback;
    decoder->ARDrone3CameraStateDefaultCameraOrientationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCallback_t ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3CameraStateDefaultCameraOrientationCallback (ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCb = callback;
        ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateElectricFrequencyChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3AntiflickeringStateElectricFrequencyChangedCallback = callback;
    decoder->ARDrone3AntiflickeringStateElectricFrequencyChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCallback_t ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateElectricFrequencyChangedCallback (ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3AntiflickeringStateModeChangedCallback = callback;
    decoder->ARDrone3AntiflickeringStateModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCallback_t ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateModeChangedCallback (ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSStateNumberOfSatelliteChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSStateNumberOfSatelliteChangedCallback = callback;
    decoder->ARDrone3GPSStateNumberOfSatelliteChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSStateNumberOfSatelliteChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeAvailabilityChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSStateHomeTypeAvailabilityChangedCallback = callback;
    decoder->ARDrone3GPSStateHomeTypeAvailabilityChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeAvailabilityChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeChosenChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3GPSStateHomeTypeChosenChangedCallback = callback;
    decoder->ARDrone3GPSStateHomeTypeChosenChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCallback_t ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeChosenChangedCallback (ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCb = callback;
        ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetARDrone3PROStateFeaturesCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ARDrone3PROStateFeaturesCallback = callback;
    decoder->ARDrone3PROStateFeaturesCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCallback_t ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCb = NULL;
static void *ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCustom = NULL;
void ARCOMMANDS_Decoder_SetARDrone3PROStateFeaturesCallback (ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCb = callback;
        ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature common

void ARCOMMANDS_Decoder_SetCommonNetworkDisconnectCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonNetworkDisconnectCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonNetworkDisconnectCallback = callback;
    decoder->CommonNetworkDisconnectCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonNetworkDisconnectCallback_t ARCOMMANDS_Decoder_CommonNetworkDisconnectCb = NULL;
static void *ARCOMMANDS_Decoder_CommonNetworkDisconnectCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonNetworkDisconnectCallback (ARCOMMANDS_Decoder_CommonNetworkDisconnectCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonNetworkDisconnectCb = callback;
        ARCOMMANDS_Decoder_CommonNetworkDisconnectCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsAllSettingsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsAllSettingsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsAllSettingsCallback = callback;
    decoder->CommonSettingsAllSettingsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsAllSettingsCallback_t ARCOMMANDS_Decoder_CommonSettingsAllSettingsCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsAllSettingsCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsAllSettingsCallback (ARCOMMANDS_Decoder_CommonSettingsAllSettingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsAllSettingsCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsAllSettingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsResetCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsResetCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsResetCallback = callback;
    decoder->CommonSettingsResetCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsResetCallback_t ARCOMMANDS_Decoder_CommonSettingsResetCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsResetCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsResetCallback (ARCOMMANDS_Decoder_CommonSettingsResetCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsResetCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsResetCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsProductNameCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsProductNameCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsProductNameCallback = callback;
    decoder->CommonSettingsProductNameCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsProductNameCallback_t ARCOMMANDS_Decoder_CommonSettingsProductNameCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsProductNameCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsProductNameCallback (ARCOMMANDS_Decoder_CommonSettingsProductNameCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsProductNameCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsProductNameCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsCountryCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsCountryCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsCountryCallback = callback;
    decoder->CommonSettingsCountryCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsCountryCallback_t ARCOMMANDS_Decoder_CommonSettingsCountryCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsCountryCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsCountryCallback (ARCOMMANDS_Decoder_CommonSettingsCountryCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsCountryCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsCountryCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsAutoCountryCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsAutoCountryCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsAutoCountryCallback = callback;
    decoder->CommonSettingsAutoCountryCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsAutoCountryCallback_t ARCOMMANDS_Decoder_CommonSettingsAutoCountryCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsAutoCountryCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsAutoCountryCallback (ARCOMMANDS_Decoder_CommonSettingsAutoCountryCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsAutoCountryCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsAutoCountryCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonAllStatesCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonAllStatesCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonAllStatesCallback = callback;
    decoder->CommonCommonAllStatesCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonAllStatesCallback_t ARCOMMANDS_Decoder_CommonCommonAllStatesCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonAllStatesCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonAllStatesCallback (ARCOMMANDS_Decoder_CommonCommonAllStatesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonAllStatesCb = callback;
        ARCOMMANDS_Decoder_CommonCommonAllStatesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonCurrentDateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonCurrentDateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonCurrentDateCallback = callback;
    decoder->CommonCommonCurrentDateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonCurrentDateCallback_t ARCOMMANDS_Decoder_CommonCommonCurrentDateCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonCurrentDateCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonCurrentDateCallback (ARCOMMANDS_Decoder_CommonCommonCurrentDateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonCurrentDateCb = callback;
        ARCOMMANDS_Decoder_CommonCommonCurrentDateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonCurrentTimeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonCurrentTimeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonCurrentTimeCallback = callback;
    decoder->CommonCommonCurrentTimeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonCurrentTimeCallback_t ARCOMMANDS_Decoder_CommonCommonCurrentTimeCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonCurrentTimeCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonCurrentTimeCallback (ARCOMMANDS_Decoder_CommonCommonCurrentTimeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonCurrentTimeCb = callback;
        ARCOMMANDS_Decoder_CommonCommonCurrentTimeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonRebootCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonRebootCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonRebootCallback = callback;
    decoder->CommonCommonRebootCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonRebootCallback_t ARCOMMANDS_Decoder_CommonCommonRebootCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonRebootCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonRebootCallback (ARCOMMANDS_Decoder_CommonCommonRebootCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonRebootCb = callback;
        ARCOMMANDS_Decoder_CommonCommonRebootCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonOverHeatSwitchOffCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonOverHeatSwitchOffCallback = callback;
    decoder->CommonOverHeatSwitchOffCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCallback_t ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCb = NULL;
static void *ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonOverHeatSwitchOffCallback (ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCb = callback;
        ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonOverHeatVentilateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonOverHeatVentilateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonOverHeatVentilateCallback = callback;
    decoder->CommonOverHeatVentilateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonOverHeatVentilateCallback_t ARCOMMANDS_Decoder_CommonOverHeatVentilateCb = NULL;
static void *ARCOMMANDS_Decoder_CommonOverHeatVentilateCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonOverHeatVentilateCallback (ARCOMMANDS_Decoder_CommonOverHeatVentilateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonOverHeatVentilateCb = callback;
        ARCOMMANDS_Decoder_CommonOverHeatVentilateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonControllerIsPilotingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonControllerIsPilotingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonControllerIsPilotingCallback = callback;
    decoder->CommonControllerIsPilotingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonControllerIsPilotingCallback_t ARCOMMANDS_Decoder_CommonControllerIsPilotingCb = NULL;
static void *ARCOMMANDS_Decoder_CommonControllerIsPilotingCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonControllerIsPilotingCallback (ARCOMMANDS_Decoder_CommonControllerIsPilotingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonControllerIsPilotingCb = callback;
        ARCOMMANDS_Decoder_CommonControllerIsPilotingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonWifiSettingsOutdoorSettingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonWifiSettingsOutdoorSettingCallback = callback;
    decoder->CommonWifiSettingsOutdoorSettingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCallback_t ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCb = NULL;
static void *ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonWifiSettingsOutdoorSettingCallback (ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCb = callback;
        ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonMavlinkStartCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonMavlinkStartCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonMavlinkStartCallback = callback;
    decoder->CommonMavlinkStartCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonMavlinkStartCallback_t ARCOMMANDS_Decoder_CommonMavlinkStartCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkStartCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkStartCallback (ARCOMMANDS_Decoder_CommonMavlinkStartCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkStartCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkStartCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonMavlinkPauseCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonMavlinkPauseCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonMavlinkPauseCallback = callback;
    decoder->CommonMavlinkPauseCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonMavlinkPauseCallback_t ARCOMMANDS_Decoder_CommonMavlinkPauseCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkPauseCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkPauseCallback (ARCOMMANDS_Decoder_CommonMavlinkPauseCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkPauseCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkPauseCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonMavlinkStopCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonMavlinkStopCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonMavlinkStopCallback = callback;
    decoder->CommonMavlinkStopCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonMavlinkStopCallback_t ARCOMMANDS_Decoder_CommonMavlinkStopCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkStopCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkStopCallback (ARCOMMANDS_Decoder_CommonMavlinkStopCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkStopCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkStopCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCalibrationMagnetoCalibrationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCalibrationMagnetoCalibrationCallback = callback;
    decoder->CommonCalibrationMagnetoCalibrationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCallback_t ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationMagnetoCalibrationCallback (ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCalibrationPitotCalibrationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCalibrationPitotCalibrationCallback = callback;
    decoder->CommonCalibrationPitotCalibrationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCallback_t ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationPitotCalibrationCallback (ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonGPSControllerPositionForRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonGPSControllerPositionForRunCallback = callback;
    decoder->CommonGPSControllerPositionForRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCallback_t ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCb = NULL;
static void *ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonGPSControllerPositionForRunCallback (ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCb = callback;
        ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAudioControllerReadyForStreamingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAudioControllerReadyForStreamingCallback = callback;
    decoder->CommonAudioControllerReadyForStreamingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCallback_t ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAudioControllerReadyForStreamingCallback (ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCb = callback;
        ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonHeadlightsIntensityCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonHeadlightsIntensityCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonHeadlightsIntensityCallback = callback;
    decoder->CommonHeadlightsIntensityCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonHeadlightsIntensityCallback_t ARCOMMANDS_Decoder_CommonHeadlightsIntensityCb = NULL;
static void *ARCOMMANDS_Decoder_CommonHeadlightsIntensityCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonHeadlightsIntensityCallback (ARCOMMANDS_Decoder_CommonHeadlightsIntensityCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonHeadlightsIntensityCb = callback;
        ARCOMMANDS_Decoder_CommonHeadlightsIntensityCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAnimationsStartAnimationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAnimationsStartAnimationCallback = callback;
    decoder->CommonAnimationsStartAnimationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCallback_t ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAnimationsStartAnimationCallback (ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCb = callback;
        ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAnimationsStopAnimationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAnimationsStopAnimationCallback = callback;
    decoder->CommonAnimationsStopAnimationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCallback_t ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAnimationsStopAnimationCallback (ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCb = callback;
        ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAnimationsStopAllAnimationsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAnimationsStopAllAnimationsCallback = callback;
    decoder->CommonAnimationsStopAllAnimationsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCallback_t ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAnimationsStopAllAnimationsCallback (ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCb = callback;
        ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAccessoryConfigCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAccessoryConfigCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAccessoryConfigCallback = callback;
    decoder->CommonAccessoryConfigCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAccessoryConfigCallback_t ARCOMMANDS_Decoder_CommonAccessoryConfigCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAccessoryConfigCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAccessoryConfigCallback (ARCOMMANDS_Decoder_CommonAccessoryConfigCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAccessoryConfigCb = callback;
        ARCOMMANDS_Decoder_CommonAccessoryConfigCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonChargerSetMaxChargeRateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonChargerSetMaxChargeRateCallback = callback;
    decoder->CommonChargerSetMaxChargeRateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCallback_t ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCb = NULL;
static void *ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonChargerSetMaxChargeRateCallback (ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCb = callback;
        ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonNetworkEventDisconnectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonNetworkEventDisconnectionCallback = callback;
    decoder->CommonNetworkEventDisconnectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCallback_t ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCb = NULL;
static void *ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonNetworkEventDisconnectionCallback (ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCb = callback;
        ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateAllSettingsChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateAllSettingsChangedCallback = callback;
    decoder->CommonSettingsStateAllSettingsChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateAllSettingsChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateResetChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateResetChangedCallback = callback;
    decoder->CommonSettingsStateResetChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateResetChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductNameChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateProductNameChangedCallback = callback;
    decoder->CommonSettingsStateProductNameChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductNameChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductVersionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateProductVersionChangedCallback = callback;
    decoder->CommonSettingsStateProductVersionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductVersionChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialHighChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateProductSerialHighChangedCallback = callback;
    decoder->CommonSettingsStateProductSerialHighChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialHighChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialLowChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateProductSerialLowChangedCallback = callback;
    decoder->CommonSettingsStateProductSerialLowChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialLowChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateCountryChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateCountryChangedCallback = callback;
    decoder->CommonSettingsStateCountryChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateCountryChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonSettingsStateAutoCountryChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonSettingsStateAutoCountryChangedCallback = callback;
    decoder->CommonSettingsStateAutoCountryChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCallback_t ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonSettingsStateAutoCountryChangedCallback (ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCb = callback;
        ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateAllStatesChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateAllStatesChangedCallback = callback;
    decoder->CommonCommonStateAllStatesChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateAllStatesChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateBatteryStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateBatteryStateChangedCallback = callback;
    decoder->CommonCommonStateBatteryStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateBatteryStateChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageStateListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateMassStorageStateListChangedCallback = callback;
    decoder->CommonCommonStateMassStorageStateListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageStateListChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoStateListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateMassStorageInfoStateListChangedCallback = callback;
    decoder->CommonCommonStateMassStorageInfoStateListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoStateListChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateCurrentDateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateCurrentDateChangedCallback = callback;
    decoder->CommonCommonStateCurrentDateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateCurrentDateChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateCurrentTimeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateCurrentTimeChangedCallback = callback;
    decoder->CommonCommonStateCurrentTimeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateCurrentTimeChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoRemainingListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateMassStorageInfoRemainingListChangedCallback = callback;
    decoder->CommonCommonStateMassStorageInfoRemainingListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoRemainingListChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateWifiSignalChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateWifiSignalChangedCallback = callback;
    decoder->CommonCommonStateWifiSignalChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateWifiSignalChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateSensorsStatesListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateSensorsStatesListChangedCallback = callback;
    decoder->CommonCommonStateSensorsStatesListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateSensorsStatesListChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateProductModelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateProductModelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateProductModelCallback = callback;
    decoder->CommonCommonStateProductModelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateProductModelCallback_t ARCOMMANDS_Decoder_CommonCommonStateProductModelCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateProductModelCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateProductModelCallback (ARCOMMANDS_Decoder_CommonCommonStateProductModelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateProductModelCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateProductModelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateCountryListKnownCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateCountryListKnownCallback = callback;
    decoder->CommonCommonStateCountryListKnownCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCallback_t ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateCountryListKnownCallback (ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateDeprecatedMassStorageContentChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateDeprecatedMassStorageContentChangedCallback = callback;
    decoder->CommonCommonStateDeprecatedMassStorageContentChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCallback_t ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateDeprecatedMassStorageContentChangedCallback (ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageContentCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateMassStorageContentCallback = callback;
    decoder->CommonCommonStateMassStorageContentCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCallback_t ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageContentCallback (ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageContentForCurrentRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCommonStateMassStorageContentForCurrentRunCallback = callback;
    decoder->CommonCommonStateMassStorageContentForCurrentRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCallback_t ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageContentForCurrentRunCallback (ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCb = callback;
        ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonOverHeatStateOverHeatChangedCallback = callback;
    decoder->CommonOverHeatStateOverHeatChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCallback_t ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatChangedCallback (ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCb = callback;
        ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatRegulationChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonOverHeatStateOverHeatRegulationChangedCallback = callback;
    decoder->CommonOverHeatStateOverHeatRegulationChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCallback_t ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatRegulationChangedCallback (ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCb = callback;
        ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonWifiSettingsStateOutdoorSettingsChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonWifiSettingsStateOutdoorSettingsChangedCallback = callback;
    decoder->CommonWifiSettingsStateOutdoorSettingsChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCallback_t ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonWifiSettingsStateOutdoorSettingsChangedCallback (ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCb = callback;
        ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkFilePlayingStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonMavlinkStateMavlinkFilePlayingStateChangedCallback = callback;
    decoder->CommonMavlinkStateMavlinkFilePlayingStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCallback_t ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkFilePlayingStateChangedCallback (ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkPlayErrorStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonMavlinkStateMavlinkPlayErrorStateChangedCallback = callback;
    decoder->CommonMavlinkStateMavlinkPlayErrorStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCallback_t ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkPlayErrorStateChangedCallback (ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCalibrationStateMagnetoCalibrationStateChangedCallback = callback;
    decoder->CommonCalibrationStateMagnetoCalibrationStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCallback_t ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStateChangedCallback (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationRequiredStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCalibrationStateMagnetoCalibrationRequiredStateCallback = callback;
    decoder->CommonCalibrationStateMagnetoCalibrationRequiredStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCallback_t ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationRequiredStateCallback (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback = callback;
    decoder->CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback_t ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStartedChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCalibrationStateMagnetoCalibrationStartedChangedCallback = callback;
    decoder->CommonCalibrationStateMagnetoCalibrationStartedChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCallback_t ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStartedChangedCallback (ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCalibrationStatePitotCalibrationStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCalibrationStatePitotCalibrationStateChangedCallback = callback;
    decoder->CommonCalibrationStatePitotCalibrationStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCallback_t ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCalibrationStatePitotCalibrationStateChangedCallback (ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonCameraSettingsStateCameraSettingsChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonCameraSettingsStateCameraSettingsChangedCallback = callback;
    decoder->CommonCameraSettingsStateCameraSettingsChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCallback_t ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonCameraSettingsStateCameraSettingsChangedCallback (ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCb = callback;
        ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonFlightPlanStateAvailabilityStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonFlightPlanStateAvailabilityStateChangedCallback = callback;
    decoder->CommonFlightPlanStateAvailabilityStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCallback_t ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonFlightPlanStateAvailabilityStateChangedCallback (ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonFlightPlanStateComponentStateListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonFlightPlanStateComponentStateListChangedCallback = callback;
    decoder->CommonFlightPlanStateComponentStateListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCallback_t ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonFlightPlanStateComponentStateListChangedCallback (ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonFlightPlanStateLockStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonFlightPlanStateLockStateChangedCallback = callback;
    decoder->CommonFlightPlanStateLockStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCallback_t ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonFlightPlanStateLockStateChangedCallback (ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonFlightPlanEventStartingErrorEventCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonFlightPlanEventStartingErrorEventCallback = callback;
    decoder->CommonFlightPlanEventStartingErrorEventCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCallback_t ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCb = NULL;
static void *ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonFlightPlanEventStartingErrorEventCallback (ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCb = callback;
        ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonFlightPlanEventSpeedBridleEventCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonFlightPlanEventSpeedBridleEventCallback = callback;
    decoder->CommonFlightPlanEventSpeedBridleEventCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCallback_t ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCb = NULL;
static void *ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonFlightPlanEventSpeedBridleEventCallback (ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCb = callback;
        ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateControllerLibARCommandsVersionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonARLibsVersionsStateControllerLibARCommandsVersionCallback = callback;
    decoder->CommonARLibsVersionsStateControllerLibARCommandsVersionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCallback_t ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCb = NULL;
static void *ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateControllerLibARCommandsVersionCallback (ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCb = callback;
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback = callback;
    decoder->CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback_t ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb = NULL;
static void *ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback (ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb = callback;
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateDeviceLibARCommandsVersionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback = callback;
    decoder->CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback_t ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCb = NULL;
static void *ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateDeviceLibARCommandsVersionCallback (ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCb = callback;
        ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAudioStateAudioStreamingRunningCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAudioStateAudioStreamingRunningCallback = callback;
    decoder->CommonAudioStateAudioStreamingRunningCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCallback_t ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAudioStateAudioStreamingRunningCallback (ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCb = callback;
        ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonHeadlightsStateIntensityChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonHeadlightsStateIntensityChangedCallback = callback;
    decoder->CommonHeadlightsStateIntensityChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCallback_t ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonHeadlightsStateIntensityChangedCallback (ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCb = callback;
        ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAnimationsStateListCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAnimationsStateListCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAnimationsStateListCallback = callback;
    decoder->CommonAnimationsStateListCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAnimationsStateListCallback_t ARCOMMANDS_Decoder_CommonAnimationsStateListCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAnimationsStateListCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAnimationsStateListCallback (ARCOMMANDS_Decoder_CommonAnimationsStateListCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAnimationsStateListCb = callback;
        ARCOMMANDS_Decoder_CommonAnimationsStateListCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAccessoryStateSupportedAccessoriesListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAccessoryStateSupportedAccessoriesListChangedCallback = callback;
    decoder->CommonAccessoryStateSupportedAccessoriesListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCallback_t ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAccessoryStateSupportedAccessoriesListChangedCallback (ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCb = callback;
        ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAccessoryStateAccessoryConfigChangedCallback = callback;
    decoder->CommonAccessoryStateAccessoryConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCallback_t ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigChangedCallback (ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCb = callback;
        ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigModificationEnabledCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonAccessoryStateAccessoryConfigModificationEnabledCallback = callback;
    decoder->CommonAccessoryStateAccessoryConfigModificationEnabledCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCallback_t ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCb = NULL;
static void *ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigModificationEnabledCallback (ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCb = callback;
        ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonChargerStateMaxChargeRateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonChargerStateMaxChargeRateChangedCallback = callback;
    decoder->CommonChargerStateMaxChargeRateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCallback_t ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonChargerStateMaxChargeRateChangedCallback (ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonChargerStateCurrentChargeStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonChargerStateCurrentChargeStateChangedCallback = callback;
    decoder->CommonChargerStateCurrentChargeStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCallback_t ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonChargerStateCurrentChargeStateChangedCallback (ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonChargerStateLastChargeRateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonChargerStateLastChargeRateChangedCallback = callback;
    decoder->CommonChargerStateLastChargeRateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCallback_t ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonChargerStateLastChargeRateChangedCallback (ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCb = callback;
        ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonChargerStateChargingInfoCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonChargerStateChargingInfoCallback = callback;
    decoder->CommonChargerStateChargingInfoCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCallback_t ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCb = NULL;
static void *ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonChargerStateChargingInfoCallback (ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCb = callback;
        ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetCommonRunStateRunIdChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->CommonRunStateRunIdChangedCallback = callback;
    decoder->CommonRunStateRunIdChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCallback_t ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCb = NULL;
static void *ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetCommonRunStateRunIdChangedCallback (ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCb = callback;
        ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature controller_info

void ARCOMMANDS_Decoder_SetControllerInfoGpsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ControllerInfoGpsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ControllerInfoGpsCallback = callback;
    decoder->ControllerInfoGpsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ControllerInfoGpsCallback_t ARCOMMANDS_Decoder_ControllerInfoGpsCb = NULL;
static void *ARCOMMANDS_Decoder_ControllerInfoGpsCustom = NULL;
void ARCOMMANDS_Decoder_SetControllerInfoGpsCallback (ARCOMMANDS_Decoder_ControllerInfoGpsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ControllerInfoGpsCb = callback;
        ARCOMMANDS_Decoder_ControllerInfoGpsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetControllerInfoBarometerCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ControllerInfoBarometerCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ControllerInfoBarometerCallback = callback;
    decoder->ControllerInfoBarometerCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ControllerInfoBarometerCallback_t ARCOMMANDS_Decoder_ControllerInfoBarometerCb = NULL;
static void *ARCOMMANDS_Decoder_ControllerInfoBarometerCustom = NULL;
void ARCOMMANDS_Decoder_SetControllerInfoBarometerCallback (ARCOMMANDS_Decoder_ControllerInfoBarometerCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ControllerInfoBarometerCb = callback;
        ARCOMMANDS_Decoder_ControllerInfoBarometerCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature debug

void ARCOMMANDS_Decoder_SetDebugGetAllSettingsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DebugGetAllSettingsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DebugGetAllSettingsCallback = callback;
    decoder->DebugGetAllSettingsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DebugGetAllSettingsCallback_t ARCOMMANDS_Decoder_DebugGetAllSettingsCb = NULL;
static void *ARCOMMANDS_Decoder_DebugGetAllSettingsCustom = NULL;
void ARCOMMANDS_Decoder_SetDebugGetAllSettingsCallback (ARCOMMANDS_Decoder_DebugGetAllSettingsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DebugGetAllSettingsCb = callback;
        ARCOMMANDS_Decoder_DebugGetAllSettingsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDebugSetSettingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DebugSetSettingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DebugSetSettingCallback = callback;
    decoder->DebugSetSettingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DebugSetSettingCallback_t ARCOMMANDS_Decoder_DebugSetSettingCb = NULL;
static void *ARCOMMANDS_Decoder_DebugSetSettingCustom = NULL;
void ARCOMMANDS_Decoder_SetDebugSetSettingCallback (ARCOMMANDS_Decoder_DebugSetSettingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DebugSetSettingCb = callback;
        ARCOMMANDS_Decoder_DebugSetSettingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDebugSettingsInfoCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DebugSettingsInfoCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DebugSettingsInfoCallback = callback;
    decoder->DebugSettingsInfoCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DebugSettingsInfoCallback_t ARCOMMANDS_Decoder_DebugSettingsInfoCb = NULL;
static void *ARCOMMANDS_Decoder_DebugSettingsInfoCustom = NULL;
void ARCOMMANDS_Decoder_SetDebugSettingsInfoCallback (ARCOMMANDS_Decoder_DebugSettingsInfoCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DebugSettingsInfoCb = callback;
        ARCOMMANDS_Decoder_DebugSettingsInfoCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDebugSettingsListCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DebugSettingsListCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DebugSettingsListCallback = callback;
    decoder->DebugSettingsListCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DebugSettingsListCallback_t ARCOMMANDS_Decoder_DebugSettingsListCb = NULL;
static void *ARCOMMANDS_Decoder_DebugSettingsListCustom = NULL;
void ARCOMMANDS_Decoder_SetDebugSettingsListCallback (ARCOMMANDS_Decoder_DebugSettingsListCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DebugSettingsListCb = callback;
        ARCOMMANDS_Decoder_DebugSettingsListCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature drone_manager

void ARCOMMANDS_Decoder_SetDroneManagerDiscoverDronesCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DroneManagerDiscoverDronesCallback = callback;
    decoder->DroneManagerDiscoverDronesCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCallback_t ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCb = NULL;
static void *ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCustom = NULL;
void ARCOMMANDS_Decoder_SetDroneManagerDiscoverDronesCallback (ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCb = callback;
        ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDroneManagerConnectCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DroneManagerConnectCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DroneManagerConnectCallback = callback;
    decoder->DroneManagerConnectCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DroneManagerConnectCallback_t ARCOMMANDS_Decoder_DroneManagerConnectCb = NULL;
static void *ARCOMMANDS_Decoder_DroneManagerConnectCustom = NULL;
void ARCOMMANDS_Decoder_SetDroneManagerConnectCallback (ARCOMMANDS_Decoder_DroneManagerConnectCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DroneManagerConnectCb = callback;
        ARCOMMANDS_Decoder_DroneManagerConnectCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDroneManagerForgetCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DroneManagerForgetCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DroneManagerForgetCallback = callback;
    decoder->DroneManagerForgetCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DroneManagerForgetCallback_t ARCOMMANDS_Decoder_DroneManagerForgetCb = NULL;
static void *ARCOMMANDS_Decoder_DroneManagerForgetCustom = NULL;
void ARCOMMANDS_Decoder_SetDroneManagerForgetCallback (ARCOMMANDS_Decoder_DroneManagerForgetCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DroneManagerForgetCb = callback;
        ARCOMMANDS_Decoder_DroneManagerForgetCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDroneManagerDroneListItemCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DroneManagerDroneListItemCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DroneManagerDroneListItemCallback = callback;
    decoder->DroneManagerDroneListItemCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DroneManagerDroneListItemCallback_t ARCOMMANDS_Decoder_DroneManagerDroneListItemCb = NULL;
static void *ARCOMMANDS_Decoder_DroneManagerDroneListItemCustom = NULL;
void ARCOMMANDS_Decoder_SetDroneManagerDroneListItemCallback (ARCOMMANDS_Decoder_DroneManagerDroneListItemCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DroneManagerDroneListItemCb = callback;
        ARCOMMANDS_Decoder_DroneManagerDroneListItemCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDroneManagerConnectionStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DroneManagerConnectionStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DroneManagerConnectionStateCallback = callback;
    decoder->DroneManagerConnectionStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DroneManagerConnectionStateCallback_t ARCOMMANDS_Decoder_DroneManagerConnectionStateCb = NULL;
static void *ARCOMMANDS_Decoder_DroneManagerConnectionStateCustom = NULL;
void ARCOMMANDS_Decoder_SetDroneManagerConnectionStateCallback (ARCOMMANDS_Decoder_DroneManagerConnectionStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DroneManagerConnectionStateCb = callback;
        ARCOMMANDS_Decoder_DroneManagerConnectionStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDroneManagerAuthenticationFailedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DroneManagerAuthenticationFailedCallback = callback;
    decoder->DroneManagerAuthenticationFailedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCallback_t ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCb = NULL;
static void *ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCustom = NULL;
void ARCOMMANDS_Decoder_SetDroneManagerAuthenticationFailedCallback (ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCb = callback;
        ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetDroneManagerConnectionRefusedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->DroneManagerConnectionRefusedCallback = callback;
    decoder->DroneManagerConnectionRefusedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCallback_t ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCb = NULL;
static void *ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCustom = NULL;
void ARCOMMANDS_Decoder_SetDroneManagerConnectionRefusedCallback (ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCb = callback;
        ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature mapper

void ARCOMMANDS_Decoder_SetMapperGrabCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperGrabCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperGrabCallback = callback;
    decoder->MapperGrabCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperGrabCallback_t ARCOMMANDS_Decoder_MapperGrabCb = NULL;
static void *ARCOMMANDS_Decoder_MapperGrabCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperGrabCallback (ARCOMMANDS_Decoder_MapperGrabCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperGrabCb = callback;
        ARCOMMANDS_Decoder_MapperGrabCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperMapButtonActionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperMapButtonActionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperMapButtonActionCallback = callback;
    decoder->MapperMapButtonActionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperMapButtonActionCallback_t ARCOMMANDS_Decoder_MapperMapButtonActionCb = NULL;
static void *ARCOMMANDS_Decoder_MapperMapButtonActionCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperMapButtonActionCallback (ARCOMMANDS_Decoder_MapperMapButtonActionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperMapButtonActionCb = callback;
        ARCOMMANDS_Decoder_MapperMapButtonActionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperMapAxisActionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperMapAxisActionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperMapAxisActionCallback = callback;
    decoder->MapperMapAxisActionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperMapAxisActionCallback_t ARCOMMANDS_Decoder_MapperMapAxisActionCb = NULL;
static void *ARCOMMANDS_Decoder_MapperMapAxisActionCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperMapAxisActionCallback (ARCOMMANDS_Decoder_MapperMapAxisActionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperMapAxisActionCb = callback;
        ARCOMMANDS_Decoder_MapperMapAxisActionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperResetMappingCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperResetMappingCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperResetMappingCallback = callback;
    decoder->MapperResetMappingCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperResetMappingCallback_t ARCOMMANDS_Decoder_MapperResetMappingCb = NULL;
static void *ARCOMMANDS_Decoder_MapperResetMappingCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperResetMappingCallback (ARCOMMANDS_Decoder_MapperResetMappingCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperResetMappingCb = callback;
        ARCOMMANDS_Decoder_MapperResetMappingCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperSetExpoCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperSetExpoCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperSetExpoCallback = callback;
    decoder->MapperSetExpoCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperSetExpoCallback_t ARCOMMANDS_Decoder_MapperSetExpoCb = NULL;
static void *ARCOMMANDS_Decoder_MapperSetExpoCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperSetExpoCallback (ARCOMMANDS_Decoder_MapperSetExpoCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperSetExpoCb = callback;
        ARCOMMANDS_Decoder_MapperSetExpoCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperSetInvertedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperSetInvertedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperSetInvertedCallback = callback;
    decoder->MapperSetInvertedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperSetInvertedCallback_t ARCOMMANDS_Decoder_MapperSetInvertedCb = NULL;
static void *ARCOMMANDS_Decoder_MapperSetInvertedCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperSetInvertedCallback (ARCOMMANDS_Decoder_MapperSetInvertedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperSetInvertedCb = callback;
        ARCOMMANDS_Decoder_MapperSetInvertedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperGrabStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperGrabStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperGrabStateCallback = callback;
    decoder->MapperGrabStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperGrabStateCallback_t ARCOMMANDS_Decoder_MapperGrabStateCb = NULL;
static void *ARCOMMANDS_Decoder_MapperGrabStateCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperGrabStateCallback (ARCOMMANDS_Decoder_MapperGrabStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperGrabStateCb = callback;
        ARCOMMANDS_Decoder_MapperGrabStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperGrabButtonEventCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperGrabButtonEventCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperGrabButtonEventCallback = callback;
    decoder->MapperGrabButtonEventCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperGrabButtonEventCallback_t ARCOMMANDS_Decoder_MapperGrabButtonEventCb = NULL;
static void *ARCOMMANDS_Decoder_MapperGrabButtonEventCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperGrabButtonEventCallback (ARCOMMANDS_Decoder_MapperGrabButtonEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperGrabButtonEventCb = callback;
        ARCOMMANDS_Decoder_MapperGrabButtonEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperGrabAxisEventCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperGrabAxisEventCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperGrabAxisEventCallback = callback;
    decoder->MapperGrabAxisEventCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperGrabAxisEventCallback_t ARCOMMANDS_Decoder_MapperGrabAxisEventCb = NULL;
static void *ARCOMMANDS_Decoder_MapperGrabAxisEventCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperGrabAxisEventCallback (ARCOMMANDS_Decoder_MapperGrabAxisEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperGrabAxisEventCb = callback;
        ARCOMMANDS_Decoder_MapperGrabAxisEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperButtonMappingItemCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperButtonMappingItemCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperButtonMappingItemCallback = callback;
    decoder->MapperButtonMappingItemCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperButtonMappingItemCallback_t ARCOMMANDS_Decoder_MapperButtonMappingItemCb = NULL;
static void *ARCOMMANDS_Decoder_MapperButtonMappingItemCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperButtonMappingItemCallback (ARCOMMANDS_Decoder_MapperButtonMappingItemCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperButtonMappingItemCb = callback;
        ARCOMMANDS_Decoder_MapperButtonMappingItemCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperAxisMappingItemCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperAxisMappingItemCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperAxisMappingItemCallback = callback;
    decoder->MapperAxisMappingItemCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperAxisMappingItemCallback_t ARCOMMANDS_Decoder_MapperAxisMappingItemCb = NULL;
static void *ARCOMMANDS_Decoder_MapperAxisMappingItemCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperAxisMappingItemCallback (ARCOMMANDS_Decoder_MapperAxisMappingItemCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperAxisMappingItemCb = callback;
        ARCOMMANDS_Decoder_MapperAxisMappingItemCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperApplicationAxisEventCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperApplicationAxisEventCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperApplicationAxisEventCallback = callback;
    decoder->MapperApplicationAxisEventCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperApplicationAxisEventCallback_t ARCOMMANDS_Decoder_MapperApplicationAxisEventCb = NULL;
static void *ARCOMMANDS_Decoder_MapperApplicationAxisEventCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperApplicationAxisEventCallback (ARCOMMANDS_Decoder_MapperApplicationAxisEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperApplicationAxisEventCb = callback;
        ARCOMMANDS_Decoder_MapperApplicationAxisEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperApplicationButtonEventCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperApplicationButtonEventCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperApplicationButtonEventCallback = callback;
    decoder->MapperApplicationButtonEventCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperApplicationButtonEventCallback_t ARCOMMANDS_Decoder_MapperApplicationButtonEventCb = NULL;
static void *ARCOMMANDS_Decoder_MapperApplicationButtonEventCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperApplicationButtonEventCallback (ARCOMMANDS_Decoder_MapperApplicationButtonEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperApplicationButtonEventCb = callback;
        ARCOMMANDS_Decoder_MapperApplicationButtonEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperExpoMapItemCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperExpoMapItemCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperExpoMapItemCallback = callback;
    decoder->MapperExpoMapItemCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperExpoMapItemCallback_t ARCOMMANDS_Decoder_MapperExpoMapItemCb = NULL;
static void *ARCOMMANDS_Decoder_MapperExpoMapItemCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperExpoMapItemCallback (ARCOMMANDS_Decoder_MapperExpoMapItemCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperExpoMapItemCb = callback;
        ARCOMMANDS_Decoder_MapperExpoMapItemCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetMapperInvertedMapItemCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_MapperInvertedMapItemCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->MapperInvertedMapItemCallback = callback;
    decoder->MapperInvertedMapItemCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_MapperInvertedMapItemCallback_t ARCOMMANDS_Decoder_MapperInvertedMapItemCb = NULL;
static void *ARCOMMANDS_Decoder_MapperInvertedMapItemCustom = NULL;
void ARCOMMANDS_Decoder_SetMapperInvertedMapItemCallback (ARCOMMANDS_Decoder_MapperInvertedMapItemCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_MapperInvertedMapItemCb = callback;
        ARCOMMANDS_Decoder_MapperInvertedMapItemCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature powerup

void ARCOMMANDS_Decoder_SetPowerupPilotingPCMDCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingPCMDCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingPCMDCallback = callback;
    decoder->PowerupPilotingPCMDCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingPCMDCallback_t ARCOMMANDS_Decoder_PowerupPilotingPCMDCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingPCMDCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingPCMDCallback (ARCOMMANDS_Decoder_PowerupPilotingPCMDCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingPCMDCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingPCMDCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingUserTakeOffCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingUserTakeOffCallback = callback;
    decoder->PowerupPilotingUserTakeOffCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCallback_t ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingUserTakeOffCallback (ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingMotorModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingMotorModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingMotorModeCallback = callback;
    decoder->PowerupPilotingMotorModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingMotorModeCallback_t ARCOMMANDS_Decoder_PowerupPilotingMotorModeCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingMotorModeCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingMotorModeCallback (ARCOMMANDS_Decoder_PowerupPilotingMotorModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingMotorModeCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingMotorModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingSettingsSetCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingSettingsSetCallback = callback;
    decoder->PowerupPilotingSettingsSetCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCallback_t ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingSettingsSetCallback (ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaRecordPictureV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaRecordPictureV2Callback = callback;
    decoder->PowerupMediaRecordPictureV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Callback_t ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Cb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Custom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaRecordPictureV2Callback (ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Cb = callback;
        ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaRecordVideoV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaRecordVideoV2Callback = callback;
    decoder->PowerupMediaRecordVideoV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Callback_t ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Cb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Custom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaRecordVideoV2Callback (ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Cb = callback;
        ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkSettingsWifiSelectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkSettingsWifiSelectionCallback = callback;
    decoder->PowerupNetworkSettingsWifiSelectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCallback_t ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkSettingsWifiSelectionCallback (ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkWifiScanCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkWifiScanCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkWifiScanCallback = callback;
    decoder->PowerupNetworkWifiScanCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkWifiScanCallback_t ARCOMMANDS_Decoder_PowerupNetworkWifiScanCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkWifiScanCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkWifiScanCallback (ARCOMMANDS_Decoder_PowerupNetworkWifiScanCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkWifiScanCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkWifiScanCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkWifiAuthChannelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkWifiAuthChannelCallback = callback;
    decoder->PowerupNetworkWifiAuthChannelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCallback_t ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkWifiAuthChannelCallback (ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaStreamingVideoEnableCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaStreamingVideoEnableCallback = callback;
    decoder->PowerupMediaStreamingVideoEnableCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCallback_t ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaStreamingVideoEnableCallback (ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCb = callback;
        ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsAutorecordCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupVideoSettingsAutorecordCallback = callback;
    decoder->PowerupVideoSettingsAutorecordCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCallback_t ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsAutorecordCallback (ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCb = callback;
        ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsVideoModeCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupVideoSettingsVideoModeCallback = callback;
    decoder->PowerupVideoSettingsVideoModeCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCallback_t ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsVideoModeCallback (ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCb = callback;
        ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupSoundsBuzzCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupSoundsBuzzCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupSoundsBuzzCallback = callback;
    decoder->PowerupSoundsBuzzCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupSoundsBuzzCallback_t ARCOMMANDS_Decoder_PowerupSoundsBuzzCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupSoundsBuzzCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupSoundsBuzzCallback (ARCOMMANDS_Decoder_PowerupSoundsBuzzCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupSoundsBuzzCb = callback;
        ARCOMMANDS_Decoder_PowerupSoundsBuzzCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingStateAlertStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingStateAlertStateChangedCallback = callback;
    decoder->PowerupPilotingStateAlertStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCallback_t ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingStateAlertStateChangedCallback (ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingStateFlyingStateChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingStateFlyingStateChangedCallback = callback;
    decoder->PowerupPilotingStateFlyingStateChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCallback_t ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingStateFlyingStateChangedCallback (ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingStateMotorModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingStateMotorModeChangedCallback = callback;
    decoder->PowerupPilotingStateMotorModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCallback_t ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingStateMotorModeChangedCallback (ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingStateAttitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingStateAttitudeChangedCallback = callback;
    decoder->PowerupPilotingStateAttitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCallback_t ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingStateAttitudeChangedCallback (ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingStateAltitudeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingStateAltitudeChangedCallback = callback;
    decoder->PowerupPilotingStateAltitudeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCallback_t ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingStateAltitudeChangedCallback (ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupPilotingSettingsStateSettingChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupPilotingSettingsStateSettingChangedCallback = callback;
    decoder->PowerupPilotingSettingsStateSettingChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCallback_t ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupPilotingSettingsStateSettingChangedCallback (ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaRecordStatePictureStateChangedV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaRecordStatePictureStateChangedV2Callback = callback;
    decoder->PowerupMediaRecordStatePictureStateChangedV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Callback_t ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaRecordStatePictureStateChangedV2Callback (ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaRecordStateVideoStateChangedV2Cb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Callback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaRecordStateVideoStateChangedV2Callback = callback;
    decoder->PowerupMediaRecordStateVideoStateChangedV2Custom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Callback_t ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Cb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Custom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaRecordStateVideoStateChangedV2Callback (ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Callback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Cb = callback;
        ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Custom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaRecordEventPictureEventChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaRecordEventPictureEventChangedCallback = callback;
    decoder->PowerupMediaRecordEventPictureEventChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCallback_t ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaRecordEventPictureEventChangedCallback (ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaRecordEventVideoEventChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaRecordEventVideoEventChangedCallback = callback;
    decoder->PowerupMediaRecordEventVideoEventChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCallback_t ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaRecordEventVideoEventChangedCallback (ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkSettingsStateWifiSelectionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkSettingsStateWifiSelectionChangedCallback = callback;
    decoder->PowerupNetworkSettingsStateWifiSelectionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCallback_t ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkSettingsStateWifiSelectionChangedCallback (ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkStateWifiScanListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkStateWifiScanListChangedCallback = callback;
    decoder->PowerupNetworkStateWifiScanListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCallback_t ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkStateWifiScanListChangedCallback (ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkStateAllWifiScanChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkStateAllWifiScanChangedCallback = callback;
    decoder->PowerupNetworkStateAllWifiScanChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCallback_t ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkStateAllWifiScanChangedCallback (ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkStateWifiAuthChannelListChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkStateWifiAuthChannelListChangedCallback = callback;
    decoder->PowerupNetworkStateWifiAuthChannelListChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCallback_t ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkStateWifiAuthChannelListChangedCallback (ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkStateAllWifiAuthChannelChangedCallback = callback;
    decoder->PowerupNetworkStateAllWifiAuthChannelChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCallback_t ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkStateAllWifiAuthChannelChangedCallback (ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupNetworkStateLinkQualityChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupNetworkStateLinkQualityChangedCallback = callback;
    decoder->PowerupNetworkStateLinkQualityChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCallback_t ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupNetworkStateLinkQualityChangedCallback (ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupMediaStreamingStateVideoEnableChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupMediaStreamingStateVideoEnableChangedCallback = callback;
    decoder->PowerupMediaStreamingStateVideoEnableChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCallback_t ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupMediaStreamingStateVideoEnableChangedCallback (ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsStateAutorecordChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupVideoSettingsStateAutorecordChangedCallback = callback;
    decoder->PowerupVideoSettingsStateAutorecordChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCallback_t ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsStateAutorecordChangedCallback (ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsStateVideoModeChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupVideoSettingsStateVideoModeChangedCallback = callback;
    decoder->PowerupVideoSettingsStateVideoModeChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCallback_t ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupVideoSettingsStateVideoModeChangedCallback (ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetPowerupSoundsStateBuzzChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->PowerupSoundsStateBuzzChangedCallback = callback;
    decoder->PowerupSoundsStateBuzzChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCallback_t ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCb = NULL;
static void *ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetPowerupSoundsStateBuzzChangedCallback (ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCb = callback;
        ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature pro

void ARCOMMANDS_Decoder_SetProProBoughtFeaturesCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ProProBoughtFeaturesCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ProProBoughtFeaturesCallback = callback;
    decoder->ProProBoughtFeaturesCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ProProBoughtFeaturesCallback_t ARCOMMANDS_Decoder_ProProBoughtFeaturesCb = NULL;
static void *ARCOMMANDS_Decoder_ProProBoughtFeaturesCustom = NULL;
void ARCOMMANDS_Decoder_SetProProBoughtFeaturesCallback (ARCOMMANDS_Decoder_ProProBoughtFeaturesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ProProBoughtFeaturesCb = callback;
        ARCOMMANDS_Decoder_ProProBoughtFeaturesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetProProResponseCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ProProResponseCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ProProResponseCallback = callback;
    decoder->ProProResponseCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ProProResponseCallback_t ARCOMMANDS_Decoder_ProProResponseCb = NULL;
static void *ARCOMMANDS_Decoder_ProProResponseCustom = NULL;
void ARCOMMANDS_Decoder_SetProProResponseCallback (ARCOMMANDS_Decoder_ProProResponseCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ProProResponseCb = callback;
        ARCOMMANDS_Decoder_ProProResponseCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetProProActivateFeaturesCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ProProActivateFeaturesCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ProProActivateFeaturesCallback = callback;
    decoder->ProProActivateFeaturesCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ProProActivateFeaturesCallback_t ARCOMMANDS_Decoder_ProProActivateFeaturesCb = NULL;
static void *ARCOMMANDS_Decoder_ProProActivateFeaturesCustom = NULL;
void ARCOMMANDS_Decoder_SetProProActivateFeaturesCallback (ARCOMMANDS_Decoder_ProProActivateFeaturesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ProProActivateFeaturesCb = callback;
        ARCOMMANDS_Decoder_ProProActivateFeaturesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetProProStateSupportedFeaturesCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ProProStateSupportedFeaturesCallback = callback;
    decoder->ProProStateSupportedFeaturesCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCallback_t ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCb = NULL;
static void *ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCustom = NULL;
void ARCOMMANDS_Decoder_SetProProStateSupportedFeaturesCallback (ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCb = callback;
        ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetProProStateFeaturesActivatedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ProProStateFeaturesActivatedCallback = callback;
    decoder->ProProStateFeaturesActivatedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCallback_t ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCb = NULL;
static void *ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCustom = NULL;
void ARCOMMANDS_Decoder_SetProProStateFeaturesActivatedCallback (ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCb = callback;
        ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetProProEventChallengeEventCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_ProProEventChallengeEventCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->ProProEventChallengeEventCallback = callback;
    decoder->ProProEventChallengeEventCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_ProProEventChallengeEventCallback_t ARCOMMANDS_Decoder_ProProEventChallengeEventCb = NULL;
static void *ARCOMMANDS_Decoder_ProProEventChallengeEventCustom = NULL;
void ARCOMMANDS_Decoder_SetProProEventChallengeEventCallback (ARCOMMANDS_Decoder_ProProEventChallengeEventCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_ProProEventChallengeEventCb = callback;
        ARCOMMANDS_Decoder_ProProEventChallengeEventCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature rc

void ARCOMMANDS_Decoder_SetRcMonitorChannelsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcMonitorChannelsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcMonitorChannelsCallback = callback;
    decoder->RcMonitorChannelsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcMonitorChannelsCallback_t ARCOMMANDS_Decoder_RcMonitorChannelsCb = NULL;
static void *ARCOMMANDS_Decoder_RcMonitorChannelsCustom = NULL;
void ARCOMMANDS_Decoder_SetRcMonitorChannelsCallback (ARCOMMANDS_Decoder_RcMonitorChannelsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcMonitorChannelsCb = callback;
        ARCOMMANDS_Decoder_RcMonitorChannelsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcStartCalibrationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcStartCalibrationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcStartCalibrationCallback = callback;
    decoder->RcStartCalibrationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcStartCalibrationCallback_t ARCOMMANDS_Decoder_RcStartCalibrationCb = NULL;
static void *ARCOMMANDS_Decoder_RcStartCalibrationCustom = NULL;
void ARCOMMANDS_Decoder_SetRcStartCalibrationCallback (ARCOMMANDS_Decoder_RcStartCalibrationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcStartCalibrationCb = callback;
        ARCOMMANDS_Decoder_RcStartCalibrationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcInvertChannelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcInvertChannelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcInvertChannelCallback = callback;
    decoder->RcInvertChannelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcInvertChannelCallback_t ARCOMMANDS_Decoder_RcInvertChannelCb = NULL;
static void *ARCOMMANDS_Decoder_RcInvertChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetRcInvertChannelCallback (ARCOMMANDS_Decoder_RcInvertChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcInvertChannelCb = callback;
        ARCOMMANDS_Decoder_RcInvertChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcAbortCalibrationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcAbortCalibrationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcAbortCalibrationCallback = callback;
    decoder->RcAbortCalibrationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcAbortCalibrationCallback_t ARCOMMANDS_Decoder_RcAbortCalibrationCb = NULL;
static void *ARCOMMANDS_Decoder_RcAbortCalibrationCustom = NULL;
void ARCOMMANDS_Decoder_SetRcAbortCalibrationCallback (ARCOMMANDS_Decoder_RcAbortCalibrationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcAbortCalibrationCb = callback;
        ARCOMMANDS_Decoder_RcAbortCalibrationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcResetCalibrationCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcResetCalibrationCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcResetCalibrationCallback = callback;
    decoder->RcResetCalibrationCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcResetCalibrationCallback_t ARCOMMANDS_Decoder_RcResetCalibrationCb = NULL;
static void *ARCOMMANDS_Decoder_RcResetCalibrationCustom = NULL;
void ARCOMMANDS_Decoder_SetRcResetCalibrationCallback (ARCOMMANDS_Decoder_RcResetCalibrationCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcResetCalibrationCb = callback;
        ARCOMMANDS_Decoder_RcResetCalibrationCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcReceiverStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcReceiverStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcReceiverStateCallback = callback;
    decoder->RcReceiverStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcReceiverStateCallback_t ARCOMMANDS_Decoder_RcReceiverStateCb = NULL;
static void *ARCOMMANDS_Decoder_RcReceiverStateCustom = NULL;
void ARCOMMANDS_Decoder_SetRcReceiverStateCallback (ARCOMMANDS_Decoder_RcReceiverStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcReceiverStateCb = callback;
        ARCOMMANDS_Decoder_RcReceiverStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcChannelsMonitorStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcChannelsMonitorStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcChannelsMonitorStateCallback = callback;
    decoder->RcChannelsMonitorStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcChannelsMonitorStateCallback_t ARCOMMANDS_Decoder_RcChannelsMonitorStateCb = NULL;
static void *ARCOMMANDS_Decoder_RcChannelsMonitorStateCustom = NULL;
void ARCOMMANDS_Decoder_SetRcChannelsMonitorStateCallback (ARCOMMANDS_Decoder_RcChannelsMonitorStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcChannelsMonitorStateCb = callback;
        ARCOMMANDS_Decoder_RcChannelsMonitorStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcChannelValueCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcChannelValueCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcChannelValueCallback = callback;
    decoder->RcChannelValueCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcChannelValueCallback_t ARCOMMANDS_Decoder_RcChannelValueCb = NULL;
static void *ARCOMMANDS_Decoder_RcChannelValueCustom = NULL;
void ARCOMMANDS_Decoder_SetRcChannelValueCallback (ARCOMMANDS_Decoder_RcChannelValueCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcChannelValueCb = callback;
        ARCOMMANDS_Decoder_RcChannelValueCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcCalibrationStateCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcCalibrationStateCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcCalibrationStateCallback = callback;
    decoder->RcCalibrationStateCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcCalibrationStateCallback_t ARCOMMANDS_Decoder_RcCalibrationStateCb = NULL;
static void *ARCOMMANDS_Decoder_RcCalibrationStateCustom = NULL;
void ARCOMMANDS_Decoder_SetRcCalibrationStateCallback (ARCOMMANDS_Decoder_RcCalibrationStateCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcCalibrationStateCb = callback;
        ARCOMMANDS_Decoder_RcCalibrationStateCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetRcReceiverQualityCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_RcReceiverQualityCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->RcReceiverQualityCallback = callback;
    decoder->RcReceiverQualityCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_RcReceiverQualityCallback_t ARCOMMANDS_Decoder_RcReceiverQualityCb = NULL;
static void *ARCOMMANDS_Decoder_RcReceiverQualityCustom = NULL;
void ARCOMMANDS_Decoder_SetRcReceiverQualityCallback (ARCOMMANDS_Decoder_RcReceiverQualityCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_RcReceiverQualityCb = callback;
        ARCOMMANDS_Decoder_RcReceiverQualityCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature unknown_feature_1

void ARCOMMANDS_Decoder_SetUnknownFeature1GeographicRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1GeographicRunCallback = callback;
    decoder->UnknownFeature1GeographicRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1GeographicRunCallback (ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1RelativeRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1RelativeRunCallback = callback;
    decoder->UnknownFeature1RelativeRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1RelativeRunCallback (ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1LookAtRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1LookAtRunCallback = callback;
    decoder->UnknownFeature1LookAtRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1LookAtRunCallback (ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1SpiralAnimRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1SpiralAnimRunCallback = callback;
    decoder->UnknownFeature1SpiralAnimRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1SpiralAnimRunCallback (ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1SwingAnimRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1SwingAnimRunCallback = callback;
    decoder->UnknownFeature1SwingAnimRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1SwingAnimRunCallback (ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1BoomerangAnimRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1BoomerangAnimRunCallback = callback;
    decoder->UnknownFeature1BoomerangAnimRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1BoomerangAnimRunCallback (ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1CandleAnimRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1CandleAnimRunCallback = callback;
    decoder->UnknownFeature1CandleAnimRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1CandleAnimRunCallback (ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1DollySlideAnimRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1DollySlideAnimRunCallback = callback;
    decoder->UnknownFeature1DollySlideAnimRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1DollySlideAnimRunCallback (ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1UserFramingPositionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1UserFramingPositionCallback = callback;
    decoder->UnknownFeature1UserFramingPositionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCallback_t ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1UserFramingPositionCallback (ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1UserGPSDataCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1UserGPSDataCallback = callback;
    decoder->UnknownFeature1UserGPSDataCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCallback_t ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1UserGPSDataCallback (ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1UserBaroDataCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1UserBaroDataCallback = callback;
    decoder->UnknownFeature1UserBaroDataCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCallback_t ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1UserBaroDataCallback (ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1LynxDetectionCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1LynxDetectionCallback = callback;
    decoder->UnknownFeature1LynxDetectionCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCallback_t ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1LynxDetectionCallback (ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1AvailabilityCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1AvailabilityCallback = callback;
    decoder->UnknownFeature1AvailabilityCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCallback_t ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1AvailabilityCallback (ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1RunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1RunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1RunCallback = callback;
    decoder->UnknownFeature1RunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1RunCallback_t ARCOMMANDS_Decoder_UnknownFeature1RunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1RunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1RunCallback (ARCOMMANDS_Decoder_UnknownFeature1RunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1RunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1RunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1GeographicConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1GeographicConfigChangedCallback = callback;
    decoder->UnknownFeature1GeographicConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1GeographicConfigChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1RelativeConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1RelativeConfigChangedCallback = callback;
    decoder->UnknownFeature1RelativeConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1RelativeConfigChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1AnimRunCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1AnimRunCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1AnimRunCallback = callback;
    decoder->UnknownFeature1AnimRunCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1AnimRunCallback_t ARCOMMANDS_Decoder_UnknownFeature1AnimRunCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1AnimRunCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1AnimRunCallback (ARCOMMANDS_Decoder_UnknownFeature1AnimRunCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1AnimRunCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1AnimRunCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1SpiralAnimConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1SpiralAnimConfigChangedCallback = callback;
    decoder->UnknownFeature1SpiralAnimConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1SpiralAnimConfigChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1SwingAnimConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1SwingAnimConfigChangedCallback = callback;
    decoder->UnknownFeature1SwingAnimConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1SwingAnimConfigChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1BoomerangAnimConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1BoomerangAnimConfigChangedCallback = callback;
    decoder->UnknownFeature1BoomerangAnimConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1BoomerangAnimConfigChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1CandleAnimConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1CandleAnimConfigChangedCallback = callback;
    decoder->UnknownFeature1CandleAnimConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1CandleAnimConfigChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1DollySlideAnimConfigChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1DollySlideAnimConfigChangedCallback = callback;
    decoder->UnknownFeature1DollySlideAnimConfigChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1DollySlideAnimConfigChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetUnknownFeature1UserFramingPositionChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->UnknownFeature1UserFramingPositionChangedCallback = callback;
    decoder->UnknownFeature1UserFramingPositionChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCallback_t ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCb = NULL;
static void *ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetUnknownFeature1UserFramingPositionChangedCallback (ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCb = callback;
        ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// Feature wifi

void ARCOMMANDS_Decoder_SetWifiScanCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiScanCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiScanCallback = callback;
    decoder->WifiScanCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiScanCallback_t ARCOMMANDS_Decoder_WifiScanCb = NULL;
static void *ARCOMMANDS_Decoder_WifiScanCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiScanCallback (ARCOMMANDS_Decoder_WifiScanCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiScanCb = callback;
        ARCOMMANDS_Decoder_WifiScanCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiUpdateAuthorizedChannelsCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiUpdateAuthorizedChannelsCallback = callback;
    decoder->WifiUpdateAuthorizedChannelsCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCallback_t ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCb = NULL;
static void *ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiUpdateAuthorizedChannelsCallback (ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCb = callback;
        ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiSetApChannelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiSetApChannelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiSetApChannelCallback = callback;
    decoder->WifiSetApChannelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiSetApChannelCallback_t ARCOMMANDS_Decoder_WifiSetApChannelCb = NULL;
static void *ARCOMMANDS_Decoder_WifiSetApChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiSetApChannelCallback (ARCOMMANDS_Decoder_WifiSetApChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiSetApChannelCb = callback;
        ARCOMMANDS_Decoder_WifiSetApChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiSetSecurityCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiSetSecurityCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiSetSecurityCallback = callback;
    decoder->WifiSetSecurityCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiSetSecurityCallback_t ARCOMMANDS_Decoder_WifiSetSecurityCb = NULL;
static void *ARCOMMANDS_Decoder_WifiSetSecurityCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiSetSecurityCallback (ARCOMMANDS_Decoder_WifiSetSecurityCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiSetSecurityCb = callback;
        ARCOMMANDS_Decoder_WifiSetSecurityCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiSetCountryCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiSetCountryCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiSetCountryCallback = callback;
    decoder->WifiSetCountryCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiSetCountryCallback_t ARCOMMANDS_Decoder_WifiSetCountryCb = NULL;
static void *ARCOMMANDS_Decoder_WifiSetCountryCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiSetCountryCallback (ARCOMMANDS_Decoder_WifiSetCountryCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiSetCountryCb = callback;
        ARCOMMANDS_Decoder_WifiSetCountryCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiSetEnvironmentCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiSetEnvironmentCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiSetEnvironmentCallback = callback;
    decoder->WifiSetEnvironmentCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiSetEnvironmentCallback_t ARCOMMANDS_Decoder_WifiSetEnvironmentCb = NULL;
static void *ARCOMMANDS_Decoder_WifiSetEnvironmentCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiSetEnvironmentCallback (ARCOMMANDS_Decoder_WifiSetEnvironmentCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiSetEnvironmentCb = callback;
        ARCOMMANDS_Decoder_WifiSetEnvironmentCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiScannedItemCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiScannedItemCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiScannedItemCallback = callback;
    decoder->WifiScannedItemCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiScannedItemCallback_t ARCOMMANDS_Decoder_WifiScannedItemCb = NULL;
static void *ARCOMMANDS_Decoder_WifiScannedItemCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiScannedItemCallback (ARCOMMANDS_Decoder_WifiScannedItemCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiScannedItemCb = callback;
        ARCOMMANDS_Decoder_WifiScannedItemCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiAuthorizedChannelCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiAuthorizedChannelCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiAuthorizedChannelCallback = callback;
    decoder->WifiAuthorizedChannelCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiAuthorizedChannelCallback_t ARCOMMANDS_Decoder_WifiAuthorizedChannelCb = NULL;
static void *ARCOMMANDS_Decoder_WifiAuthorizedChannelCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiAuthorizedChannelCallback (ARCOMMANDS_Decoder_WifiAuthorizedChannelCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiAuthorizedChannelCb = callback;
        ARCOMMANDS_Decoder_WifiAuthorizedChannelCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiApChannelChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiApChannelChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiApChannelChangedCallback = callback;
    decoder->WifiApChannelChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiApChannelChangedCallback_t ARCOMMANDS_Decoder_WifiApChannelChangedCb = NULL;
static void *ARCOMMANDS_Decoder_WifiApChannelChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiApChannelChangedCallback (ARCOMMANDS_Decoder_WifiApChannelChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiApChannelChangedCb = callback;
        ARCOMMANDS_Decoder_WifiApChannelChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiSecurityChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiSecurityChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiSecurityChangedCallback = callback;
    decoder->WifiSecurityChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiSecurityChangedCallback_t ARCOMMANDS_Decoder_WifiSecurityChangedCb = NULL;
static void *ARCOMMANDS_Decoder_WifiSecurityChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiSecurityChangedCallback (ARCOMMANDS_Decoder_WifiSecurityChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiSecurityChangedCb = callback;
        ARCOMMANDS_Decoder_WifiSecurityChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiCountryChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiCountryChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiCountryChangedCallback = callback;
    decoder->WifiCountryChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiCountryChangedCallback_t ARCOMMANDS_Decoder_WifiCountryChangedCb = NULL;
static void *ARCOMMANDS_Decoder_WifiCountryChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiCountryChangedCallback (ARCOMMANDS_Decoder_WifiCountryChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiCountryChangedCb = callback;
        ARCOMMANDS_Decoder_WifiCountryChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiEnvironmentChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiEnvironmentChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiEnvironmentChangedCallback = callback;
    decoder->WifiEnvironmentChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiEnvironmentChangedCallback_t ARCOMMANDS_Decoder_WifiEnvironmentChangedCb = NULL;
static void *ARCOMMANDS_Decoder_WifiEnvironmentChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiEnvironmentChangedCallback (ARCOMMANDS_Decoder_WifiEnvironmentChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiEnvironmentChangedCb = callback;
        ARCOMMANDS_Decoder_WifiEnvironmentChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}
void ARCOMMANDS_Decoder_SetWifiRssiChangedCb (ARCOMMANDS_Decoder_t *decoder, ARCOMMANDS_Decoder_WifiRssiChangedCallback_t callback, void *custom)
{
    if (!decoder)
        return;

    ARSAL_Mutex_Lock (&decoder->mutex);
    decoder->WifiRssiChangedCallback = callback;
    decoder->WifiRssiChangedCustom = custom;
    ARSAL_Mutex_Unlock (&decoder->mutex);
}

static ARCOMMANDS_Decoder_WifiRssiChangedCallback_t ARCOMMANDS_Decoder_WifiRssiChangedCb = NULL;
static void *ARCOMMANDS_Decoder_WifiRssiChangedCustom = NULL;
void ARCOMMANDS_Decoder_SetWifiRssiChangedCallback (ARCOMMANDS_Decoder_WifiRssiChangedCallback_t callback, void *custom)
{
    if (ARCOMMANDS_Decoder_Init () == 1)
    {
        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
        ARCOMMANDS_Decoder_WifiRssiChangedCb = callback;
        ARCOMMANDS_Decoder_WifiRssiChangedCustom = custom;
        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
    } // No else --> do nothing if library can not be initialized
}

// DECODER ENTRY POINT
eARCOMMANDS_DECODER_ERROR
ARCOMMANDS_Decoder_DecodeBuffer (uint8_t *buffer, int32_t buffLen)
{
    return ARCOMMANDS_Decoder_DecodeCommand (NULL, buffer, buffLen);
}

eARCOMMANDS_DECODER_ERROR
ARCOMMANDS_Decoder_DecodeCommand (ARCOMMANDS_Decoder_t *decoder, uint8_t *buffer, int32_t buffLen)
{
    eARCOMMANDS_ID_FEATURE commandFetaure = -1;
    int commandClass = -1;
    int commandId = -1;
    int32_t error = 0;
    int32_t offset = 0;
    eARCOMMANDS_DECODER_ERROR retVal = ARCOMMANDS_DECODER_OK;
    if (NULL == buffer)
    {
        retVal = ARCOMMANDS_DECODER_ERROR;
    } // No else --> Arg check

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        if (ARCOMMANDS_Decoder_Init () == 0)
        {
            retVal = ARCOMMANDS_DECODER_ERROR;
        } // No else --> keep retVal to OK if init went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandFetaure = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandClass = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandId = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        switch (commandFetaure)
        {
        case ARCOMMANDS_ID_FEATURE_GENERIC:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_GENERIC_CMD_DEFAULT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->GenericDefaultCallback) || (!decoder && ARCOMMANDS_Decoder_GenericDefaultCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->GenericDefaultCallback) {
                                decoder->GenericDefaultCallback (decoder->GenericDefaultCustom);
                            } else {
                                ARCOMMANDS_Decoder_GenericDefaultCb (ARCOMMANDS_Decoder_GenericDefaultCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_GENERIC_FACTORY_CMD_DEFAULT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_GENERIC */
        case ARCOMMANDS_ID_FEATURE_ARDRONE3:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_FLATTRIM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingFlatTrimCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingFlatTrimCallback) {
                                decoder->ARDrone3PilotingFlatTrimCallback (decoder->ARDrone3PilotingFlatTrimCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCb (ARCOMMANDS_Decoder_ARDrone3PilotingFlatTrimCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_FLATTRIM */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_TAKEOFF:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingTakeOffCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingTakeOffCallback) {
                                decoder->ARDrone3PilotingTakeOffCallback (decoder->ARDrone3PilotingTakeOffCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCb (ARCOMMANDS_Decoder_ARDrone3PilotingTakeOffCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_TAKEOFF */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_PCMD:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingPCMDCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCb))
                    {
                        uint8_t _flag;
                        int8_t _roll;
                        int8_t _pitch;
                        int8_t _yaw;
                        int8_t _gaz;
                        uint32_t _timestampAndSeqNum;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _flag = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _roll =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pitch =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _yaw =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _gaz =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _timestampAndSeqNum = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingPCMDCallback) {
                                decoder->ARDrone3PilotingPCMDCallback (_flag, _roll, _pitch, _yaw, _gaz, _timestampAndSeqNum, decoder->ARDrone3PilotingPCMDCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCb (_flag, _roll, _pitch, _yaw, _gaz, _timestampAndSeqNum, ARCOMMANDS_Decoder_ARDrone3PilotingPCMDCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_LANDING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingLandingCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingLandingCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingLandingCallback) {
                                decoder->ARDrone3PilotingLandingCallback (decoder->ARDrone3PilotingLandingCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingLandingCb (ARCOMMANDS_Decoder_ARDrone3PilotingLandingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_LANDING */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_EMERGENCY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingEmergencyCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingEmergencyCallback) {
                                decoder->ARDrone3PilotingEmergencyCallback (decoder->ARDrone3PilotingEmergencyCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCb (ARCOMMANDS_Decoder_ARDrone3PilotingEmergencyCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_EMERGENCY */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_NAVIGATEHOME:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingNavigateHomeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCb))
                    {
                        uint8_t _start;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingNavigateHomeCallback) {
                                decoder->ARDrone3PilotingNavigateHomeCallback (_start, decoder->ARDrone3PilotingNavigateHomeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCb (_start, ARCOMMANDS_Decoder_ARDrone3PilotingNavigateHomeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_NAVIGATEHOME */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_AUTOTAKEOFFMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingAutoTakeOffModeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCb))
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingAutoTakeOffModeCallback) {
                                decoder->ARDrone3PilotingAutoTakeOffModeCallback (_state, decoder->ARDrone3PilotingAutoTakeOffModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingAutoTakeOffModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_AUTOTAKEOFFMODE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_MOVEBY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingMoveByCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCb))
                    {
                        float _dX;
                        float _dY;
                        float _dZ;
                        float _dPsi;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dX = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dY = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dZ = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dPsi = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingMoveByCallback) {
                                decoder->ARDrone3PilotingMoveByCallback (_dX, _dY, _dZ, _dPsi, decoder->ARDrone3PilotingMoveByCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCb (_dX, _dY, _dZ, _dPsi, ARCOMMANDS_Decoder_ARDrone3PilotingMoveByCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_MOVEBY */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_USERTAKEOFF:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingUserTakeOffCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCb))
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingUserTakeOffCallback) {
                                decoder->ARDrone3PilotingUserTakeOffCallback (_state, decoder->ARDrone3PilotingUserTakeOffCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingUserTakeOffCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_USERTAKEOFF */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_CIRCLE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingCircleCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingCircleCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTING_CIRCLE_DIRECTION _direction;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _direction = (eARCOMMANDS_ARDRONE3_PILOTING_CIRCLE_DIRECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingCircleCallback) {
                                decoder->ARDrone3PilotingCircleCallback (_direction, decoder->ARDrone3PilotingCircleCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingCircleCb (_direction, ARCOMMANDS_Decoder_ARDrone3PilotingCircleCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_CIRCLE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANIMATIONS_CMD_FLIP:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3AnimationsFlipCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCb))
                    {
                        eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION _direction;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _direction = (eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3AnimationsFlipCallback) {
                                decoder->ARDrone3AnimationsFlipCallback (_direction, decoder->ARDrone3AnimationsFlipCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCb (_direction, ARCOMMANDS_Decoder_ARDrone3AnimationsFlipCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANIMATIONS_CMD_FLIP */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERA:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_CAMERA_CMD_ORIENTATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3CameraOrientationCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3CameraOrientationCb))
                    {
                        int8_t _tilt;
                        int8_t _pan;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _tilt =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pan =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3CameraOrientationCallback) {
                                decoder->ARDrone3CameraOrientationCallback (_tilt, _pan, decoder->ARDrone3CameraOrientationCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3CameraOrientationCb (_tilt, _pan, ARCOMMANDS_Decoder_ARDrone3CameraOrientationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERA_CMD_ORIENTATION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERA */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTURE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordPictureCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCb))
                    {
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordPictureCallback) {
                                decoder->ARDrone3MediaRecordPictureCallback (_mass_storage_id, decoder->ARDrone3MediaRecordPictureCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCb (_mass_storage_id, ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTURE */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEO:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordVideoCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD _record;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _record = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordVideoCallback) {
                                decoder->ARDrone3MediaRecordVideoCallback (_record, _mass_storage_id, decoder->ARDrone3MediaRecordVideoCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCb (_record, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEO */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTUREV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordPictureV2Callback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Cb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordPictureV2Callback) {
                                decoder->ARDrone3MediaRecordPictureV2Callback (decoder->ARDrone3MediaRecordPictureV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Cb (ARCOMMANDS_Decoder_ARDrone3MediaRecordPictureV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTUREV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEOV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordVideoV2Callback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Cb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD _record;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _record = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordVideoV2Callback) {
                                decoder->ARDrone3MediaRecordVideoV2Callback (_record, decoder->ARDrone3MediaRecordVideoV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Cb (_record, ARCOMMANDS_Decoder_ARDrone3MediaRecordVideoV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEOV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordStatePictureStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCb))
                    {
                        uint8_t _state;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordStatePictureStateChangedCallback) {
                                decoder->ARDrone3MediaRecordStatePictureStateChangedCallback (_state, _mass_storage_id, decoder->ARDrone3MediaRecordStatePictureStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCb (_state, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordStateVideoStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordStateVideoStateChangedCallback) {
                                decoder->ARDrone3MediaRecordStateVideoStateChangedCallback (_state, _mass_storage_id, decoder->ARDrone3MediaRecordStateVideoStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCb (_state, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordStatePictureStateChangedV2Callback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Cb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordStatePictureStateChangedV2Callback) {
                                decoder->ARDrone3MediaRecordStatePictureStateChangedV2Callback (_state, _error, decoder->ARDrone3MediaRecordStatePictureStateChangedV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_ARDrone3MediaRecordStatePictureStateChangedV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordStateVideoStateChangedV2Callback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Cb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordStateVideoStateChangedV2Callback) {
                                decoder->ARDrone3MediaRecordStateVideoStateChangedV2Callback (_state, _error, decoder->ARDrone3MediaRecordStateVideoStateChangedV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoStateChangedV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEORESOLUTIONSTATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordStateVideoResolutionStateCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING _streaming;
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING _recording;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _streaming = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _recording = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordStateVideoResolutionStateCallback) {
                                decoder->ARDrone3MediaRecordStateVideoResolutionStateCallback (_streaming, _recording, decoder->ARDrone3MediaRecordStateVideoResolutionStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCb (_streaming, _recording, ARCOMMANDS_Decoder_ARDrone3MediaRecordStateVideoResolutionStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEORESOLUTIONSTATE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordEventPictureEventChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordEventPictureEventChangedCallback) {
                                decoder->ARDrone3MediaRecordEventPictureEventChangedCallback (_event, _error, decoder->ARDrone3MediaRecordEventPictureEventChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCb (_event, _error, ARCOMMANDS_Decoder_ARDrone3MediaRecordEventPictureEventChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaRecordEventVideoEventChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaRecordEventVideoEventChangedCallback) {
                                decoder->ARDrone3MediaRecordEventVideoEventChangedCallback (_event, _error, decoder->ARDrone3MediaRecordEventVideoEventChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCb (_event, _error, ARCOMMANDS_Decoder_ARDrone3MediaRecordEventVideoEventChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLATTRIMCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateFlatTrimChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateFlatTrimChangedCallback) {
                                decoder->ARDrone3PilotingStateFlatTrimChangedCallback (decoder->ARDrone3PilotingStateFlatTrimChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCb (ARCOMMANDS_Decoder_ARDrone3PilotingStateFlatTrimChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLATTRIMCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLYINGSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateFlyingStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateFlyingStateChangedCallback) {
                                decoder->ARDrone3PilotingStateFlyingStateChangedCallback (_state, decoder->ARDrone3PilotingStateFlyingStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingStateFlyingStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLYINGSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateAlertStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateAlertStateChangedCallback) {
                                decoder->ARDrone3PilotingStateAlertStateChangedCallback (_state, decoder->ARDrone3PilotingStateAlertStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingStateAlertStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_NAVIGATEHOMESTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateNavigateHomeStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE _state;
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON _reason;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _reason = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateNavigateHomeStateChangedCallback) {
                                decoder->ARDrone3PilotingStateNavigateHomeStateChangedCallback (_state, _reason, decoder->ARDrone3PilotingStateNavigateHomeStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCb (_state, _reason, ARCOMMANDS_Decoder_ARDrone3PilotingStateNavigateHomeStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_NAVIGATEHOMESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_POSITIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStatePositionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCb))
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStatePositionChangedCallback) {
                                decoder->ARDrone3PilotingStatePositionChangedCallback (_latitude, _longitude, _altitude, decoder->ARDrone3PilotingStatePositionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCb (_latitude, _longitude, _altitude, ARCOMMANDS_Decoder_ARDrone3PilotingStatePositionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_POSITIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_SPEEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateSpeedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCb))
                    {
                        float _speedX;
                        float _speedY;
                        float _speedZ;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speedX = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speedY = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speedZ = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateSpeedChangedCallback) {
                                decoder->ARDrone3PilotingStateSpeedChangedCallback (_speedX, _speedY, _speedZ, decoder->ARDrone3PilotingStateSpeedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCb (_speedX, _speedY, _speedZ, ARCOMMANDS_Decoder_ARDrone3PilotingStateSpeedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_SPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ATTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateAttitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCb))
                    {
                        float _roll;
                        float _pitch;
                        float _yaw;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _roll = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pitch = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _yaw = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateAttitudeChangedCallback) {
                                decoder->ARDrone3PilotingStateAttitudeChangedCallback (_roll, _pitch, _yaw, decoder->ARDrone3PilotingStateAttitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCb (_roll, _pitch, _yaw, ARCOMMANDS_Decoder_ARDrone3PilotingStateAttitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ATTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateAutoTakeOffModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCb))
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateAutoTakeOffModeChangedCallback) {
                                decoder->ARDrone3PilotingStateAutoTakeOffModeChangedCallback (_state, decoder->ARDrone3PilotingStateAutoTakeOffModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingStateAutoTakeOffModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateAltitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCb))
                    {
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateAltitudeChangedCallback) {
                                decoder->ARDrone3PilotingStateAltitudeChangedCallback (_altitude, decoder->ARDrone3PilotingStateAltitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCb (_altitude, ARCOMMANDS_Decoder_ARDrone3PilotingStateAltitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_GPSLOCATIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateGpsLocationChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCb))
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        int8_t _latitude_accuracy;
                        int8_t _longitude_accuracy;
                        int8_t _altitude_accuracy;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude_accuracy =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude_accuracy =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude_accuracy =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateGpsLocationChangedCallback) {
                                decoder->ARDrone3PilotingStateGpsLocationChangedCallback (_latitude, _longitude, _altitude, _latitude_accuracy, _longitude_accuracy, _altitude_accuracy, decoder->ARDrone3PilotingStateGpsLocationChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCb (_latitude, _longitude, _altitude, _latitude_accuracy, _longitude_accuracy, _altitude_accuracy, ARCOMMANDS_Decoder_ARDrone3PilotingStateGpsLocationChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_GPSLOCATIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_LANDINGSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingStateLandingStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingStateLandingStateChangedCallback) {
                                decoder->ARDrone3PilotingStateLandingStateChangedCallback (_state, decoder->ARDrone3PilotingStateLandingStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingStateLandingStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_LANDINGSTATECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGEVENT_CMD_MOVEBYEND:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingEventMoveByEndCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCb))
                    {
                        float _dX;
                        float _dY;
                        float _dZ;
                        float _dPsi;
                        eARCOMMANDS_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dX = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dY = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dZ = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _dPsi = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingEventMoveByEndCallback) {
                                decoder->ARDrone3PilotingEventMoveByEndCallback (_dX, _dY, _dZ, _dPsi, _error, decoder->ARDrone3PilotingEventMoveByEndCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCb (_dX, _dY, _dZ, _dPsi, _error, ARCOMMANDS_Decoder_ARDrone3PilotingEventMoveByEndCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGEVENT_CMD_MOVEBYEND */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGEVENT */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFISCAN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkWifiScanCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCb))
                    {
                        eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND _band;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkWifiScanCallback) {
                                decoder->ARDrone3NetworkWifiScanCallback (_band, decoder->ARDrone3NetworkWifiScanCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCb (_band, ARCOMMANDS_Decoder_ARDrone3NetworkWifiScanCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFISCAN */
                case ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFIAUTHCHANNEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkWifiAuthChannelCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkWifiAuthChannelCallback) {
                                decoder->ARDrone3NetworkWifiAuthChannelCallback (decoder->ARDrone3NetworkWifiAuthChannelCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCb (ARCOMMANDS_Decoder_ARDrone3NetworkWifiAuthChannelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFIAUTHCHANNEL */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORK */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFISCANLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkStateWifiScanListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCb))
                    {
                        char * _ssid = NULL;
                        int16_t _rssi;
                        eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkStateWifiScanListChangedCallback) {
                                decoder->ARDrone3NetworkStateWifiScanListChangedCallback (_ssid, _rssi, _band, _channel, decoder->ARDrone3NetworkStateWifiScanListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCb (_ssid, _rssi, _band, _channel, ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiScanListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFISCANLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFISCANCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkStateAllWifiScanChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkStateAllWifiScanChangedCallback) {
                                decoder->ARDrone3NetworkStateAllWifiScanChangedCallback (decoder->ARDrone3NetworkStateAllWifiScanChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCb (ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiScanChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFISCANCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkStateWifiAuthChannelListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        uint8_t _in_or_out;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _in_or_out = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkStateWifiAuthChannelListChangedCallback) {
                                decoder->ARDrone3NetworkStateWifiAuthChannelListChangedCallback (_band, _channel, _in_or_out, decoder->ARDrone3NetworkStateWifiAuthChannelListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCb (_band, _channel, _in_or_out, ARCOMMANDS_Decoder_ARDrone3NetworkStateWifiAuthChannelListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkStateAllWifiAuthChannelChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkStateAllWifiAuthChannelChangedCallback) {
                                decoder->ARDrone3NetworkStateAllWifiAuthChannelChangedCallback (decoder->ARDrone3NetworkStateAllWifiAuthChannelChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_ARDrone3NetworkStateAllWifiAuthChannelChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXALTITUDE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsMaxAltitudeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsMaxAltitudeCallback) {
                                decoder->ARDrone3PilotingSettingsMaxAltitudeCallback (_current, decoder->ARDrone3PilotingSettingsMaxAltitudeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCb (_current, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxAltitudeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXALTITUDE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXTILT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsMaxTiltCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsMaxTiltCallback) {
                                decoder->ARDrone3PilotingSettingsMaxTiltCallback (_current, decoder->ARDrone3PilotingSettingsMaxTiltCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCb (_current, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxTiltCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXTILT */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_ABSOLUTCONTROL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsAbsolutControlCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCb))
                    {
                        uint8_t _on;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _on = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsAbsolutControlCallback) {
                                decoder->ARDrone3PilotingSettingsAbsolutControlCallback (_on, decoder->ARDrone3PilotingSettingsAbsolutControlCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCb (_on, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsAbsolutControlCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_ABSOLUTCONTROL */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXDISTANCE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsMaxDistanceCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsMaxDistanceCallback) {
                                decoder->ARDrone3PilotingSettingsMaxDistanceCallback (_value, decoder->ARDrone3PilotingSettingsMaxDistanceCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMaxDistanceCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXDISTANCE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_NOFLYOVERMAXDISTANCE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCb))
                    {
                        uint8_t _shouldNotFlyOver;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _shouldNotFlyOver = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback) {
                                decoder->ARDrone3PilotingSettingsNoFlyOverMaxDistanceCallback (_shouldNotFlyOver, decoder->ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCb (_shouldNotFlyOver, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsNoFlyOverMaxDistanceCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_NOFLYOVERMAXDISTANCE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback) {
                                decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCallback (_value, decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback) {
                                decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCallback (_value, decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback) {
                                decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCallback (_value, decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAccelerationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALACCELERATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback) {
                                decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCallback (_value, decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAccelerationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXROTATIONSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback) {
                                decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCallback (_value, decoder->ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXROTATIONSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_BANKEDTURN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsBankedTurnCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCb))
                    {
                        uint8_t _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsBankedTurnCallback) {
                                decoder->ARDrone3PilotingSettingsBankedTurnCallback (_value, decoder->ARDrone3PilotingSettingsBankedTurnCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsBankedTurnCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_BANKEDTURN */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MINALTITUDE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsMinAltitudeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsMinAltitudeCallback) {
                                decoder->ARDrone3PilotingSettingsMinAltitudeCallback (_current, decoder->ARDrone3PilotingSettingsMinAltitudeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCb (_current, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsMinAltitudeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MINALTITUDE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGDIRECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsCirclingDirectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_CIRCLINGDIRECTION_VALUE _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_CIRCLINGDIRECTION_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsCirclingDirectionCallback) {
                                decoder->ARDrone3PilotingSettingsCirclingDirectionCallback (_value, decoder->ARDrone3PilotingSettingsCirclingDirectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingDirectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGDIRECTION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGRADIUS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsCirclingRadiusCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCb))
                    {
                        uint16_t _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsCirclingRadiusCallback) {
                                decoder->ARDrone3PilotingSettingsCirclingRadiusCallback (_value, decoder->ARDrone3PilotingSettingsCirclingRadiusCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingRadiusCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGRADIUS */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGALTITUDE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsCirclingAltitudeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCb))
                    {
                        uint16_t _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsCirclingAltitudeCallback) {
                                decoder->ARDrone3PilotingSettingsCirclingAltitudeCallback (_value, decoder->ARDrone3PilotingSettingsCirclingAltitudeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsCirclingAltitudeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGALTITUDE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_PITCHMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsPitchModeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_PITCHMODE_VALUE _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_PITCHMODE_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsPitchModeCallback) {
                                decoder->ARDrone3PilotingSettingsPitchModeCallback (_value, decoder->ARDrone3PilotingSettingsPitchModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsPitchModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_PITCHMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateMaxAltitudeChangedCallback (_current, _min, _max, decoder->ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxAltitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateMaxTiltChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateMaxTiltChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateMaxTiltChangedCallback (_current, _min, _max, decoder->ARDrone3PilotingSettingsStateMaxTiltChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxTiltChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_ABSOLUTCONTROLCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateAbsolutControlChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCb))
                    {
                        uint8_t _on;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _on = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateAbsolutControlChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateAbsolutControlChangedCallback (_on, decoder->ARDrone3PilotingSettingsStateAbsolutControlChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCb (_on, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAbsolutControlChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_ABSOLUTCONTROLCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXDISTANCECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateMaxDistanceChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateMaxDistanceChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateMaxDistanceChangedCallback (_current, _min, _max, decoder->ARDrone3PilotingSettingsStateMaxDistanceChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMaxDistanceChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXDISTANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_NOFLYOVERMAXDISTANCECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb))
                    {
                        uint8_t _shouldNotFlyOver;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _shouldNotFlyOver = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback (_shouldNotFlyOver, decoder->ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb (_shouldNotFlyOver, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_NOFLYOVERMAXDISTANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback) {
                                decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback (_value, decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback) {
                                decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback (_value, decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback) {
                                decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback (_value, decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALACCELERATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback) {
                                decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback (_value, decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXROTATIONSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback) {
                                decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback (_value, decoder->ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXROTATIONSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_BANKEDTURNCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateBankedTurnChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCb))
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateBankedTurnChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateBankedTurnChangedCallback (_state, decoder->ARDrone3PilotingSettingsStateBankedTurnChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateBankedTurnChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_BANKEDTURNCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MINALTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateMinAltitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateMinAltitudeChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateMinAltitudeChangedCallback (_current, _min, _max, decoder->ARDrone3PilotingSettingsStateMinAltitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateMinAltitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MINALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGDIRECTIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateCirclingDirectionChangedCallback (_value, decoder->ARDrone3PilotingSettingsStateCirclingDirectionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingDirectionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGDIRECTIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGRADIUSCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCb))
                    {
                        uint16_t _current;
                        uint16_t _min;
                        uint16_t _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateCirclingRadiusChangedCallback (_current, _min, _max, decoder->ARDrone3PilotingSettingsStateCirclingRadiusChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingRadiusChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGRADIUSCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGALTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCb))
                    {
                        uint16_t _current;
                        uint16_t _min;
                        uint16_t _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStateCirclingAltitudeChangedCallback (_current, _min, _max, decoder->ARDrone3PilotingSettingsStateCirclingAltitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStateCirclingAltitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_PITCHMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PilotingSettingsStatePitchModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PilotingSettingsStatePitchModeChangedCallback) {
                                decoder->ARDrone3PilotingSettingsStatePitchModeChangedCallback (_value, decoder->ARDrone3PilotingSettingsStatePitchModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCb (_value, ARCOMMANDS_Decoder_ARDrone3PilotingSettingsStatePitchModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_PITCHMODECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXVERTICALSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsMaxVerticalSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsMaxVerticalSpeedCallback) {
                                decoder->ARDrone3SpeedSettingsMaxVerticalSpeedCallback (_current, decoder->ARDrone3SpeedSettingsMaxVerticalSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCb (_current, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxVerticalSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXVERTICALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXROTATIONSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsMaxRotationSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsMaxRotationSpeedCallback) {
                                decoder->ARDrone3SpeedSettingsMaxRotationSpeedCallback (_current, decoder->ARDrone3SpeedSettingsMaxRotationSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCb (_current, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxRotationSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXROTATIONSPEED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_HULLPROTECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsHullProtectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCb))
                    {
                        uint8_t _present;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _present = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsHullProtectionCallback) {
                                decoder->ARDrone3SpeedSettingsHullProtectionCallback (_present, decoder->ARDrone3SpeedSettingsHullProtectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCb (_present, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsHullProtectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_HULLPROTECTION */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_OUTDOOR:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsOutdoorCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCb))
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsOutdoorCallback) {
                                decoder->ARDrone3SpeedSettingsOutdoorCallback (_outdoor, decoder->ARDrone3SpeedSettingsOutdoorCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCb (_outdoor, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsOutdoorCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_OUTDOOR */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXPITCHROLLROTATIONSPEED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCb))
                    {
                        float _current;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback) {
                                decoder->ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCallback (_current, decoder->ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCb (_current, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsMaxPitchRollRotationSpeedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXPITCHROLLROTATIONSPEED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback) {
                                decoder->ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCallback (_current, _min, _max, decoder->ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback) {
                                decoder->ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCallback (_current, _min, _max, decoder->ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxRotationSpeedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_HULLPROTECTIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsStateHullProtectionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCb))
                    {
                        uint8_t _present;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _present = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsStateHullProtectionChangedCallback) {
                                decoder->ARDrone3SpeedSettingsStateHullProtectionChangedCallback (_present, decoder->ARDrone3SpeedSettingsStateHullProtectionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCb (_present, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateHullProtectionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_HULLPROTECTIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsStateOutdoorChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCb))
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsStateOutdoorChangedCallback) {
                                decoder->ARDrone3SpeedSettingsStateOutdoorChangedCallback (_outdoor, decoder->ARDrone3SpeedSettingsStateOutdoorChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCb (_outdoor, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateOutdoorChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXPITCHROLLROTATIONSPEEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCb))
                    {
                        float _current;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback) {
                                decoder->ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback (_current, _min, _max, decoder->ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCb (_current, _min, _max, ARCOMMANDS_Decoder_ARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXPITCHROLLROTATIONSPEEDCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkSettingsWifiSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCb))
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE _type;
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkSettingsWifiSelectionCallback) {
                                decoder->ARDrone3NetworkSettingsWifiSelectionCallback (_type, _band, _channel, decoder->ARDrone3NetworkSettingsWifiSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCb (_type, _band, _channel, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISELECTION */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISECURITY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkSettingsWifiSecurityCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCb))
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_TYPE _type;
                        char * _key = NULL;
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_KEYTYPE _keyType;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _keyType = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_KEYTYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkSettingsWifiSecurityCallback) {
                                decoder->ARDrone3NetworkSettingsWifiSecurityCallback (_type, _key, _keyType, decoder->ARDrone3NetworkSettingsWifiSecurityCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCb (_type, _key, _keyType, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsWifiSecurityCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISECURITY */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkSettingsStateWifiSelectionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type;
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkSettingsStateWifiSelectionChangedCallback) {
                                decoder->ARDrone3NetworkSettingsStateWifiSelectionChangedCallback (_type, _band, _channel, decoder->ARDrone3NetworkSettingsStateWifiSelectionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCb (_type, _band, _channel, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSelectionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkSettingsStateWifiSecurityChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkSettingsStateWifiSecurityChangedCallback) {
                                decoder->ARDrone3NetworkSettingsStateWifiSecurityChangedCallback (_type, decoder->ARDrone3NetworkSettingsStateWifiSecurityChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3NetworkSettingsStateWifiSecurityCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCb))
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE _type;
                        char * _key = NULL;
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE _keyType;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _keyType = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3NetworkSettingsStateWifiSecurityCallback) {
                                decoder->ARDrone3NetworkSettingsStateWifiSecurityCallback (_type, _key, _keyType, decoder->ARDrone3NetworkSettingsStateWifiSecurityCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCb (_type, _key, _keyType, ARCOMMANDS_Decoder_ARDrone3NetworkSettingsStateWifiSecurityCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITY */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTMOTORVERSIONLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateProductMotorVersionListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCb))
                    {
                        uint8_t _motor_number;
                        char * _type = NULL;
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _motor_number = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateProductMotorVersionListChangedCallback) {
                                decoder->ARDrone3SettingsStateProductMotorVersionListChangedCallback (_motor_number, _type, _software, _hardware, decoder->ARDrone3SettingsStateProductMotorVersionListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCb (_motor_number, _type, _software, _hardware, ARCOMMANDS_Decoder_ARDrone3SettingsStateProductMotorVersionListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTMOTORVERSIONLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateProductGPSVersionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCb))
                    {
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateProductGPSVersionChangedCallback) {
                                decoder->ARDrone3SettingsStateProductGPSVersionChangedCallback (_software, _hardware, decoder->ARDrone3SettingsStateProductGPSVersionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCb (_software, _hardware, ARCOMMANDS_Decoder_ARDrone3SettingsStateProductGPSVersionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateMotorErrorStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCb))
                    {
                        uint8_t _motorIds;
                        eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR _motorError;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _motorIds = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _motorError = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateMotorErrorStateChangedCallback) {
                                decoder->ARDrone3SettingsStateMotorErrorStateChangedCallback (_motorIds, _motorError, decoder->ARDrone3SettingsStateMotorErrorStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCb (_motorIds, _motorError, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORSOFTWAREVERSIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateMotorSoftwareVersionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCb))
                    {
                        char * _version = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _version = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateMotorSoftwareVersionChangedCallback) {
                                decoder->ARDrone3SettingsStateMotorSoftwareVersionChangedCallback (_version, decoder->ARDrone3SettingsStateMotorSoftwareVersionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCb (_version, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorSoftwareVersionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORSOFTWAREVERSIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORFLIGHTSSTATUSCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateMotorFlightsStatusChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCb))
                    {
                        uint16_t _nbFlights;
                        uint16_t _lastFlightDuration;
                        uint32_t _totalFlightDuration;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbFlights = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _lastFlightDuration = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _totalFlightDuration = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateMotorFlightsStatusChangedCallback) {
                                decoder->ARDrone3SettingsStateMotorFlightsStatusChangedCallback (_nbFlights, _lastFlightDuration, _totalFlightDuration, decoder->ARDrone3SettingsStateMotorFlightsStatusChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCb (_nbFlights, _lastFlightDuration, _totalFlightDuration, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorFlightsStatusChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORFLIGHTSSTATUSCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORLASTERRORCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateMotorErrorLastErrorChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR _motorError;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _motorError = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateMotorErrorLastErrorChangedCallback) {
                                decoder->ARDrone3SettingsStateMotorErrorLastErrorChangedCallback (_motorError, decoder->ARDrone3SettingsStateMotorErrorLastErrorChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCb (_motorError, ARCOMMANDS_Decoder_ARDrone3SettingsStateMotorErrorLastErrorChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORLASTERRORCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_P7ID:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateP7IDCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCb))
                    {
                        char * _serialID = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serialID = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateP7IDCallback) {
                                decoder->ARDrone3SettingsStateP7IDCallback (_serialID, decoder->ARDrone3SettingsStateP7IDCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCb (_serialID, ARCOMMANDS_Decoder_ARDrone3SettingsStateP7IDCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_P7ID */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_CPUID:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3SettingsStateCPUIDCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCb))
                    {
                        char * _id = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3SettingsStateCPUIDCallback) {
                                decoder->ARDrone3SettingsStateCPUIDCallback (_id, decoder->ARDrone3SettingsStateCPUIDCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCb (_id, ARCOMMANDS_Decoder_ARDrone3SettingsStateCPUIDCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_CPUID */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_PICTUREFORMATSELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsPictureFormatSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsPictureFormatSelectionCallback) {
                                decoder->ARDrone3PictureSettingsPictureFormatSelectionCallback (_type, decoder->ARDrone3PictureSettingsPictureFormatSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsPictureFormatSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_PICTUREFORMATSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_AUTOWHITEBALANCESELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback) {
                                decoder->ARDrone3PictureSettingsAutoWhiteBalanceSelectionCallback (_type, decoder->ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsAutoWhiteBalanceSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_AUTOWHITEBALANCESELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_EXPOSITIONSELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsExpositionSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsExpositionSelectionCallback) {
                                decoder->ARDrone3PictureSettingsExpositionSelectionCallback (_value, decoder->ARDrone3PictureSettingsExpositionSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCb (_value, ARCOMMANDS_Decoder_ARDrone3PictureSettingsExpositionSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_EXPOSITIONSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_SATURATIONSELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsSaturationSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCb))
                    {
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsSaturationSelectionCallback) {
                                decoder->ARDrone3PictureSettingsSaturationSelectionCallback (_value, decoder->ARDrone3PictureSettingsSaturationSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCb (_value, ARCOMMANDS_Decoder_ARDrone3PictureSettingsSaturationSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_SATURATIONSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_TIMELAPSESELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsTimelapseSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCb))
                    {
                        uint8_t _enabled;
                        float _interval;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _interval = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsTimelapseSelectionCallback) {
                                decoder->ARDrone3PictureSettingsTimelapseSelectionCallback (_enabled, _interval, decoder->ARDrone3PictureSettingsTimelapseSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCb (_enabled, _interval, ARCOMMANDS_Decoder_ARDrone3PictureSettingsTimelapseSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_TIMELAPSESELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOAUTORECORDSELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsVideoAutorecordSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCb))
                    {
                        uint8_t _enabled;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsVideoAutorecordSelectionCallback) {
                                decoder->ARDrone3PictureSettingsVideoAutorecordSelectionCallback (_enabled, _mass_storage_id, decoder->ARDrone3PictureSettingsVideoAutorecordSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCb (_enabled, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoAutorecordSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOAUTORECORDSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOSTABILIZATIONMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsVideoStabilizationModeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOSTABILIZATIONMODE_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOSTABILIZATIONMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsVideoStabilizationModeCallback) {
                                decoder->ARDrone3PictureSettingsVideoStabilizationModeCallback (_mode, decoder->ARDrone3PictureSettingsVideoStabilizationModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCb (_mode, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoStabilizationModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOSTABILIZATIONMODE */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORECORDINGMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsVideoRecordingModeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORECORDINGMODE_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORECORDINGMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsVideoRecordingModeCallback) {
                                decoder->ARDrone3PictureSettingsVideoRecordingModeCallback (_mode, decoder->ARDrone3PictureSettingsVideoRecordingModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCb (_mode, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoRecordingModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORECORDINGMODE */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOFRAMERATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsVideoFramerateCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOFRAMERATE_FRAMERATE _framerate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _framerate = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOFRAMERATE_FRAMERATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsVideoFramerateCallback) {
                                decoder->ARDrone3PictureSettingsVideoFramerateCallback (_framerate, decoder->ARDrone3PictureSettingsVideoFramerateCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCb (_framerate, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoFramerateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOFRAMERATE */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORESOLUTIONS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsVideoResolutionsCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORESOLUTIONS_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORESOLUTIONS_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsVideoResolutionsCallback) {
                                decoder->ARDrone3PictureSettingsVideoResolutionsCallback (_type, decoder->ARDrone3PictureSettingsVideoResolutionsCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsVideoResolutionsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORESOLUTIONS */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_PICTUREFORMATCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStatePictureFormatChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStatePictureFormatChangedCallback) {
                                decoder->ARDrone3PictureSettingsStatePictureFormatChangedCallback (_type, decoder->ARDrone3PictureSettingsStatePictureFormatChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStatePictureFormatChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_PICTUREFORMATCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_AUTOWHITEBALANCECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCallback (_type, decoder->ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateAutoWhiteBalanceChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_AUTOWHITEBALANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_EXPOSITIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateExpositionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCb))
                    {
                        float _value;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateExpositionChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateExpositionChangedCallback (_value, _min, _max, decoder->ARDrone3PictureSettingsStateExpositionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCb (_value, _min, _max, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateExpositionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_EXPOSITIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_SATURATIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateSaturationChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCb))
                    {
                        float _value;
                        float _min;
                        float _max;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateSaturationChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateSaturationChangedCallback (_value, _min, _max, decoder->ARDrone3PictureSettingsStateSaturationChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCb (_value, _min, _max, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateSaturationChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_SATURATIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_TIMELAPSECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateTimelapseChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCb))
                    {
                        uint8_t _enabled;
                        float _interval;
                        float _minInterval;
                        float _maxInterval;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _interval = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _minInterval = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _maxInterval = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateTimelapseChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateTimelapseChangedCallback (_enabled, _interval, _minInterval, _maxInterval, decoder->ARDrone3PictureSettingsStateTimelapseChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCb (_enabled, _interval, _minInterval, _maxInterval, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateTimelapseChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_TIMELAPSECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOAUTORECORDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateVideoAutorecordChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCb))
                    {
                        uint8_t _enabled;
                        uint8_t _mass_storage_id;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateVideoAutorecordChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateVideoAutorecordChangedCallback (_enabled, _mass_storage_id, decoder->ARDrone3PictureSettingsStateVideoAutorecordChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCb (_enabled, _mass_storage_id, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoAutorecordChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOAUTORECORDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOSTABILIZATIONMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateVideoStabilizationModeChangedCallback (_mode, decoder->ARDrone3PictureSettingsStateVideoStabilizationModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCb (_mode, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoStabilizationModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOSTABILIZATIONMODECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORECORDINGMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateVideoRecordingModeChangedCallback (_mode, decoder->ARDrone3PictureSettingsStateVideoRecordingModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCb (_mode, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoRecordingModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORECORDINGMODECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOFRAMERATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateVideoFramerateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE _framerate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _framerate = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateVideoFramerateChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateVideoFramerateChangedCallback (_framerate, decoder->ARDrone3PictureSettingsStateVideoFramerateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCb (_framerate, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoFramerateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOFRAMERATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORESOLUTIONSCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PictureSettingsStateVideoResolutionsChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PictureSettingsStateVideoResolutionsChangedCallback) {
                                decoder->ARDrone3PictureSettingsStateVideoResolutionsChangedCallback (_type, decoder->ARDrone3PictureSettingsStateVideoResolutionsChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3PictureSettingsStateVideoResolutionsChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORESOLUTIONSCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOENABLE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaStreamingVideoEnableCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCb))
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaStreamingVideoEnableCallback) {
                                decoder->ARDrone3MediaStreamingVideoEnableCallback (_enable, decoder->ARDrone3MediaStreamingVideoEnableCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCb (_enable, ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoEnableCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOENABLE */
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOSTREAMMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaStreamingVideoStreamModeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIASTREAMING_VIDEOSTREAMMODE_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_MEDIASTREAMING_VIDEOSTREAMMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaStreamingVideoStreamModeCallback) {
                                decoder->ARDrone3MediaStreamingVideoStreamModeCallback (_mode, decoder->ARDrone3MediaStreamingVideoStreamModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCb (_mode, ARCOMMANDS_Decoder_ARDrone3MediaStreamingVideoStreamModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOSTREAMMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaStreamingStateVideoEnableChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaStreamingStateVideoEnableChangedCallback) {
                                decoder->ARDrone3MediaStreamingStateVideoEnableChangedCallback (_enabled, decoder->ARDrone3MediaStreamingStateVideoEnableChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCb (_enabled, ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoEnableChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOSTREAMMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3MediaStreamingStateVideoStreamModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3MediaStreamingStateVideoStreamModeChangedCallback) {
                                decoder->ARDrone3MediaStreamingStateVideoStreamModeChangedCallback (_mode, decoder->ARDrone3MediaStreamingStateVideoStreamModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCb (_mode, ARCOMMANDS_Decoder_ARDrone3MediaStreamingStateVideoStreamModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOSTREAMMODECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SETHOME:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsSetHomeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCb))
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsSetHomeCallback) {
                                decoder->ARDrone3GPSSettingsSetHomeCallback (_latitude, _longitude, _altitude, decoder->ARDrone3GPSSettingsSetHomeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCb (_latitude, _longitude, _altitude, ARCOMMANDS_Decoder_ARDrone3GPSSettingsSetHomeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SETHOME */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RESETHOME:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsResetHomeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsResetHomeCallback) {
                                decoder->ARDrone3GPSSettingsResetHomeCallback (decoder->ARDrone3GPSSettingsResetHomeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCb (ARCOMMANDS_Decoder_ARDrone3GPSSettingsResetHomeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RESETHOME */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SENDCONTROLLERGPS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsSendControllerGPSCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCb))
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        double _horizontalAccuracy;
                        double _verticalAccuracy;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontalAccuracy = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _verticalAccuracy = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsSendControllerGPSCallback) {
                                decoder->ARDrone3GPSSettingsSendControllerGPSCallback (_latitude, _longitude, _altitude, _horizontalAccuracy, _verticalAccuracy, decoder->ARDrone3GPSSettingsSendControllerGPSCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCb (_latitude, _longitude, _altitude, _horizontalAccuracy, _verticalAccuracy, ARCOMMANDS_Decoder_ARDrone3GPSSettingsSendControllerGPSCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SENDCONTROLLERGPS */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_HOMETYPE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsHomeTypeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCb))
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsHomeTypeCallback) {
                                decoder->ARDrone3GPSSettingsHomeTypeCallback (_type, decoder->ARDrone3GPSSettingsHomeTypeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCb (_type, ARCOMMANDS_Decoder_ARDrone3GPSSettingsHomeTypeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_HOMETYPE */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RETURNHOMEDELAY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsReturnHomeDelayCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCb))
                    {
                        uint16_t _delay;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _delay = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsReturnHomeDelayCallback) {
                                decoder->ARDrone3GPSSettingsReturnHomeDelayCallback (_delay, decoder->ARDrone3GPSSettingsReturnHomeDelayCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCb (_delay, ARCOMMANDS_Decoder_ARDrone3GPSSettingsReturnHomeDelayCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RETURNHOMEDELAY */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsStateHomeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCb))
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsStateHomeChangedCallback) {
                                decoder->ARDrone3GPSSettingsStateHomeChangedCallback (_latitude, _longitude, _altitude, decoder->ARDrone3GPSSettingsStateHomeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCb (_latitude, _longitude, _altitude, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RESETHOMECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsStateResetHomeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCb))
                    {
                        double _latitude;
                        double _longitude;
                        double _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsStateResetHomeChangedCallback) {
                                decoder->ARDrone3GPSSettingsStateResetHomeChangedCallback (_latitude, _longitude, _altitude, decoder->ARDrone3GPSSettingsStateResetHomeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCb (_latitude, _longitude, _altitude, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateResetHomeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RESETHOMECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSFIXSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsStateGPSFixStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCb))
                    {
                        uint8_t _fixed;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _fixed = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsStateGPSFixStateChangedCallback) {
                                decoder->ARDrone3GPSSettingsStateGPSFixStateChangedCallback (_fixed, decoder->ARDrone3GPSSettingsStateGPSFixStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCb (_fixed, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSFixStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSFIXSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSUPDATESTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback) {
                                decoder->ARDrone3GPSSettingsStateGPSUpdateStateChangedCallback (_state, decoder->ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCb (_state, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateGPSUpdateStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSUPDATESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMETYPECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsStateHomeTypeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsStateHomeTypeChangedCallback) {
                                decoder->ARDrone3GPSSettingsStateHomeTypeChangedCallback (_type, decoder->ARDrone3GPSSettingsStateHomeTypeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateHomeTypeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMETYPECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RETURNHOMEDELAYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCb))
                    {
                        uint16_t _delay;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _delay = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback) {
                                decoder->ARDrone3GPSSettingsStateReturnHomeDelayChangedCallback (_delay, decoder->ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCb (_delay, ARCOMMANDS_Decoder_ARDrone3GPSSettingsStateReturnHomeDelayChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RETURNHOMEDELAYCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERASTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_ORIENTATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3CameraStateOrientationCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCb))
                    {
                        int8_t _tilt;
                        int8_t _pan;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _tilt =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pan =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3CameraStateOrientationCallback) {
                                decoder->ARDrone3CameraStateOrientationCallback (_tilt, _pan, decoder->ARDrone3CameraStateOrientationCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCb (_tilt, _pan, ARCOMMANDS_Decoder_ARDrone3CameraStateOrientationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_ORIENTATION */
                case ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_DEFAULTCAMERAORIENTATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3CameraStateDefaultCameraOrientationCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCb))
                    {
                        int8_t _tilt;
                        int8_t _pan;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _tilt =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pan =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3CameraStateDefaultCameraOrientationCallback) {
                                decoder->ARDrone3CameraStateDefaultCameraOrientationCallback (_tilt, _pan, decoder->ARDrone3CameraStateDefaultCameraOrientationCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCb (_tilt, _pan, ARCOMMANDS_Decoder_ARDrone3CameraStateDefaultCameraOrientationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_DEFAULTCAMERAORIENTATION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERASTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_ELECTRICFREQUENCY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3AntiflickeringElectricFrequencyCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCb))
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY _frequency;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _frequency = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3AntiflickeringElectricFrequencyCallback) {
                                decoder->ARDrone3AntiflickeringElectricFrequencyCallback (_frequency, decoder->ARDrone3AntiflickeringElectricFrequencyCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCb (_frequency, ARCOMMANDS_Decoder_ARDrone3AntiflickeringElectricFrequencyCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_ELECTRICFREQUENCY */
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_SETMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3AntiflickeringSetModeCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCb))
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3AntiflickeringSetModeCallback) {
                                decoder->ARDrone3AntiflickeringSetModeCallback (_mode, decoder->ARDrone3AntiflickeringSetModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCb (_mode, ARCOMMANDS_Decoder_ARDrone3AntiflickeringSetModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_SETMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_ELECTRICFREQUENCYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3AntiflickeringStateElectricFrequencyChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY _frequency;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _frequency = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3AntiflickeringStateElectricFrequencyChangedCallback) {
                                decoder->ARDrone3AntiflickeringStateElectricFrequencyChangedCallback (_frequency, decoder->ARDrone3AntiflickeringStateElectricFrequencyChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCb (_frequency, ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateElectricFrequencyChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_ELECTRICFREQUENCYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_MODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3AntiflickeringStateModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3AntiflickeringStateModeChangedCallback) {
                                decoder->ARDrone3AntiflickeringStateModeChangedCallback (_mode, decoder->ARDrone3AntiflickeringStateModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCb (_mode, ARCOMMANDS_Decoder_ARDrone3AntiflickeringStateModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_MODECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_NUMBEROFSATELLITECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSStateNumberOfSatelliteChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCb))
                    {
                        uint8_t _numberOfSatellite;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _numberOfSatellite = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSStateNumberOfSatelliteChangedCallback) {
                                decoder->ARDrone3GPSStateNumberOfSatelliteChangedCallback (_numberOfSatellite, decoder->ARDrone3GPSStateNumberOfSatelliteChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCb (_numberOfSatellite, ARCOMMANDS_Decoder_ARDrone3GPSStateNumberOfSatelliteChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_NUMBEROFSATELLITECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPEAVAILABILITYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSStateHomeTypeAvailabilityChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE _type;
                        uint8_t _available;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _available = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSStateHomeTypeAvailabilityChangedCallback) {
                                decoder->ARDrone3GPSStateHomeTypeAvailabilityChangedCallback (_type, _available, decoder->ARDrone3GPSStateHomeTypeAvailabilityChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCb (_type, _available, ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeAvailabilityChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPEAVAILABILITYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPECHOSENCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3GPSStateHomeTypeChosenChangedCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCb))
                    {
                        eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3GPSStateHomeTypeChosenChangedCallback) {
                                decoder->ARDrone3GPSStateHomeTypeChosenChangedCallback (_type, decoder->ARDrone3GPSStateHomeTypeChosenChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCb (_type, ARCOMMANDS_Decoder_ARDrone3GPSStateHomeTypeChosenChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPECHOSENCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PROSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PROSTATE_CMD_FEATURES:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ARDrone3PROStateFeaturesCallback) || (!decoder && ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCb))
                    {
                        uint64_t _features;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _features = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ARDrone3PROStateFeaturesCallback) {
                                decoder->ARDrone3PROStateFeaturesCallback (_features, decoder->ARDrone3PROStateFeaturesCustom);
                            } else {
                                ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCb (_features, ARCOMMANDS_Decoder_ARDrone3PROStateFeaturesCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PROSTATE_CMD_FEATURES */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PROSTATE */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_ARDRONE3 */
        case ARCOMMANDS_ID_FEATURE_COMMON:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_COMMON_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_NETWORK_CMD_DISCONNECT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonNetworkDisconnectCallback) || (!decoder && ARCOMMANDS_Decoder_CommonNetworkDisconnectCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonNetworkDisconnectCallback) {
                                decoder->CommonNetworkDisconnectCallback (decoder->CommonNetworkDisconnectCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonNetworkDisconnectCb (ARCOMMANDS_Decoder_CommonNetworkDisconnectCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_NETWORK_CMD_DISCONNECT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_NETWORK */
            case ARCOMMANDS_ID_COMMON_CLASS_NETWORKEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_NETWORKEVENT_CMD_DISCONNECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonNetworkEventDisconnectionCallback) || (!decoder && ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCb))
                    {
                        eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE _cause;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _cause = (eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonNetworkEventDisconnectionCallback) {
                                decoder->CommonNetworkEventDisconnectionCallback (_cause, decoder->CommonNetworkEventDisconnectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCb (_cause, ARCOMMANDS_Decoder_CommonNetworkEventDisconnectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_NETWORKEVENT_CMD_DISCONNECTION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_NETWORKEVENT */
            case ARCOMMANDS_ID_COMMON_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_ALLSETTINGS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsAllSettingsCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsAllSettingsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsAllSettingsCallback) {
                                decoder->CommonSettingsAllSettingsCallback (decoder->CommonSettingsAllSettingsCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsAllSettingsCb (ARCOMMANDS_Decoder_CommonSettingsAllSettingsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_ALLSETTINGS */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_RESET:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsResetCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsResetCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsResetCallback) {
                                decoder->CommonSettingsResetCallback (decoder->CommonSettingsResetCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsResetCb (ARCOMMANDS_Decoder_CommonSettingsResetCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_RESET */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_PRODUCTNAME:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsProductNameCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsProductNameCb))
                    {
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsProductNameCallback) {
                                decoder->CommonSettingsProductNameCallback (_name, decoder->CommonSettingsProductNameCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsProductNameCb (_name, ARCOMMANDS_Decoder_CommonSettingsProductNameCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_PRODUCTNAME */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_COUNTRY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsCountryCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsCountryCb))
                    {
                        char * _code = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _code = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsCountryCallback) {
                                decoder->CommonSettingsCountryCallback (_code, decoder->CommonSettingsCountryCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsCountryCb (_code, ARCOMMANDS_Decoder_CommonSettingsCountryCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_COUNTRY */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_AUTOCOUNTRY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsAutoCountryCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsAutoCountryCb))
                    {
                        uint8_t _automatic;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _automatic = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsAutoCountryCallback) {
                                decoder->CommonSettingsAutoCountryCallback (_automatic, decoder->CommonSettingsAutoCountryCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsAutoCountryCb (_automatic, ARCOMMANDS_Decoder_CommonSettingsAutoCountryCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_AUTOCOUNTRY */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_SETTINGS */
            case ARCOMMANDS_ID_COMMON_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateAllSettingsChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateAllSettingsChangedCallback) {
                                decoder->CommonSettingsStateAllSettingsChangedCallback (decoder->CommonSettingsStateAllSettingsChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCb (ARCOMMANDS_Decoder_CommonSettingsStateAllSettingsChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_RESETCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateResetChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateResetChangedCallback) {
                                decoder->CommonSettingsStateResetChangedCallback (decoder->CommonSettingsStateResetChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCb (ARCOMMANDS_Decoder_CommonSettingsStateResetChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_RESETCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTNAMECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateProductNameChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCb))
                    {
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateProductNameChangedCallback) {
                                decoder->CommonSettingsStateProductNameChangedCallback (_name, decoder->CommonSettingsStateProductNameChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCb (_name, ARCOMMANDS_Decoder_CommonSettingsStateProductNameChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTNAMECHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateProductVersionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCb))
                    {
                        char * _software = NULL;
                        char * _hardware = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _software = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _hardware = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateProductVersionChangedCallback) {
                                decoder->CommonSettingsStateProductVersionChangedCallback (_software, _hardware, decoder->CommonSettingsStateProductVersionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCb (_software, _hardware, ARCOMMANDS_Decoder_CommonSettingsStateProductVersionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALHIGHCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateProductSerialHighChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCb))
                    {
                        char * _high = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _high = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateProductSerialHighChangedCallback) {
                                decoder->CommonSettingsStateProductSerialHighChangedCallback (_high, decoder->CommonSettingsStateProductSerialHighChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCb (_high, ARCOMMANDS_Decoder_CommonSettingsStateProductSerialHighChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALHIGHCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALLOWCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateProductSerialLowChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCb))
                    {
                        char * _low = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _low = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateProductSerialLowChangedCallback) {
                                decoder->CommonSettingsStateProductSerialLowChangedCallback (_low, decoder->CommonSettingsStateProductSerialLowChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCb (_low, ARCOMMANDS_Decoder_CommonSettingsStateProductSerialLowChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALLOWCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_COUNTRYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateCountryChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCb))
                    {
                        char * _code = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _code = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateCountryChangedCallback) {
                                decoder->CommonSettingsStateCountryChangedCallback (_code, decoder->CommonSettingsStateCountryChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCb (_code, ARCOMMANDS_Decoder_CommonSettingsStateCountryChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_COUNTRYCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_AUTOCOUNTRYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonSettingsStateAutoCountryChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCb))
                    {
                        uint8_t _automatic;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _automatic = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonSettingsStateAutoCountryChangedCallback) {
                                decoder->CommonSettingsStateAutoCountryChangedCallback (_automatic, decoder->CommonSettingsStateAutoCountryChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCb (_automatic, ARCOMMANDS_Decoder_CommonSettingsStateAutoCountryChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_AUTOCOUNTRYCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_COMMON:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_ALLSTATES:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonAllStatesCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonAllStatesCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonAllStatesCallback) {
                                decoder->CommonCommonAllStatesCallback (decoder->CommonCommonAllStatesCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonAllStatesCb (ARCOMMANDS_Decoder_CommonCommonAllStatesCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_ALLSTATES */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTDATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonCurrentDateCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonCurrentDateCb))
                    {
                        char * _date = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _date = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonCurrentDateCallback) {
                                decoder->CommonCommonCurrentDateCallback (_date, decoder->CommonCommonCurrentDateCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonCurrentDateCb (_date, ARCOMMANDS_Decoder_CommonCommonCurrentDateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTDATE */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTTIME:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonCurrentTimeCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonCurrentTimeCb))
                    {
                        char * _time = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _time = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonCurrentTimeCallback) {
                                decoder->CommonCommonCurrentTimeCallback (_time, decoder->CommonCommonCurrentTimeCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonCurrentTimeCb (_time, ARCOMMANDS_Decoder_CommonCommonCurrentTimeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTTIME */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_REBOOT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonRebootCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonRebootCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonRebootCallback) {
                                decoder->CommonCommonRebootCallback (decoder->CommonCommonRebootCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonRebootCb (ARCOMMANDS_Decoder_CommonCommonRebootCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_REBOOT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_COMMON */
            case ARCOMMANDS_ID_COMMON_CLASS_COMMONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_ALLSTATESCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateAllStatesChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateAllStatesChangedCallback) {
                                decoder->CommonCommonStateAllStatesChangedCallback (decoder->CommonCommonStateAllStatesChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCb (ARCOMMANDS_Decoder_CommonCommonStateAllStatesChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_ALLSTATESCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_BATTERYSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateBatteryStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCb))
                    {
                        uint8_t _percent;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _percent = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateBatteryStateChangedCallback) {
                                decoder->CommonCommonStateBatteryStateChangedCallback (_percent, decoder->CommonCommonStateBatteryStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCb (_percent, ARCOMMANDS_Decoder_CommonCommonStateBatteryStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_BATTERYSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGESTATELISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateMassStorageStateListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCb))
                    {
                        uint8_t _mass_storage_id;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateMassStorageStateListChangedCallback) {
                                decoder->CommonCommonStateMassStorageStateListChangedCallback (_mass_storage_id, _name, decoder->CommonCommonStateMassStorageStateListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCb (_mass_storage_id, _name, ARCOMMANDS_Decoder_CommonCommonStateMassStorageStateListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGESTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOSTATELISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateMassStorageInfoStateListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCb))
                    {
                        uint8_t _mass_storage_id;
                        uint32_t _size;
                        uint32_t _used_size;
                        uint8_t _plugged;
                        uint8_t _full;
                        uint8_t _internal;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _size = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _used_size = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _plugged = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _full = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _internal = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateMassStorageInfoStateListChangedCallback) {
                                decoder->CommonCommonStateMassStorageInfoStateListChangedCallback (_mass_storage_id, _size, _used_size, _plugged, _full, _internal, decoder->CommonCommonStateMassStorageInfoStateListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCb (_mass_storage_id, _size, _used_size, _plugged, _full, _internal, ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoStateListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOSTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTDATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateCurrentDateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCb))
                    {
                        char * _date = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _date = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateCurrentDateChangedCallback) {
                                decoder->CommonCommonStateCurrentDateChangedCallback (_date, decoder->CommonCommonStateCurrentDateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCb (_date, ARCOMMANDS_Decoder_CommonCommonStateCurrentDateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTDATECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTTIMECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateCurrentTimeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCb))
                    {
                        char * _time = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _time = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateCurrentTimeChangedCallback) {
                                decoder->CommonCommonStateCurrentTimeChangedCallback (_time, decoder->CommonCommonStateCurrentTimeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCb (_time, ARCOMMANDS_Decoder_CommonCommonStateCurrentTimeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTTIMECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOREMAININGLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateMassStorageInfoRemainingListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCb))
                    {
                        uint32_t _free_space;
                        uint16_t _rec_time;
                        uint32_t _photo_remaining;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _free_space = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rec_time = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _photo_remaining = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateMassStorageInfoRemainingListChangedCallback) {
                                decoder->CommonCommonStateMassStorageInfoRemainingListChangedCallback (_free_space, _rec_time, _photo_remaining, decoder->CommonCommonStateMassStorageInfoRemainingListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCb (_free_space, _rec_time, _photo_remaining, ARCOMMANDS_Decoder_CommonCommonStateMassStorageInfoRemainingListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOREMAININGLISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_WIFISIGNALCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateWifiSignalChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCb))
                    {
                        int16_t _rssi;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateWifiSignalChangedCallback) {
                                decoder->CommonCommonStateWifiSignalChangedCallback (_rssi, decoder->CommonCommonStateWifiSignalChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCb (_rssi, ARCOMMANDS_Decoder_CommonCommonStateWifiSignalChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_WIFISIGNALCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_SENSORSSTATESLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateSensorsStatesListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCb))
                    {
                        eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME _sensorName;
                        uint8_t _sensorState;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _sensorName = (eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _sensorState = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateSensorsStatesListChangedCallback) {
                                decoder->CommonCommonStateSensorsStatesListChangedCallback (_sensorName, _sensorState, decoder->CommonCommonStateSensorsStatesListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCb (_sensorName, _sensorState, ARCOMMANDS_Decoder_CommonCommonStateSensorsStatesListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_SENSORSSTATESLISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_PRODUCTMODEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateProductModelCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateProductModelCb))
                    {
                        eARCOMMANDS_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL _model;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _model = (eARCOMMANDS_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateProductModelCallback) {
                                decoder->CommonCommonStateProductModelCallback (_model, decoder->CommonCommonStateProductModelCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateProductModelCb (_model, ARCOMMANDS_Decoder_CommonCommonStateProductModelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_PRODUCTMODEL */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_COUNTRYLISTKNOWN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateCountryListKnownCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCb))
                    {
                        uint8_t _listFlags;
                        char * _countryCodes = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _listFlags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _countryCodes = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateCountryListKnownCallback) {
                                decoder->CommonCommonStateCountryListKnownCallback (_listFlags, _countryCodes, decoder->CommonCommonStateCountryListKnownCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCb (_listFlags, _countryCodes, ARCOMMANDS_Decoder_CommonCommonStateCountryListKnownCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_COUNTRYLISTKNOWN */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_DEPRECATEDMASSSTORAGECONTENTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateDeprecatedMassStorageContentChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCb))
                    {
                        uint8_t _mass_storage_id;
                        uint16_t _nbPhotos;
                        uint16_t _nbVideos;
                        uint16_t _nbPuds;
                        uint16_t _nbCrashLogs;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbPhotos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbVideos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbPuds = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbCrashLogs = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateDeprecatedMassStorageContentChangedCallback) {
                                decoder->CommonCommonStateDeprecatedMassStorageContentChangedCallback (_mass_storage_id, _nbPhotos, _nbVideos, _nbPuds, _nbCrashLogs, decoder->CommonCommonStateDeprecatedMassStorageContentChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCb (_mass_storage_id, _nbPhotos, _nbVideos, _nbPuds, _nbCrashLogs, ARCOMMANDS_Decoder_CommonCommonStateDeprecatedMassStorageContentChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_DEPRECATEDMASSSTORAGECONTENTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateMassStorageContentCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCb))
                    {
                        uint8_t _mass_storage_id;
                        uint16_t _nbPhotos;
                        uint16_t _nbVideos;
                        uint16_t _nbPuds;
                        uint16_t _nbCrashLogs;
                        uint16_t _nbRawPhotos;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbPhotos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbVideos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbPuds = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbCrashLogs = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbRawPhotos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateMassStorageContentCallback) {
                                decoder->CommonCommonStateMassStorageContentCallback (_mass_storage_id, _nbPhotos, _nbVideos, _nbPuds, _nbCrashLogs, _nbRawPhotos, decoder->CommonCommonStateMassStorageContentCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCb (_mass_storage_id, _nbPhotos, _nbVideos, _nbPuds, _nbCrashLogs, _nbRawPhotos, ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENT */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENTFORCURRENTRUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCommonStateMassStorageContentForCurrentRunCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCb))
                    {
                        uint8_t _mass_storage_id;
                        uint16_t _nbPhotos;
                        uint16_t _nbVideos;
                        uint16_t _nbRawPhotos;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mass_storage_id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbPhotos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbVideos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _nbRawPhotos = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCommonStateMassStorageContentForCurrentRunCallback) {
                                decoder->CommonCommonStateMassStorageContentForCurrentRunCallback (_mass_storage_id, _nbPhotos, _nbVideos, _nbRawPhotos, decoder->CommonCommonStateMassStorageContentForCurrentRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCb (_mass_storage_id, _nbPhotos, _nbVideos, _nbRawPhotos, ARCOMMANDS_Decoder_CommonCommonStateMassStorageContentForCurrentRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENTFORCURRENTRUN */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_COMMONSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_OVERHEAT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_SWITCHOFF:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonOverHeatSwitchOffCallback) || (!decoder && ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonOverHeatSwitchOffCallback) {
                                decoder->CommonOverHeatSwitchOffCallback (decoder->CommonOverHeatSwitchOffCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCb (ARCOMMANDS_Decoder_CommonOverHeatSwitchOffCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_SWITCHOFF */
                case ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_VENTILATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonOverHeatVentilateCallback) || (!decoder && ARCOMMANDS_Decoder_CommonOverHeatVentilateCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonOverHeatVentilateCallback) {
                                decoder->CommonOverHeatVentilateCallback (decoder->CommonOverHeatVentilateCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonOverHeatVentilateCb (ARCOMMANDS_Decoder_CommonOverHeatVentilateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_VENTILATE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_OVERHEAT */
            case ARCOMMANDS_ID_COMMON_CLASS_OVERHEATSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonOverHeatStateOverHeatChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonOverHeatStateOverHeatChangedCallback) {
                                decoder->CommonOverHeatStateOverHeatChangedCallback (decoder->CommonOverHeatStateOverHeatChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCb (ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATCHANGED */
                case ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATREGULATIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonOverHeatStateOverHeatRegulationChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCb))
                    {
                        uint8_t _regulationType;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _regulationType = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonOverHeatStateOverHeatRegulationChangedCallback) {
                                decoder->CommonOverHeatStateOverHeatRegulationChangedCallback (_regulationType, decoder->CommonOverHeatStateOverHeatRegulationChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCb (_regulationType, ARCOMMANDS_Decoder_CommonOverHeatStateOverHeatRegulationChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATREGULATIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_OVERHEATSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CONTROLLER:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CONTROLLER_CMD_ISPILOTING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonControllerIsPilotingCallback) || (!decoder && ARCOMMANDS_Decoder_CommonControllerIsPilotingCb))
                    {
                        uint8_t _piloting;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _piloting = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonControllerIsPilotingCallback) {
                                decoder->CommonControllerIsPilotingCallback (_piloting, decoder->CommonControllerIsPilotingCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonControllerIsPilotingCb (_piloting, ARCOMMANDS_Decoder_CommonControllerIsPilotingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CONTROLLER_CMD_ISPILOTING */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CONTROLLER */
            case ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_WIFISETTINGS_CMD_OUTDOORSETTING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonWifiSettingsOutdoorSettingCallback) || (!decoder && ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCb))
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonWifiSettingsOutdoorSettingCallback) {
                                decoder->CommonWifiSettingsOutdoorSettingCallback (_outdoor, decoder->CommonWifiSettingsOutdoorSettingCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCb (_outdoor, ARCOMMANDS_Decoder_CommonWifiSettingsOutdoorSettingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_WIFISETTINGS_CMD_OUTDOORSETTING */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGS */
            case ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_WIFISETTINGSSTATE_CMD_OUTDOORSETTINGSCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonWifiSettingsStateOutdoorSettingsChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCb))
                    {
                        uint8_t _outdoor;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _outdoor = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonWifiSettingsStateOutdoorSettingsChangedCallback) {
                                decoder->CommonWifiSettingsStateOutdoorSettingsChangedCallback (_outdoor, decoder->CommonWifiSettingsStateOutdoorSettingsChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCb (_outdoor, ARCOMMANDS_Decoder_CommonWifiSettingsStateOutdoorSettingsChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_WIFISETTINGSSTATE_CMD_OUTDOORSETTINGSCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_MAVLINK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_START:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonMavlinkStartCallback) || (!decoder && ARCOMMANDS_Decoder_CommonMavlinkStartCb))
                    {
                        char * _filepath = NULL;
                        eARCOMMANDS_COMMON_MAVLINK_START_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _filepath = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_COMMON_MAVLINK_START_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonMavlinkStartCallback) {
                                decoder->CommonMavlinkStartCallback (_filepath, _type, decoder->CommonMavlinkStartCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonMavlinkStartCb (_filepath, _type, ARCOMMANDS_Decoder_CommonMavlinkStartCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_START */
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_PAUSE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonMavlinkPauseCallback) || (!decoder && ARCOMMANDS_Decoder_CommonMavlinkPauseCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonMavlinkPauseCallback) {
                                decoder->CommonMavlinkPauseCallback (decoder->CommonMavlinkPauseCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonMavlinkPauseCb (ARCOMMANDS_Decoder_CommonMavlinkPauseCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_PAUSE */
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_STOP:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonMavlinkStopCallback) || (!decoder && ARCOMMANDS_Decoder_CommonMavlinkStopCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonMavlinkStopCallback) {
                                decoder->CommonMavlinkStopCallback (decoder->CommonMavlinkStopCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonMavlinkStopCb (ARCOMMANDS_Decoder_CommonMavlinkStopCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_STOP */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_MAVLINK */
            case ARCOMMANDS_ID_COMMON_CLASS_MAVLINKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKFILEPLAYINGSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonMavlinkStateMavlinkFilePlayingStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCb))
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE _state;
                        char * _filepath = NULL;
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _filepath = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonMavlinkStateMavlinkFilePlayingStateChangedCallback) {
                                decoder->CommonMavlinkStateMavlinkFilePlayingStateChangedCallback (_state, _filepath, _type, decoder->CommonMavlinkStateMavlinkFilePlayingStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCb (_state, _filepath, _type, ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkFilePlayingStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKFILEPLAYINGSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKPLAYERRORSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonMavlinkStateMavlinkPlayErrorStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCb))
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonMavlinkStateMavlinkPlayErrorStateChangedCallback) {
                                decoder->CommonMavlinkStateMavlinkPlayErrorStateChangedCallback (_error, decoder->CommonMavlinkStateMavlinkPlayErrorStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCb (_error, ARCOMMANDS_Decoder_CommonMavlinkStateMavlinkPlayErrorStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKPLAYERRORSTATECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_MAVLINKSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CALIBRATION:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_MAGNETOCALIBRATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCalibrationMagnetoCalibrationCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCb))
                    {
                        uint8_t _calibrate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _calibrate = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCalibrationMagnetoCalibrationCallback) {
                                decoder->CommonCalibrationMagnetoCalibrationCallback (_calibrate, decoder->CommonCalibrationMagnetoCalibrationCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCb (_calibrate, ARCOMMANDS_Decoder_CommonCalibrationMagnetoCalibrationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_MAGNETOCALIBRATION */
                case ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_PITOTCALIBRATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCalibrationPitotCalibrationCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCb))
                    {
                        uint8_t _calibrate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _calibrate = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCalibrationPitotCalibrationCallback) {
                                decoder->CommonCalibrationPitotCalibrationCallback (_calibrate, decoder->CommonCalibrationPitotCalibrationCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCb (_calibrate, ARCOMMANDS_Decoder_CommonCalibrationPitotCalibrationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_PITOTCALIBRATION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CALIBRATION */
            case ARCOMMANDS_ID_COMMON_CLASS_CALIBRATIONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCalibrationStateMagnetoCalibrationStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCb))
                    {
                        uint8_t _xAxisCalibration;
                        uint8_t _yAxisCalibration;
                        uint8_t _zAxisCalibration;
                        uint8_t _calibrationFailed;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _xAxisCalibration = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _yAxisCalibration = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _zAxisCalibration = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _calibrationFailed = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCalibrationStateMagnetoCalibrationStateChangedCallback) {
                                decoder->CommonCalibrationStateMagnetoCalibrationStateChangedCallback (_xAxisCalibration, _yAxisCalibration, _zAxisCalibration, _calibrationFailed, decoder->CommonCalibrationStateMagnetoCalibrationStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCb (_xAxisCalibration, _yAxisCalibration, _zAxisCalibration, _calibrationFailed, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONREQUIREDSTATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCalibrationStateMagnetoCalibrationRequiredStateCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCb))
                    {
                        uint8_t _required;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _required = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCalibrationStateMagnetoCalibrationRequiredStateCallback) {
                                decoder->CommonCalibrationStateMagnetoCalibrationRequiredStateCallback (_required, decoder->CommonCalibrationStateMagnetoCalibrationRequiredStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCb (_required, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationRequiredStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONREQUIREDSTATE */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb))
                    {
                        eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS _axis;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback) {
                                decoder->CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback (_axis, decoder->CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb (_axis, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTARTEDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCalibrationStateMagnetoCalibrationStartedChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCb))
                    {
                        uint8_t _started;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _started = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCalibrationStateMagnetoCalibrationStartedChangedCallback) {
                                decoder->CommonCalibrationStateMagnetoCalibrationStartedChangedCallback (_started, decoder->CommonCalibrationStateMagnetoCalibrationStartedChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCb (_started, ARCOMMANDS_Decoder_CommonCalibrationStateMagnetoCalibrationStartedChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTARTEDCHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_PITOTCALIBRATIONSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCalibrationStatePitotCalibrationStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCb))
                    {
                        eARCOMMANDS_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_STATE _state;
                        uint8_t _lastError;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _lastError = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCalibrationStatePitotCalibrationStateChangedCallback) {
                                decoder->CommonCalibrationStatePitotCalibrationStateChangedCallback (_state, _lastError, decoder->CommonCalibrationStatePitotCalibrationStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCb (_state, _lastError, ARCOMMANDS_Decoder_CommonCalibrationStatePitotCalibrationStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_PITOTCALIBRATIONSTATECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CALIBRATIONSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CAMERASETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CAMERASETTINGSSTATE_CMD_CAMERASETTINGSCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonCameraSettingsStateCameraSettingsChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCb))
                    {
                        float _fov;
                        float _panMax;
                        float _panMin;
                        float _tiltMax;
                        float _tiltMin;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _fov = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _panMax = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _panMin = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _tiltMax = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _tiltMin = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonCameraSettingsStateCameraSettingsChangedCallback) {
                                decoder->CommonCameraSettingsStateCameraSettingsChangedCallback (_fov, _panMax, _panMin, _tiltMax, _tiltMin, decoder->CommonCameraSettingsStateCameraSettingsChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCb (_fov, _panMax, _panMin, _tiltMax, _tiltMin, ARCOMMANDS_Decoder_CommonCameraSettingsStateCameraSettingsChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CAMERASETTINGSSTATE_CMD_CAMERASETTINGSCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CAMERASETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_GPS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_GPS_CMD_CONTROLLERPOSITIONFORRUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonGPSControllerPositionForRunCallback) || (!decoder && ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCb))
                    {
                        double _latitude;
                        double _longitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonGPSControllerPositionForRunCallback) {
                                decoder->CommonGPSControllerPositionForRunCallback (_latitude, _longitude, decoder->CommonGPSControllerPositionForRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCb (_latitude, _longitude, ARCOMMANDS_Decoder_CommonGPSControllerPositionForRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_GPS_CMD_CONTROLLERPOSITIONFORRUN */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_GPS */
            case ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_AVAILABILITYSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonFlightPlanStateAvailabilityStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCb))
                    {
                        uint8_t _AvailabilityState;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _AvailabilityState = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonFlightPlanStateAvailabilityStateChangedCallback) {
                                decoder->CommonFlightPlanStateAvailabilityStateChangedCallback (_AvailabilityState, decoder->CommonFlightPlanStateAvailabilityStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCb (_AvailabilityState, ARCOMMANDS_Decoder_CommonFlightPlanStateAvailabilityStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_AVAILABILITYSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_COMPONENTSTATELISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonFlightPlanStateComponentStateListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCb))
                    {
                        eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT _component;
                        uint8_t _State;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _component = (eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _State = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonFlightPlanStateComponentStateListChangedCallback) {
                                decoder->CommonFlightPlanStateComponentStateListChangedCallback (_component, _State, decoder->CommonFlightPlanStateComponentStateListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCb (_component, _State, ARCOMMANDS_Decoder_CommonFlightPlanStateComponentStateListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_COMPONENTSTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_LOCKSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonFlightPlanStateLockStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCb))
                    {
                        uint8_t _LockState;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _LockState = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonFlightPlanStateLockStateChangedCallback) {
                                decoder->CommonFlightPlanStateLockStateChangedCallback (_LockState, decoder->CommonFlightPlanStateLockStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCb (_LockState, ARCOMMANDS_Decoder_CommonFlightPlanStateLockStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_LOCKSTATECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_STARTINGERROREVENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonFlightPlanEventStartingErrorEventCallback) || (!decoder && ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonFlightPlanEventStartingErrorEventCallback) {
                                decoder->CommonFlightPlanEventStartingErrorEventCallback (decoder->CommonFlightPlanEventStartingErrorEventCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCb (ARCOMMANDS_Decoder_CommonFlightPlanEventStartingErrorEventCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_STARTINGERROREVENT */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_SPEEDBRIDLEEVENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonFlightPlanEventSpeedBridleEventCallback) || (!decoder && ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonFlightPlanEventSpeedBridleEventCallback) {
                                decoder->CommonFlightPlanEventSpeedBridleEventCallback (decoder->CommonFlightPlanEventSpeedBridleEventCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCb (ARCOMMANDS_Decoder_CommonFlightPlanEventSpeedBridleEventCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_SPEEDBRIDLEEVENT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANEVENT */
            case ARCOMMANDS_ID_COMMON_CLASS_ARLIBSVERSIONSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_CONTROLLERLIBARCOMMANDSVERSION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonARLibsVersionsStateControllerLibARCommandsVersionCallback) || (!decoder && ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCb))
                    {
                        char * _version = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _version = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonARLibsVersionsStateControllerLibARCommandsVersionCallback) {
                                decoder->CommonARLibsVersionsStateControllerLibARCommandsVersionCallback (_version, decoder->CommonARLibsVersionsStateControllerLibARCommandsVersionCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCb (_version, ARCOMMANDS_Decoder_CommonARLibsVersionsStateControllerLibARCommandsVersionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_CONTROLLERLIBARCOMMANDSVERSION */
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_SKYCONTROLLERLIBARCOMMANDSVERSION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback) || (!decoder && ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb))
                    {
                        char * _version = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _version = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback) {
                                decoder->CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCallback (_version, decoder->CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb (_version, ARCOMMANDS_Decoder_CommonARLibsVersionsStateSkyControllerLibARCommandsVersionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_SKYCONTROLLERLIBARCOMMANDSVERSION */
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_DEVICELIBARCOMMANDSVERSION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback) || (!decoder && ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCb))
                    {
                        char * _version = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _version = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback) {
                                decoder->CommonARLibsVersionsStateDeviceLibARCommandsVersionCallback (_version, decoder->CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCb (_version, ARCOMMANDS_Decoder_CommonARLibsVersionsStateDeviceLibARCommandsVersionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_DEVICELIBARCOMMANDSVERSION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ARLIBSVERSIONSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_AUDIO:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_AUDIO_CMD_CONTROLLERREADYFORSTREAMING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAudioControllerReadyForStreamingCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCb))
                    {
                        uint8_t _ready;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ready = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAudioControllerReadyForStreamingCallback) {
                                decoder->CommonAudioControllerReadyForStreamingCallback (_ready, decoder->CommonAudioControllerReadyForStreamingCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCb (_ready, ARCOMMANDS_Decoder_CommonAudioControllerReadyForStreamingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_AUDIO_CMD_CONTROLLERREADYFORSTREAMING */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_AUDIO */
            case ARCOMMANDS_ID_COMMON_CLASS_AUDIOSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_AUDIOSTATE_CMD_AUDIOSTREAMINGRUNNING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAudioStateAudioStreamingRunningCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCb))
                    {
                        uint8_t _running;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _running = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAudioStateAudioStreamingRunningCallback) {
                                decoder->CommonAudioStateAudioStreamingRunningCallback (_running, decoder->CommonAudioStateAudioStreamingRunningCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCb (_running, ARCOMMANDS_Decoder_CommonAudioStateAudioStreamingRunningCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_AUDIOSTATE_CMD_AUDIOSTREAMINGRUNNING */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_AUDIOSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_HEADLIGHTS_CMD_INTENSITY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonHeadlightsIntensityCallback) || (!decoder && ARCOMMANDS_Decoder_CommonHeadlightsIntensityCb))
                    {
                        uint8_t _left;
                        uint8_t _right;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _left = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _right = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonHeadlightsIntensityCallback) {
                                decoder->CommonHeadlightsIntensityCallback (_left, _right, decoder->CommonHeadlightsIntensityCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonHeadlightsIntensityCb (_left, _right, ARCOMMANDS_Decoder_CommonHeadlightsIntensityCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_HEADLIGHTS_CMD_INTENSITY */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTS */
            case ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_HEADLIGHTSSTATE_CMD_INTENSITYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonHeadlightsStateIntensityChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCb))
                    {
                        uint8_t _left;
                        uint8_t _right;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _left = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _right = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonHeadlightsStateIntensityChangedCallback) {
                                decoder->CommonHeadlightsStateIntensityChangedCallback (_left, _right, decoder->CommonHeadlightsStateIntensityChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCb (_left, _right, ARCOMMANDS_Decoder_CommonHeadlightsStateIntensityChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_HEADLIGHTSSTATE_CMD_INTENSITYCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STARTANIMATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAnimationsStartAnimationCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCb))
                    {
                        eARCOMMANDS_COMMON_ANIMATIONS_STARTANIMATION_ANIM _anim;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _anim = (eARCOMMANDS_COMMON_ANIMATIONS_STARTANIMATION_ANIM)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAnimationsStartAnimationCallback) {
                                decoder->CommonAnimationsStartAnimationCallback (_anim, decoder->CommonAnimationsStartAnimationCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCb (_anim, ARCOMMANDS_Decoder_CommonAnimationsStartAnimationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STARTANIMATION */
                case ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPANIMATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAnimationsStopAnimationCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCb))
                    {
                        eARCOMMANDS_COMMON_ANIMATIONS_STOPANIMATION_ANIM _anim;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _anim = (eARCOMMANDS_COMMON_ANIMATIONS_STOPANIMATION_ANIM)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAnimationsStopAnimationCallback) {
                                decoder->CommonAnimationsStopAnimationCallback (_anim, decoder->CommonAnimationsStopAnimationCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCb (_anim, ARCOMMANDS_Decoder_CommonAnimationsStopAnimationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPANIMATION */
                case ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPALLANIMATIONS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAnimationsStopAllAnimationsCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAnimationsStopAllAnimationsCallback) {
                                decoder->CommonAnimationsStopAllAnimationsCallback (decoder->CommonAnimationsStopAllAnimationsCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCb (ARCOMMANDS_Decoder_CommonAnimationsStopAllAnimationsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPALLANIMATIONS */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ANIMATIONSSTATE_CMD_LIST:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAnimationsStateListCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAnimationsStateListCb))
                    {
                        eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ANIM _anim;
                        eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_STATE _state;
                        eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _anim = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ANIM)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAnimationsStateListCallback) {
                                decoder->CommonAnimationsStateListCallback (_anim, _state, _error, decoder->CommonAnimationsStateListCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAnimationsStateListCb (_anim, _state, _error, ARCOMMANDS_Decoder_CommonAnimationsStateListCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONSSTATE_CMD_LIST */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_ACCESSORY:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ACCESSORY_CMD_CONFIG:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAccessoryConfigCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAccessoryConfigCb))
                    {
                        eARCOMMANDS_COMMON_ACCESSORY_CONFIG_ACCESSORY _accessory;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _accessory = (eARCOMMANDS_COMMON_ACCESSORY_CONFIG_ACCESSORY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAccessoryConfigCallback) {
                                decoder->CommonAccessoryConfigCallback (_accessory, decoder->CommonAccessoryConfigCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAccessoryConfigCb (_accessory, ARCOMMANDS_Decoder_CommonAccessoryConfigCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORY_CMD_CONFIG */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ACCESSORY */
            case ARCOMMANDS_ID_COMMON_CLASS_ACCESSORYSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_SUPPORTEDACCESSORIESLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAccessoryStateSupportedAccessoriesListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCb))
                    {
                        eARCOMMANDS_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY _accessory;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _accessory = (eARCOMMANDS_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAccessoryStateSupportedAccessoriesListChangedCallback) {
                                decoder->CommonAccessoryStateSupportedAccessoriesListChangedCallback (_accessory, decoder->CommonAccessoryStateSupportedAccessoriesListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCb (_accessory, ARCOMMANDS_Decoder_CommonAccessoryStateSupportedAccessoriesListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_SUPPORTEDACCESSORIESLISTCHANGED */
                case ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAccessoryStateAccessoryConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCb))
                    {
                        eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY _newAccessory;
                        eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _newAccessory = (eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAccessoryStateAccessoryConfigChangedCallback) {
                                decoder->CommonAccessoryStateAccessoryConfigChangedCallback (_newAccessory, _error, decoder->CommonAccessoryStateAccessoryConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCb (_newAccessory, _error, ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGCHANGED */
                case ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGMODIFICATIONENABLED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonAccessoryStateAccessoryConfigModificationEnabledCallback) || (!decoder && ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCb))
                    {
                        uint8_t _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonAccessoryStateAccessoryConfigModificationEnabledCallback) {
                                decoder->CommonAccessoryStateAccessoryConfigModificationEnabledCallback (_enabled, decoder->CommonAccessoryStateAccessoryConfigModificationEnabledCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCb (_enabled, ARCOMMANDS_Decoder_CommonAccessoryStateAccessoryConfigModificationEnabledCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGMODIFICATIONENABLED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ACCESSORYSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CHARGER:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CHARGER_CMD_SETMAXCHARGERATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonChargerSetMaxChargeRateCallback) || (!decoder && ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCb))
                    {
                        eARCOMMANDS_COMMON_CHARGER_SETMAXCHARGERATE_RATE _rate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rate = (eARCOMMANDS_COMMON_CHARGER_SETMAXCHARGERATE_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonChargerSetMaxChargeRateCallback) {
                                decoder->CommonChargerSetMaxChargeRateCallback (_rate, decoder->CommonChargerSetMaxChargeRateCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCb (_rate, ARCOMMANDS_Decoder_CommonChargerSetMaxChargeRateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGER_CMD_SETMAXCHARGERATE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CHARGER */
            case ARCOMMANDS_ID_COMMON_CLASS_CHARGERSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_MAXCHARGERATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonChargerStateMaxChargeRateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCb))
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE _rate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rate = (eARCOMMANDS_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonChargerStateMaxChargeRateChangedCallback) {
                                decoder->CommonChargerStateMaxChargeRateChangedCallback (_rate, decoder->CommonChargerStateMaxChargeRateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCb (_rate, ARCOMMANDS_Decoder_CommonChargerStateMaxChargeRateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_MAXCHARGERATECHANGED */
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CURRENTCHARGESTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonChargerStateCurrentChargeStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCb))
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS _status;
                        eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE _phase;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _status = (eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _phase = (eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonChargerStateCurrentChargeStateChangedCallback) {
                                decoder->CommonChargerStateCurrentChargeStateChangedCallback (_status, _phase, decoder->CommonChargerStateCurrentChargeStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCb (_status, _phase, ARCOMMANDS_Decoder_CommonChargerStateCurrentChargeStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CURRENTCHARGESTATECHANGED */
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_LASTCHARGERATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonChargerStateLastChargeRateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCb))
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE _rate;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rate = (eARCOMMANDS_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonChargerStateLastChargeRateChangedCallback) {
                                decoder->CommonChargerStateLastChargeRateChangedCallback (_rate, decoder->CommonChargerStateLastChargeRateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCb (_rate, ARCOMMANDS_Decoder_CommonChargerStateLastChargeRateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_LASTCHARGERATECHANGED */
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CHARGINGINFO:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonChargerStateChargingInfoCallback) || (!decoder && ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCb))
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE _phase;
                        eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_RATE _rate;
                        uint8_t _intensity;
                        uint8_t _fullChargingTime;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _phase = (eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rate = (eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _intensity = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _fullChargingTime = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonChargerStateChargingInfoCallback) {
                                decoder->CommonChargerStateChargingInfoCallback (_phase, _rate, _intensity, _fullChargingTime, decoder->CommonChargerStateChargingInfoCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCb (_phase, _rate, _intensity, _fullChargingTime, ARCOMMANDS_Decoder_CommonChargerStateChargingInfoCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CHARGINGINFO */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CHARGERSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_RUNSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_RUNSTATE_CMD_RUNIDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->CommonRunStateRunIdChangedCallback) || (!decoder && ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCb))
                    {
                        char * _runId = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _runId = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->CommonRunStateRunIdChangedCallback) {
                                decoder->CommonRunStateRunIdChangedCallback (_runId, decoder->CommonRunStateRunIdChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCb (_runId, ARCOMMANDS_Decoder_CommonRunStateRunIdChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_COMMON_RUNSTATE_CMD_RUNIDCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_RUNSTATE */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_COMMON */
        case ARCOMMANDS_ID_FEATURE_CONTROLLER_INFO:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_CONTROLLER_INFO_CMD_GPS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ControllerInfoGpsCallback) || (!decoder && ARCOMMANDS_Decoder_ControllerInfoGpsCb))
                    {
                        double _latitude;
                        double _longitude;
                        float _altitude;
                        float _horizontal_accuracy;
                        float _vertical_accuracy;
                        float _north_speed;
                        float _east_speed;
                        float _down_speed;
                        double _timestamp;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal_accuracy = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_accuracy = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _north_speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _east_speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _down_speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _timestamp = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ControllerInfoGpsCallback) {
                                decoder->ControllerInfoGpsCallback (_latitude, _longitude, _altitude, _horizontal_accuracy, _vertical_accuracy, _north_speed, _east_speed, _down_speed, _timestamp, decoder->ControllerInfoGpsCustom);
                            } else {
                                ARCOMMANDS_Decoder_ControllerInfoGpsCb (_latitude, _longitude, _altitude, _horizontal_accuracy, _vertical_accuracy, _north_speed, _east_speed, _down_speed, _timestamp, ARCOMMANDS_Decoder_ControllerInfoGpsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_CONTROLLER_INFO_RUNSTATE_CMD_GPS */
                case ARCOMMANDS_ID_CONTROLLER_INFO_CMD_BAROMETER:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ControllerInfoBarometerCallback) || (!decoder && ARCOMMANDS_Decoder_ControllerInfoBarometerCb))
                    {
                        float _pressure;
                        double _timestamp;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pressure = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _timestamp = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ControllerInfoBarometerCallback) {
                                decoder->ControllerInfoBarometerCallback (_pressure, _timestamp, decoder->ControllerInfoBarometerCustom);
                            } else {
                                ARCOMMANDS_Decoder_ControllerInfoBarometerCb (_pressure, _timestamp, ARCOMMANDS_Decoder_ControllerInfoBarometerCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_CONTROLLER_INFO_RUNSTATE_CMD_BAROMETER */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_CONTROLLER_INFO */
        case ARCOMMANDS_ID_FEATURE_DEBUG:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_DEBUG_CMD_GET_ALL_SETTINGS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DebugGetAllSettingsCallback) || (!decoder && ARCOMMANDS_Decoder_DebugGetAllSettingsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DebugGetAllSettingsCallback) {
                                decoder->DebugGetAllSettingsCallback (decoder->DebugGetAllSettingsCustom);
                            } else {
                                ARCOMMANDS_Decoder_DebugGetAllSettingsCb (ARCOMMANDS_Decoder_DebugGetAllSettingsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DEBUG_RUNSTATE_CMD_GET_ALL_SETTINGS */
                case ARCOMMANDS_ID_DEBUG_CMD_SET_SETTING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DebugSetSettingCallback) || (!decoder && ARCOMMANDS_Decoder_DebugSetSettingCb))
                    {
                        uint16_t _id;
                        char * _value = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DebugSetSettingCallback) {
                                decoder->DebugSetSettingCallback (_id, _value, decoder->DebugSetSettingCustom);
                            } else {
                                ARCOMMANDS_Decoder_DebugSetSettingCb (_id, _value, ARCOMMANDS_Decoder_DebugSetSettingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DEBUG_RUNSTATE_CMD_SET_SETTING */
                case ARCOMMANDS_ID_DEBUG_CMD_SETTINGS_INFO:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DebugSettingsInfoCallback) || (!decoder && ARCOMMANDS_Decoder_DebugSettingsInfoCb))
                    {
                        uint8_t _listFlags;
                        uint16_t _id;
                        char * _label = NULL;
                        eARCOMMANDS_DEBUG_SETTING_TYPE _type;
                        eARCOMMANDS_DEBUG_SETTING_MODE _mode;
                        char * _range_min = NULL;
                        char * _range_max = NULL;
                        char * _range_step = NULL;
                        char * _value = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _listFlags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _label = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_DEBUG_SETTING_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_DEBUG_SETTING_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _range_min = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _range_max = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _range_step = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DebugSettingsInfoCallback) {
                                decoder->DebugSettingsInfoCallback (_listFlags, _id, _label, _type, _mode, _range_min, _range_max, _range_step, _value, decoder->DebugSettingsInfoCustom);
                            } else {
                                ARCOMMANDS_Decoder_DebugSettingsInfoCb (_listFlags, _id, _label, _type, _mode, _range_min, _range_max, _range_step, _value, ARCOMMANDS_Decoder_DebugSettingsInfoCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DEBUG_RUNSTATE_CMD_SETTINGS_INFO */
                case ARCOMMANDS_ID_DEBUG_CMD_SETTINGS_LIST:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DebugSettingsListCallback) || (!decoder && ARCOMMANDS_Decoder_DebugSettingsListCb))
                    {
                        uint16_t _id;
                        char * _value = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DebugSettingsListCallback) {
                                decoder->DebugSettingsListCallback (_id, _value, decoder->DebugSettingsListCustom);
                            } else {
                                ARCOMMANDS_Decoder_DebugSettingsListCb (_id, _value, ARCOMMANDS_Decoder_DebugSettingsListCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DEBUG_RUNSTATE_CMD_SETTINGS_LIST */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_DEBUG */
        case ARCOMMANDS_ID_FEATURE_DRONE_MANAGER:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_DISCOVER_DRONES:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DroneManagerDiscoverDronesCallback) || (!decoder && ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DroneManagerDiscoverDronesCallback) {
                                decoder->DroneManagerDiscoverDronesCallback (decoder->DroneManagerDiscoverDronesCustom);
                            } else {
                                ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCb (ARCOMMANDS_Decoder_DroneManagerDiscoverDronesCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_RUNSTATE_CMD_DISCOVER_DRONES */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DroneManagerConnectCallback) || (!decoder && ARCOMMANDS_Decoder_DroneManagerConnectCb))
                    {
                        char * _serial = NULL;
                        char * _key = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serial = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DroneManagerConnectCallback) {
                                decoder->DroneManagerConnectCallback (_serial, _key, decoder->DroneManagerConnectCustom);
                            } else {
                                ARCOMMANDS_Decoder_DroneManagerConnectCb (_serial, _key, ARCOMMANDS_Decoder_DroneManagerConnectCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_RUNSTATE_CMD_CONNECT */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_FORGET:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DroneManagerForgetCallback) || (!decoder && ARCOMMANDS_Decoder_DroneManagerForgetCb))
                    {
                        char * _serial = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serial = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DroneManagerForgetCallback) {
                                decoder->DroneManagerForgetCallback (_serial, decoder->DroneManagerForgetCustom);
                            } else {
                                ARCOMMANDS_Decoder_DroneManagerForgetCb (_serial, ARCOMMANDS_Decoder_DroneManagerForgetCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_RUNSTATE_CMD_FORGET */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_DRONE_LIST_ITEM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DroneManagerDroneListItemCallback) || (!decoder && ARCOMMANDS_Decoder_DroneManagerDroneListItemCb))
                    {
                        char * _serial = NULL;
                        uint16_t _model;
                        char * _name = NULL;
                        uint8_t _connection_order;
                        uint8_t _active;
                        uint8_t _visible;
                        eARCOMMANDS_DRONE_MANAGER_SECURITY _security;
                        uint8_t _has_saved_key;
                        int8_t _rssi;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serial = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _model = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _connection_order = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _active = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _visible = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _security = (eARCOMMANDS_DRONE_MANAGER_SECURITY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _has_saved_key = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DroneManagerDroneListItemCallback) {
                                decoder->DroneManagerDroneListItemCallback (_serial, _model, _name, _connection_order, _active, _visible, _security, _has_saved_key, _rssi, _list_flags, decoder->DroneManagerDroneListItemCustom);
                            } else {
                                ARCOMMANDS_Decoder_DroneManagerDroneListItemCb (_serial, _model, _name, _connection_order, _active, _visible, _security, _has_saved_key, _rssi, _list_flags, ARCOMMANDS_Decoder_DroneManagerDroneListItemCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_RUNSTATE_CMD_DRONE_LIST_ITEM */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECTION_STATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DroneManagerConnectionStateCallback) || (!decoder && ARCOMMANDS_Decoder_DroneManagerConnectionStateCb))
                    {
                        eARCOMMANDS_DRONE_MANAGER_CONNECTION_STATE _state;
                        char * _serial = NULL;
                        uint16_t _model;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_DRONE_MANAGER_CONNECTION_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serial = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _model = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DroneManagerConnectionStateCallback) {
                                decoder->DroneManagerConnectionStateCallback (_state, _serial, _model, _name, decoder->DroneManagerConnectionStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_DroneManagerConnectionStateCb (_state, _serial, _model, _name, ARCOMMANDS_Decoder_DroneManagerConnectionStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_RUNSTATE_CMD_CONNECTION_STATE */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_AUTHENTICATION_FAILED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DroneManagerAuthenticationFailedCallback) || (!decoder && ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCb))
                    {
                        char * _serial = NULL;
                        uint16_t _model;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serial = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _model = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DroneManagerAuthenticationFailedCallback) {
                                decoder->DroneManagerAuthenticationFailedCallback (_serial, _model, _name, decoder->DroneManagerAuthenticationFailedCustom);
                            } else {
                                ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCb (_serial, _model, _name, ARCOMMANDS_Decoder_DroneManagerAuthenticationFailedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_RUNSTATE_CMD_AUTHENTICATION_FAILED */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECTION_REFUSED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->DroneManagerConnectionRefusedCallback) || (!decoder && ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCb))
                    {
                        char * _serial = NULL;
                        uint16_t _model;
                        char * _name = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _serial = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _model = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _name = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->DroneManagerConnectionRefusedCallback) {
                                decoder->DroneManagerConnectionRefusedCallback (_serial, _model, _name, decoder->DroneManagerConnectionRefusedCustom);
                            } else {
                                ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCb (_serial, _model, _name, ARCOMMANDS_Decoder_DroneManagerConnectionRefusedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_RUNSTATE_CMD_CONNECTION_REFUSED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_DRONE_MANAGER */
        case ARCOMMANDS_ID_FEATURE_MAPPER:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperGrabCallback) || (!decoder && ARCOMMANDS_Decoder_MapperGrabCb))
                    {
                        uint32_t _buttons;
                        uint32_t _axes;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _buttons = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axes = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperGrabCallback) {
                                decoder->MapperGrabCallback (_buttons, _axes, decoder->MapperGrabCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperGrabCb (_buttons, _axes, ARCOMMANDS_Decoder_MapperGrabCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_GRAB */
                case ARCOMMANDS_ID_MAPPER_CMD_MAP_BUTTON_ACTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperMapButtonActionCallback) || (!decoder && ARCOMMANDS_Decoder_MapperMapButtonActionCb))
                    {
                        uint16_t _product;
                        eARCOMMANDS_MAPPER_BUTTON_ACTION _action;
                        uint32_t _buttons;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _action = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _buttons = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperMapButtonActionCallback) {
                                decoder->MapperMapButtonActionCallback (_product, _action, _buttons, decoder->MapperMapButtonActionCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperMapButtonActionCb (_product, _action, _buttons, ARCOMMANDS_Decoder_MapperMapButtonActionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_MAP_BUTTON_ACTION */
                case ARCOMMANDS_ID_MAPPER_CMD_MAP_AXIS_ACTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperMapAxisActionCallback) || (!decoder && ARCOMMANDS_Decoder_MapperMapAxisActionCb))
                    {
                        uint16_t _product;
                        eARCOMMANDS_MAPPER_AXIS_ACTION _action;
                        int32_t _axis;
                        uint32_t _buttons;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _action = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _buttons = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperMapAxisActionCallback) {
                                decoder->MapperMapAxisActionCallback (_product, _action, _axis, _buttons, decoder->MapperMapAxisActionCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperMapAxisActionCb (_product, _action, _axis, _buttons, ARCOMMANDS_Decoder_MapperMapAxisActionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_MAP_AXIS_ACTION */
                case ARCOMMANDS_ID_MAPPER_CMD_RESET_MAPPING:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperResetMappingCallback) || (!decoder && ARCOMMANDS_Decoder_MapperResetMappingCb))
                    {
                        uint16_t _product;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperResetMappingCallback) {
                                decoder->MapperResetMappingCallback (_product, decoder->MapperResetMappingCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperResetMappingCb (_product, ARCOMMANDS_Decoder_MapperResetMappingCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_RESET_MAPPING */
                case ARCOMMANDS_ID_MAPPER_CMD_SET_EXPO:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperSetExpoCallback) || (!decoder && ARCOMMANDS_Decoder_MapperSetExpoCb))
                    {
                        uint16_t _product;
                        int32_t _axis;
                        eARCOMMANDS_MAPPER_EXPO_TYPE _expo;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _expo = (eARCOMMANDS_MAPPER_EXPO_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperSetExpoCallback) {
                                decoder->MapperSetExpoCallback (_product, _axis, _expo, decoder->MapperSetExpoCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperSetExpoCb (_product, _axis, _expo, ARCOMMANDS_Decoder_MapperSetExpoCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_SET_EXPO */
                case ARCOMMANDS_ID_MAPPER_CMD_SET_INVERTED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperSetInvertedCallback) || (!decoder && ARCOMMANDS_Decoder_MapperSetInvertedCb))
                    {
                        uint16_t _product;
                        int32_t _axis;
                        uint8_t _inverted;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _inverted = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperSetInvertedCallback) {
                                decoder->MapperSetInvertedCallback (_product, _axis, _inverted, decoder->MapperSetInvertedCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperSetInvertedCb (_product, _axis, _inverted, ARCOMMANDS_Decoder_MapperSetInvertedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_SET_INVERTED */
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB_STATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperGrabStateCallback) || (!decoder && ARCOMMANDS_Decoder_MapperGrabStateCb))
                    {
                        uint32_t _buttons;
                        uint32_t _axes;
                        uint32_t _buttons_state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _buttons = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axes = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _buttons_state = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperGrabStateCallback) {
                                decoder->MapperGrabStateCallback (_buttons, _axes, _buttons_state, decoder->MapperGrabStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperGrabStateCb (_buttons, _axes, _buttons_state, ARCOMMANDS_Decoder_MapperGrabStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_GRAB_STATE */
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB_BUTTON_EVENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperGrabButtonEventCallback) || (!decoder && ARCOMMANDS_Decoder_MapperGrabButtonEventCb))
                    {
                        uint32_t _button;
                        eARCOMMANDS_MAPPER_BUTTON_EVENT _event;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _button = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_MAPPER_BUTTON_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperGrabButtonEventCallback) {
                                decoder->MapperGrabButtonEventCallback (_button, _event, decoder->MapperGrabButtonEventCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperGrabButtonEventCb (_button, _event, ARCOMMANDS_Decoder_MapperGrabButtonEventCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_GRAB_BUTTON_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB_AXIS_EVENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperGrabAxisEventCallback) || (!decoder && ARCOMMANDS_Decoder_MapperGrabAxisEventCb))
                    {
                        uint32_t _axis;
                        int8_t _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperGrabAxisEventCallback) {
                                decoder->MapperGrabAxisEventCallback (_axis, _value, decoder->MapperGrabAxisEventCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperGrabAxisEventCb (_axis, _value, ARCOMMANDS_Decoder_MapperGrabAxisEventCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_GRAB_AXIS_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_BUTTON_MAPPING_ITEM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperButtonMappingItemCallback) || (!decoder && ARCOMMANDS_Decoder_MapperButtonMappingItemCb))
                    {
                        uint32_t _uid;
                        uint16_t _product;
                        eARCOMMANDS_MAPPER_BUTTON_ACTION _action;
                        uint32_t _buttons;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uid = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _action = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _buttons = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperButtonMappingItemCallback) {
                                decoder->MapperButtonMappingItemCallback (_uid, _product, _action, _buttons, _list_flags, decoder->MapperButtonMappingItemCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperButtonMappingItemCb (_uid, _product, _action, _buttons, _list_flags, ARCOMMANDS_Decoder_MapperButtonMappingItemCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_BUTTON_MAPPING_ITEM */
                case ARCOMMANDS_ID_MAPPER_CMD_AXIS_MAPPING_ITEM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperAxisMappingItemCallback) || (!decoder && ARCOMMANDS_Decoder_MapperAxisMappingItemCb))
                    {
                        uint32_t _uid;
                        uint16_t _product;
                        eARCOMMANDS_MAPPER_AXIS_ACTION _action;
                        int32_t _axis;
                        uint32_t _buttons;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uid = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _action = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _buttons = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperAxisMappingItemCallback) {
                                decoder->MapperAxisMappingItemCallback (_uid, _product, _action, _axis, _buttons, _list_flags, decoder->MapperAxisMappingItemCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperAxisMappingItemCb (_uid, _product, _action, _axis, _buttons, _list_flags, ARCOMMANDS_Decoder_MapperAxisMappingItemCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_AXIS_MAPPING_ITEM */
                case ARCOMMANDS_ID_MAPPER_CMD_APPLICATION_AXIS_EVENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperApplicationAxisEventCallback) || (!decoder && ARCOMMANDS_Decoder_MapperApplicationAxisEventCb))
                    {
                        eARCOMMANDS_MAPPER_AXIS_ACTION _action;
                        int8_t _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _action = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperApplicationAxisEventCallback) {
                                decoder->MapperApplicationAxisEventCallback (_action, _value, decoder->MapperApplicationAxisEventCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperApplicationAxisEventCb (_action, _value, ARCOMMANDS_Decoder_MapperApplicationAxisEventCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_APPLICATION_AXIS_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_APPLICATION_BUTTON_EVENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperApplicationButtonEventCallback) || (!decoder && ARCOMMANDS_Decoder_MapperApplicationButtonEventCb))
                    {
                        eARCOMMANDS_MAPPER_BUTTON_ACTION _action;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _action = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperApplicationButtonEventCallback) {
                                decoder->MapperApplicationButtonEventCallback (_action, decoder->MapperApplicationButtonEventCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperApplicationButtonEventCb (_action, ARCOMMANDS_Decoder_MapperApplicationButtonEventCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_APPLICATION_BUTTON_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_EXPO_MAP_ITEM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperExpoMapItemCallback) || (!decoder && ARCOMMANDS_Decoder_MapperExpoMapItemCb))
                    {
                        uint32_t _uid;
                        uint16_t _product;
                        int32_t _axis;
                        eARCOMMANDS_MAPPER_EXPO_TYPE _expo;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uid = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _expo = (eARCOMMANDS_MAPPER_EXPO_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperExpoMapItemCallback) {
                                decoder->MapperExpoMapItemCallback (_uid, _product, _axis, _expo, _list_flags, decoder->MapperExpoMapItemCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperExpoMapItemCb (_uid, _product, _axis, _expo, _list_flags, ARCOMMANDS_Decoder_MapperExpoMapItemCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_EXPO_MAP_ITEM */
                case ARCOMMANDS_ID_MAPPER_CMD_INVERTED_MAP_ITEM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->MapperInvertedMapItemCallback) || (!decoder && ARCOMMANDS_Decoder_MapperInvertedMapItemCb))
                    {
                        uint32_t _uid;
                        uint16_t _product;
                        int32_t _axis;
                        uint8_t _inverted;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _uid = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _product = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _axis =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _inverted = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->MapperInvertedMapItemCallback) {
                                decoder->MapperInvertedMapItemCallback (_uid, _product, _axis, _inverted, _list_flags, decoder->MapperInvertedMapItemCustom);
                            } else {
                                ARCOMMANDS_Decoder_MapperInvertedMapItemCb (_uid, _product, _axis, _inverted, _list_flags, ARCOMMANDS_Decoder_MapperInvertedMapItemCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_MAPPER_VIDEOSETTINGSSTATE_CMD_INVERTED_MAP_ITEM */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_MAPPER */
        case ARCOMMANDS_ID_FEATURE_POWERUP:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTING_CMD_PCMD:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingPCMDCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingPCMDCb))
                    {
                        uint8_t _flag;
                        uint8_t _throttle;
                        int8_t _roll;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _flag = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _throttle = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _roll =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingPCMDCallback) {
                                decoder->PowerupPilotingPCMDCallback (_flag, _throttle, _roll, decoder->PowerupPilotingPCMDCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingPCMDCb (_flag, _throttle, _roll, ARCOMMANDS_Decoder_PowerupPilotingPCMDCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_POWERUP_PILOTING_CMD_USERTAKEOFF:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingUserTakeOffCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCb))
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingUserTakeOffCallback) {
                                decoder->PowerupPilotingUserTakeOffCallback (_state, decoder->PowerupPilotingUserTakeOffCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCb (_state, ARCOMMANDS_Decoder_PowerupPilotingUserTakeOffCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTING_CMD_USERTAKEOFF */
                case ARCOMMANDS_ID_POWERUP_PILOTING_CMD_MOTORMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingMotorModeCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingMotorModeCb))
                    {
                        eARCOMMANDS_POWERUP_PILOTING_MOTORMODE_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_POWERUP_PILOTING_MOTORMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingMotorModeCallback) {
                                decoder->PowerupPilotingMotorModeCallback (_mode, decoder->PowerupPilotingMotorModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingMotorModeCb (_mode, ARCOMMANDS_Decoder_PowerupPilotingMotorModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTING_CMD_MOTORMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTING */
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingStateAlertStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCb))
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingStateAlertStateChangedCallback) {
                                decoder->PowerupPilotingStateAlertStateChangedCallback (_state, decoder->PowerupPilotingStateAlertStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCb (_state, ARCOMMANDS_Decoder_PowerupPilotingStateAlertStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_FLYINGSTATECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingStateFlyingStateChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCb))
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingStateFlyingStateChangedCallback) {
                                decoder->PowerupPilotingStateFlyingStateChangedCallback (_state, decoder->PowerupPilotingStateFlyingStateChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCb (_state, ARCOMMANDS_Decoder_PowerupPilotingStateFlyingStateChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_FLYINGSTATECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_MOTORMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingStateMotorModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCb))
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSTATE_MOTORMODECHANGED_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_POWERUP_PILOTINGSTATE_MOTORMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingStateMotorModeChangedCallback) {
                                decoder->PowerupPilotingStateMotorModeChangedCallback (_mode, decoder->PowerupPilotingStateMotorModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCb (_mode, ARCOMMANDS_Decoder_PowerupPilotingStateMotorModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_MOTORMODECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ATTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingStateAttitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCb))
                    {
                        float _roll;
                        float _pitch;
                        float _yaw;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _roll = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pitch = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _yaw = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingStateAttitudeChangedCallback) {
                                decoder->PowerupPilotingStateAttitudeChangedCallback (_roll, _pitch, _yaw, decoder->PowerupPilotingStateAttitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCb (_roll, _pitch, _yaw, ARCOMMANDS_Decoder_PowerupPilotingStateAttitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ATTITUDECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALTITUDECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingStateAltitudeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCb))
                    {
                        float _altitude;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingStateAltitudeChangedCallback) {
                                decoder->PowerupPilotingStateAltitudeChangedCallback (_altitude, decoder->PowerupPilotingStateAltitudeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCb (_altitude, ARCOMMANDS_Decoder_PowerupPilotingStateAltitudeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALTITUDECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGS_CMD_SET:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingSettingsSetCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCb))
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSETTINGS_SET_SETTING _setting;
                        float _value;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _setting = (eARCOMMANDS_POWERUP_PILOTINGSETTINGS_SET_SETTING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingSettingsSetCallback) {
                                decoder->PowerupPilotingSettingsSetCallback (_setting, _value, decoder->PowerupPilotingSettingsSetCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCb (_setting, _value, ARCOMMANDS_Decoder_PowerupPilotingSettingsSetCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGS_CMD_SET */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGS */
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGSSTATE_CMD_SETTINGCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupPilotingSettingsStateSettingChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCb))
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_SETTING _setting;
                        float _current;
                        float _min;
                        float _max;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _setting = (eARCOMMANDS_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_SETTING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _current = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _min = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _max = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupPilotingSettingsStateSettingChangedCallback) {
                                decoder->PowerupPilotingSettingsStateSettingChangedCallback (_setting, _current, _min, _max, _list_flags, decoder->PowerupPilotingSettingsStateSettingChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCb (_setting, _current, _min, _max, _list_flags, ARCOMMANDS_Decoder_PowerupPilotingSettingsStateSettingChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGSSTATE_CMD_SETTINGCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGSSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_PICTUREV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaRecordPictureV2Callback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Cb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaRecordPictureV2Callback) {
                                decoder->PowerupMediaRecordPictureV2Callback (decoder->PowerupMediaRecordPictureV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Cb (ARCOMMANDS_Decoder_PowerupMediaRecordPictureV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_PICTUREV2 */
                case ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_VIDEOV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaRecordVideoV2Callback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Cb))
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORD_VIDEOV2_RECORD _record;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _record = (eARCOMMANDS_POWERUP_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaRecordVideoV2Callback) {
                                decoder->PowerupMediaRecordVideoV2Callback (_record, decoder->PowerupMediaRecordVideoV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Cb (_record, ARCOMMANDS_Decoder_PowerupMediaRecordVideoV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_VIDEOV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaRecordStatePictureStateChangedV2Callback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Cb))
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaRecordStatePictureStateChangedV2Callback) {
                                decoder->PowerupMediaRecordStatePictureStateChangedV2Callback (_state, _error, decoder->PowerupMediaRecordStatePictureStateChangedV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_PowerupMediaRecordStatePictureStateChangedV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaRecordStateVideoStateChangedV2Callback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Cb))
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state;
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaRecordStateVideoStateChangedV2Callback) {
                                decoder->PowerupMediaRecordStateVideoStateChangedV2Callback (_state, _error, decoder->PowerupMediaRecordStateVideoStateChangedV2Custom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Cb (_state, _error, ARCOMMANDS_Decoder_PowerupMediaRecordStateVideoStateChangedV2Custom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2 */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaRecordEventPictureEventChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCb))
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaRecordEventPictureEventChangedCallback) {
                                decoder->PowerupMediaRecordEventPictureEventChangedCallback (_event, _error, decoder->PowerupMediaRecordEventPictureEventChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCb (_event, _error, ARCOMMANDS_Decoder_PowerupMediaRecordEventPictureEventChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaRecordEventVideoEventChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCb))
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event;
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _event = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _error = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaRecordEventVideoEventChangedCallback) {
                                decoder->PowerupMediaRecordEventVideoEventChangedCallback (_event, _error, decoder->PowerupMediaRecordEventVideoEventChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCb (_event, _error, ARCOMMANDS_Decoder_PowerupMediaRecordEventVideoEventChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORKSETTINGS_CMD_WIFISELECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkSettingsWifiSelectionCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCb))
                    {
                        eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_TYPE _type;
                        eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkSettingsWifiSelectionCallback) {
                                decoder->PowerupNetworkSettingsWifiSelectionCallback (_type, _band, _channel, decoder->PowerupNetworkSettingsWifiSelectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCb (_type, _band, _channel, ARCOMMANDS_Decoder_PowerupNetworkSettingsWifiSelectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSETTINGS_CMD_WIFISELECTION */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGS */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkSettingsStateWifiSelectionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCb))
                    {
                        eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type;
                        eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkSettingsStateWifiSelectionChangedCallback) {
                                decoder->PowerupNetworkSettingsStateWifiSelectionChangedCallback (_type, _band, _channel, decoder->PowerupNetworkSettingsStateWifiSelectionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCb (_type, _band, _channel, ARCOMMANDS_Decoder_PowerupNetworkSettingsStateWifiSelectionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGSSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFISCAN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkWifiScanCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkWifiScanCb))
                    {
                        eARCOMMANDS_POWERUP_NETWORK_WIFISCAN_BAND _band;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_POWERUP_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkWifiScanCallback) {
                                decoder->PowerupNetworkWifiScanCallback (_band, decoder->PowerupNetworkWifiScanCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkWifiScanCb (_band, ARCOMMANDS_Decoder_PowerupNetworkWifiScanCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFISCAN */
                case ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFIAUTHCHANNEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkWifiAuthChannelCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkWifiAuthChannelCallback) {
                                decoder->PowerupNetworkWifiAuthChannelCallback (decoder->PowerupNetworkWifiAuthChannelCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCb (ARCOMMANDS_Decoder_PowerupNetworkWifiAuthChannelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFIAUTHCHANNEL */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORK */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFISCANLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkStateWifiScanListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCb))
                    {
                        char * _ssid = NULL;
                        int16_t _rssi;
                        eARCOMMANDS_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkStateWifiScanListChangedCallback) {
                                decoder->PowerupNetworkStateWifiScanListChangedCallback (_ssid, _rssi, _band, _channel, decoder->PowerupNetworkStateWifiScanListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCb (_ssid, _rssi, _band, _channel, ARCOMMANDS_Decoder_PowerupNetworkStateWifiScanListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFISCANLISTCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFISCANCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkStateAllWifiScanChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkStateAllWifiScanChangedCallback) {
                                decoder->PowerupNetworkStateAllWifiScanChangedCallback (decoder->PowerupNetworkStateAllWifiScanChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCb (ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiScanChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFISCANCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkStateWifiAuthChannelListChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCb))
                    {
                        eARCOMMANDS_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band;
                        uint8_t _channel;
                        uint8_t _in_or_out;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _in_or_out = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkStateWifiAuthChannelListChangedCallback) {
                                decoder->PowerupNetworkStateWifiAuthChannelListChangedCallback (_band, _channel, _in_or_out, decoder->PowerupNetworkStateWifiAuthChannelListChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCb (_band, _channel, _in_or_out, ARCOMMANDS_Decoder_PowerupNetworkStateWifiAuthChannelListChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkStateAllWifiAuthChannelChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkStateAllWifiAuthChannelChangedCallback) {
                                decoder->PowerupNetworkStateAllWifiAuthChannelChangedCallback (decoder->PowerupNetworkStateAllWifiAuthChannelChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCb (ARCOMMANDS_Decoder_PowerupNetworkStateAllWifiAuthChannelChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_LINKQUALITYCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupNetworkStateLinkQualityChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCb))
                    {
                        uint8_t _quality;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _quality = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupNetworkStateLinkQualityChangedCallback) {
                                decoder->PowerupNetworkStateLinkQualityChangedCallback (_quality, decoder->PowerupNetworkStateLinkQualityChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCb (_quality, ARCOMMANDS_Decoder_PowerupNetworkStateLinkQualityChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_LINKQUALITYCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIASTREAMING_CMD_VIDEOENABLE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaStreamingVideoEnableCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCb))
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaStreamingVideoEnableCallback) {
                                decoder->PowerupMediaStreamingVideoEnableCallback (_enable, decoder->PowerupMediaStreamingVideoEnableCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCb (_enable, ARCOMMANDS_Decoder_PowerupMediaStreamingVideoEnableCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIASTREAMING_CMD_VIDEOENABLE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMING */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupMediaStreamingStateVideoEnableChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCb))
                    {
                        eARCOMMANDS_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = (eARCOMMANDS_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupMediaStreamingStateVideoEnableChangedCallback) {
                                decoder->PowerupMediaStreamingStateVideoEnableChangedCallback (_enabled, decoder->PowerupMediaStreamingStateVideoEnableChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCb (_enabled, ARCOMMANDS_Decoder_PowerupMediaStreamingStateVideoEnableChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMINGSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_AUTORECORD:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupVideoSettingsAutorecordCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCb))
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupVideoSettingsAutorecordCallback) {
                                decoder->PowerupVideoSettingsAutorecordCallback (_enable, decoder->PowerupVideoSettingsAutorecordCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCb (_enable, ARCOMMANDS_Decoder_PowerupVideoSettingsAutorecordCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_AUTORECORD */
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_VIDEOMODE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupVideoSettingsVideoModeCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCb))
                    {
                        eARCOMMANDS_POWERUP_VIDEOSETTINGS_VIDEOMODE_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_POWERUP_VIDEOSETTINGS_VIDEOMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupVideoSettingsVideoModeCallback) {
                                decoder->PowerupVideoSettingsVideoModeCallback (_mode, decoder->PowerupVideoSettingsVideoModeCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCb (_mode, ARCOMMANDS_Decoder_PowerupVideoSettingsVideoModeCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_VIDEOMODE */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGS */
            case ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_AUTORECORDCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupVideoSettingsStateAutorecordChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCb))
                    {
                        uint8_t _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupVideoSettingsStateAutorecordChangedCallback) {
                                decoder->PowerupVideoSettingsStateAutorecordChangedCallback (_enabled, decoder->PowerupVideoSettingsStateAutorecordChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCb (_enabled, ARCOMMANDS_Decoder_PowerupVideoSettingsStateAutorecordChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_AUTORECORDCHANGED */
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_VIDEOMODECHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupVideoSettingsStateVideoModeChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCb))
                    {
                        eARCOMMANDS_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED_MODE _mode;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _mode = (eARCOMMANDS_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupVideoSettingsStateVideoModeChangedCallback) {
                                decoder->PowerupVideoSettingsStateVideoModeChangedCallback (_mode, decoder->PowerupVideoSettingsStateVideoModeChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCb (_mode, ARCOMMANDS_Decoder_PowerupVideoSettingsStateVideoModeChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_VIDEOMODECHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGSSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_SOUNDS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_SOUNDS_CMD_BUZZ:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupSoundsBuzzCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupSoundsBuzzCb))
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupSoundsBuzzCallback) {
                                decoder->PowerupSoundsBuzzCallback (_enable, decoder->PowerupSoundsBuzzCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupSoundsBuzzCb (_enable, ARCOMMANDS_Decoder_PowerupSoundsBuzzCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_SOUNDS_CMD_BUZZ */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_SOUNDS */
            case ARCOMMANDS_ID_POWERUP_CLASS_SOUNDSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_SOUNDSSTATE_CMD_BUZZCHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->PowerupSoundsStateBuzzChangedCallback) || (!decoder && ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCb))
                    {
                        uint8_t _enabled;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enabled = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->PowerupSoundsStateBuzzChangedCallback) {
                                decoder->PowerupSoundsStateBuzzChangedCallback (_enabled, decoder->PowerupSoundsStateBuzzChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCb (_enabled, ARCOMMANDS_Decoder_PowerupSoundsStateBuzzChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_POWERUP_SOUNDSSTATE_CMD_BUZZCHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_SOUNDSSTATE */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_POWERUP */
        case ARCOMMANDS_ID_FEATURE_PRO:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_PRO_CLASS_PRO:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_PRO_PRO_CMD_BOUGHTFEATURES:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ProProBoughtFeaturesCallback) || (!decoder && ARCOMMANDS_Decoder_ProProBoughtFeaturesCb))
                    {
                        uint64_t _features;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _features = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ProProBoughtFeaturesCallback) {
                                decoder->ProProBoughtFeaturesCallback (_features, decoder->ProProBoughtFeaturesCustom);
                            } else {
                                ARCOMMANDS_Decoder_ProProBoughtFeaturesCb (_features, ARCOMMANDS_Decoder_ProProBoughtFeaturesCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_PRO_PRO_CMD_BOUGHTFEATURES */
                case ARCOMMANDS_ID_PRO_PRO_CMD_RESPONSE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ProProResponseCallback) || (!decoder && ARCOMMANDS_Decoder_ProProResponseCb))
                    {
                        uint8_t _listFlags;
                        char * _signedChallenge = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _listFlags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _signedChallenge = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ProProResponseCallback) {
                                decoder->ProProResponseCallback (_listFlags, _signedChallenge, decoder->ProProResponseCustom);
                            } else {
                                ARCOMMANDS_Decoder_ProProResponseCb (_listFlags, _signedChallenge, ARCOMMANDS_Decoder_ProProResponseCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_PRO_PRO_CMD_RESPONSE */
                case ARCOMMANDS_ID_PRO_PRO_CMD_ACTIVATEFEATURES:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ProProActivateFeaturesCallback) || (!decoder && ARCOMMANDS_Decoder_ProProActivateFeaturesCb))
                    {
                        uint64_t _features;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _features = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ProProActivateFeaturesCallback) {
                                decoder->ProProActivateFeaturesCallback (_features, decoder->ProProActivateFeaturesCustom);
                            } else {
                                ARCOMMANDS_Decoder_ProProActivateFeaturesCb (_features, ARCOMMANDS_Decoder_ProProActivateFeaturesCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_PRO_PRO_CMD_ACTIVATEFEATURES */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_PRO_CLASS_PRO */
            case ARCOMMANDS_ID_PRO_CLASS_PROSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_PRO_PROSTATE_CMD_SUPPORTEDFEATURES:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ProProStateSupportedFeaturesCallback) || (!decoder && ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCb))
                    {
                        eARCOMMANDS_PRO_PROSTATE_SUPPORTEDFEATURES_STATUS _status;
                        uint64_t _features;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _status = (eARCOMMANDS_PRO_PROSTATE_SUPPORTEDFEATURES_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _features = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ProProStateSupportedFeaturesCallback) {
                                decoder->ProProStateSupportedFeaturesCallback (_status, _features, decoder->ProProStateSupportedFeaturesCustom);
                            } else {
                                ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCb (_status, _features, ARCOMMANDS_Decoder_ProProStateSupportedFeaturesCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_PRO_PROSTATE_CMD_SUPPORTEDFEATURES */
                case ARCOMMANDS_ID_PRO_PROSTATE_CMD_FEATURESACTIVATED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ProProStateFeaturesActivatedCallback) || (!decoder && ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCb))
                    {
                        uint64_t _features;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _features = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ProProStateFeaturesActivatedCallback) {
                                decoder->ProProStateFeaturesActivatedCallback (_features, decoder->ProProStateFeaturesActivatedCustom);
                            } else {
                                ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCb (_features, ARCOMMANDS_Decoder_ProProStateFeaturesActivatedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_PRO_PROSTATE_CMD_FEATURESACTIVATED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_PRO_CLASS_PROSTATE */
            case ARCOMMANDS_ID_PRO_CLASS_PROEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_PRO_PROEVENT_CMD_CHALLENGEEVENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->ProProEventChallengeEventCallback) || (!decoder && ARCOMMANDS_Decoder_ProProEventChallengeEventCb))
                    {
                        char * _challenge = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _challenge = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->ProProEventChallengeEventCallback) {
                                decoder->ProProEventChallengeEventCallback (_challenge, decoder->ProProEventChallengeEventCustom);
                            } else {
                                ARCOMMANDS_Decoder_ProProEventChallengeEventCb (_challenge, ARCOMMANDS_Decoder_ProProEventChallengeEventCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_PRO_PROEVENT_CMD_CHALLENGEEVENT */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_PRO_CLASS_PROEVENT */
            default:
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_PRO */
        case ARCOMMANDS_ID_FEATURE_RC:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_RC_CMD_MONITOR_CHANNELS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcMonitorChannelsCallback) || (!decoder && ARCOMMANDS_Decoder_RcMonitorChannelsCb))
                    {
                        uint8_t _enable;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _enable = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcMonitorChannelsCallback) {
                                decoder->RcMonitorChannelsCallback (_enable, decoder->RcMonitorChannelsCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcMonitorChannelsCb (_enable, ARCOMMANDS_Decoder_RcMonitorChannelsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_MONITOR_CHANNELS */
                case ARCOMMANDS_ID_RC_CMD_START_CALIBRATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcStartCalibrationCallback) || (!decoder && ARCOMMANDS_Decoder_RcStartCalibrationCb))
                    {
                        eARCOMMANDS_RC_CALIBRATION_TYPE _type;
                        eARCOMMANDS_RC_CHANNEL_TYPE _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_RC_CALIBRATION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcStartCalibrationCallback) {
                                decoder->RcStartCalibrationCallback (_type, _channel, decoder->RcStartCalibrationCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcStartCalibrationCb (_type, _channel, ARCOMMANDS_Decoder_RcStartCalibrationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_START_CALIBRATION */
                case ARCOMMANDS_ID_RC_CMD_INVERT_CHANNEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcInvertChannelCallback) || (!decoder && ARCOMMANDS_Decoder_RcInvertChannelCb))
                    {
                        eARCOMMANDS_RC_CHANNEL_TYPE _channel;
                        uint8_t _flag;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _flag = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcInvertChannelCallback) {
                                decoder->RcInvertChannelCallback (_channel, _flag, decoder->RcInvertChannelCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcInvertChannelCb (_channel, _flag, ARCOMMANDS_Decoder_RcInvertChannelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_INVERT_CHANNEL */
                case ARCOMMANDS_ID_RC_CMD_ABORT_CALIBRATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcAbortCalibrationCallback) || (!decoder && ARCOMMANDS_Decoder_RcAbortCalibrationCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcAbortCalibrationCallback) {
                                decoder->RcAbortCalibrationCallback (decoder->RcAbortCalibrationCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcAbortCalibrationCb (ARCOMMANDS_Decoder_RcAbortCalibrationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_ABORT_CALIBRATION */
                case ARCOMMANDS_ID_RC_CMD_RESET_CALIBRATION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcResetCalibrationCallback) || (!decoder && ARCOMMANDS_Decoder_RcResetCalibrationCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcResetCalibrationCallback) {
                                decoder->RcResetCalibrationCallback (decoder->RcResetCalibrationCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcResetCalibrationCb (ARCOMMANDS_Decoder_RcResetCalibrationCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_RESET_CALIBRATION */
                case ARCOMMANDS_ID_RC_CMD_RECEIVER_STATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcReceiverStateCallback) || (!decoder && ARCOMMANDS_Decoder_RcReceiverStateCb))
                    {
                        eARCOMMANDS_RC_RECEIVER_STATE _state;
                        char * _protocol = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = (eARCOMMANDS_RC_RECEIVER_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _protocol = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcReceiverStateCallback) {
                                decoder->RcReceiverStateCallback (_state, _protocol, decoder->RcReceiverStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcReceiverStateCb (_state, _protocol, ARCOMMANDS_Decoder_RcReceiverStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_RECEIVER_STATE */
                case ARCOMMANDS_ID_RC_CMD_CHANNELS_MONITOR_STATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcChannelsMonitorStateCallback) || (!decoder && ARCOMMANDS_Decoder_RcChannelsMonitorStateCb))
                    {
                        uint8_t _state;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _state = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcChannelsMonitorStateCallback) {
                                decoder->RcChannelsMonitorStateCallback (_state, decoder->RcChannelsMonitorStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcChannelsMonitorStateCb (_state, ARCOMMANDS_Decoder_RcChannelsMonitorStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_CHANNELS_MONITOR_STATE */
                case ARCOMMANDS_ID_RC_CMD_CHANNEL_VALUE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcChannelValueCallback) || (!decoder && ARCOMMANDS_Decoder_RcChannelValueCb))
                    {
                        uint8_t _id;
                        eARCOMMANDS_RC_CHANNEL_TYPE _type;
                        int16_t _value;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _id = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _value =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcChannelValueCallback) {
                                decoder->RcChannelValueCallback (_id, _type, _value, _list_flags, decoder->RcChannelValueCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcChannelValueCb (_id, _type, _value, _list_flags, ARCOMMANDS_Decoder_RcChannelValueCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_CHANNEL_VALUE */
                case ARCOMMANDS_ID_RC_CMD_CALIBRATION_STATE:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcCalibrationStateCallback) || (!decoder && ARCOMMANDS_Decoder_RcCalibrationStateCb))
                    {
                        eARCOMMANDS_RC_CALIBRATION_TYPE _type;
                        eARCOMMANDS_RC_CHANNEL_TYPE _channel;
                        uint32_t _supported;
                        uint32_t _required;
                        uint32_t _calibrated;
                        uint8_t _neutral_calibrated;
                        uint32_t _inverted;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_RC_CALIBRATION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _supported = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _required = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _calibrated = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _neutral_calibrated = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _inverted = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcCalibrationStateCallback) {
                                decoder->RcCalibrationStateCallback (_type, _channel, _supported, _required, _calibrated, _neutral_calibrated, _inverted, decoder->RcCalibrationStateCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcCalibrationStateCb (_type, _channel, _supported, _required, _calibrated, _neutral_calibrated, _inverted, ARCOMMANDS_Decoder_RcCalibrationStateCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_CALIBRATION_STATE */
                case ARCOMMANDS_ID_RC_CMD_RECEIVER_QUALITY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->RcReceiverQualityCallback) || (!decoder && ARCOMMANDS_Decoder_RcReceiverQualityCb))
                    {
                        uint8_t _level;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _level = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->RcReceiverQualityCallback) {
                                decoder->RcReceiverQualityCallback (_level, decoder->RcReceiverQualityCustom);
                            } else {
                                ARCOMMANDS_Decoder_RcReceiverQualityCb (_level, ARCOMMANDS_Decoder_RcReceiverQualityCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_RC_PROEVENT_CMD_RECEIVER_QUALITY */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_RC */
        case ARCOMMANDS_ID_FEATURE_UNKNOWN_FEATURE_1:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_GEOGRAPHIC_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1GeographicRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCb))
                    {
                        uint8_t _start;
                        uint8_t _distance_is_default;
                        float _distance;
                        uint8_t _elevation_is_default;
                        float _elevation;
                        uint8_t _azimuth_is_default;
                        float _azimuth;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1GeographicRunCallback) {
                                decoder->UnknownFeature1GeographicRunCallback (_start, _distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, decoder->UnknownFeature1GeographicRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCb (_start, _distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, ARCOMMANDS_Decoder_UnknownFeature1GeographicRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_GEOGRAPHIC_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RELATIVE_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1RelativeRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCb))
                    {
                        uint8_t _start;
                        uint8_t _distance_is_default;
                        float _distance;
                        uint8_t _elevation_is_default;
                        float _elevation;
                        uint8_t _azimuth_is_default;
                        float _azimuth;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1RelativeRunCallback) {
                                decoder->UnknownFeature1RelativeRunCallback (_start, _distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, decoder->UnknownFeature1RelativeRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCb (_start, _distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, ARCOMMANDS_Decoder_UnknownFeature1RelativeRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_RELATIVE_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_LOOK_AT_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1LookAtRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCb))
                    {
                        uint8_t _start;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1LookAtRunCallback) {
                                decoder->UnknownFeature1LookAtRunCallback (_start, decoder->UnknownFeature1LookAtRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCb (_start, ARCOMMANDS_Decoder_UnknownFeature1LookAtRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_LOOK_AT_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SPIRAL_ANIM_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1SpiralAnimRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCb))
                    {
                        uint8_t _start;
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _revolution_nb_is_default;
                        float _revolution_number;
                        uint8_t _vertical_distance_is_default;
                        float _vertical_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _revolution_nb_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _revolution_number = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1SpiralAnimRunCallback) {
                                decoder->UnknownFeature1SpiralAnimRunCallback (_start, _speed_is_default, _speed, _revolution_nb_is_default, _revolution_number, _vertical_distance_is_default, _vertical_distance, decoder->UnknownFeature1SpiralAnimRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCb (_start, _speed_is_default, _speed, _revolution_nb_is_default, _revolution_number, _vertical_distance_is_default, _vertical_distance, ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_SPIRAL_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SWING_ANIM_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1SwingAnimRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCb))
                    {
                        uint8_t _start;
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _vertical_distance_is_default;
                        float _vertical_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1SwingAnimRunCallback) {
                                decoder->UnknownFeature1SwingAnimRunCallback (_start, _speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, decoder->UnknownFeature1SwingAnimRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCb (_start, _speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, ARCOMMANDS_Decoder_UnknownFeature1SwingAnimRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_SWING_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_BOOMERANG_ANIM_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1BoomerangAnimRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCb))
                    {
                        uint8_t _start;
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _distance_is_default;
                        float _distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1BoomerangAnimRunCallback) {
                                decoder->UnknownFeature1BoomerangAnimRunCallback (_start, _speed_is_default, _speed, _distance_is_default, _distance, decoder->UnknownFeature1BoomerangAnimRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCb (_start, _speed_is_default, _speed, _distance_is_default, _distance, ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_BOOMERANG_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_CANDLE_ANIM_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1CandleAnimRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCb))
                    {
                        uint8_t _start;
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _vertical_distance_is_default;
                        float _vertical_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1CandleAnimRunCallback) {
                                decoder->UnknownFeature1CandleAnimRunCallback (_start, _speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, decoder->UnknownFeature1CandleAnimRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCb (_start, _speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, ARCOMMANDS_Decoder_UnknownFeature1CandleAnimRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_CANDLE_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_DOLLY_SLIDE_ANIM_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1DollySlideAnimRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCb))
                    {
                        uint8_t _start;
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _angle_is_default;
                        float _angle;
                        uint8_t _horizontal_distance_is_default;
                        float _horizontal_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _start = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _angle_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _angle = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1DollySlideAnimRunCallback) {
                                decoder->UnknownFeature1DollySlideAnimRunCallback (_start, _speed_is_default, _speed, _angle_is_default, _angle, _horizontal_distance_is_default, _horizontal_distance, decoder->UnknownFeature1DollySlideAnimRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCb (_start, _speed_is_default, _speed, _angle_is_default, _angle, _horizontal_distance_is_default, _horizontal_distance, ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_DOLLY_SLIDE_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_FRAMING_POSITION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1UserFramingPositionCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCb))
                    {
                        int8_t _horizontal;
                        int8_t _vertical;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1UserFramingPositionCallback) {
                                decoder->UnknownFeature1UserFramingPositionCallback (_horizontal, _vertical, decoder->UnknownFeature1UserFramingPositionCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCb (_horizontal, _vertical, ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_USER_FRAMING_POSITION */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_GPS_DATA:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1UserGPSDataCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCb))
                    {
                        double _latitude;
                        double _longitude;
                        float _altitude;
                        float _horizontal_accuracy;
                        float _vertical_accuracy;
                        float _north_speed;
                        float _east_speed;
                        float _down_speed;
                        double _timestamp;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _latitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _longitude = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _altitude = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal_accuracy = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_accuracy = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _north_speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _east_speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _down_speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _timestamp = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1UserGPSDataCallback) {
                                decoder->UnknownFeature1UserGPSDataCallback (_latitude, _longitude, _altitude, _horizontal_accuracy, _vertical_accuracy, _north_speed, _east_speed, _down_speed, _timestamp, decoder->UnknownFeature1UserGPSDataCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCb (_latitude, _longitude, _altitude, _horizontal_accuracy, _vertical_accuracy, _north_speed, _east_speed, _down_speed, _timestamp, ARCOMMANDS_Decoder_UnknownFeature1UserGPSDataCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_USER_GPS_DATA */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_BARO_DATA:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1UserBaroDataCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCb))
                    {
                        float _pressure;
                        double _timestamp;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _pressure = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _timestamp = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1UserBaroDataCallback) {
                                decoder->UnknownFeature1UserBaroDataCallback (_pressure, _timestamp, decoder->UnknownFeature1UserBaroDataCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCb (_pressure, _timestamp, ARCOMMANDS_Decoder_UnknownFeature1UserBaroDataCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_USER_BARO_DATA */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_LYNX_DETECTION:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1LynxDetectionCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCb))
                    {
                        float _target_pan;
                        float _target_tilt;
                        float _change_of_scale;
                        uint8_t _confidence_index;
                        uint8_t _is_new_selection;
                        uint64_t _timestamp;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _target_pan = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _target_tilt = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _change_of_scale = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _confidence_index = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _is_new_selection = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _timestamp = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1LynxDetectionCallback) {
                                decoder->UnknownFeature1LynxDetectionCallback (_target_pan, _target_tilt, _change_of_scale, _confidence_index, _is_new_selection, _timestamp, decoder->UnknownFeature1LynxDetectionCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCb (_target_pan, _target_tilt, _change_of_scale, _confidence_index, _is_new_selection, _timestamp, ARCOMMANDS_Decoder_UnknownFeature1LynxDetectionCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_LYNX_DETECTION */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_AVAILABILITY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1AvailabilityCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCb))
                    {
                        eARCOMMANDS_UNKNOWN_FEATURE_1_TYPES_AVAILABLE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_UNKNOWN_FEATURE_1_TYPES_AVAILABLE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1AvailabilityCallback) {
                                decoder->UnknownFeature1AvailabilityCallback (_type, decoder->UnknownFeature1AvailabilityCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCb (_type, ARCOMMANDS_Decoder_UnknownFeature1AvailabilityCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_AVAILABILITY */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1RunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1RunCb))
                    {
                        eARCOMMANDS_UNKNOWN_FEATURE_1_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_UNKNOWN_FEATURE_1_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1RunCallback) {
                                decoder->UnknownFeature1RunCallback (_type, decoder->UnknownFeature1RunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1RunCb (_type, ARCOMMANDS_Decoder_UnknownFeature1RunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_GEOGRAPHIC_CONFIG_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1GeographicConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCb))
                    {
                        uint8_t _distance_is_default;
                        float _distance;
                        uint8_t _elevation_is_default;
                        float _elevation;
                        uint8_t _azimuth_is_default;
                        float _azimuth;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1GeographicConfigChangedCallback) {
                                decoder->UnknownFeature1GeographicConfigChangedCallback (_distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, decoder->UnknownFeature1GeographicConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCb (_distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, ARCOMMANDS_Decoder_UnknownFeature1GeographicConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_GEOGRAPHIC_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RELATIVE_CONFIG_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1RelativeConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCb))
                    {
                        uint8_t _distance_is_default;
                        float _distance;
                        uint8_t _elevation_is_default;
                        float _elevation;
                        uint8_t _azimuth_is_default;
                        float _azimuth;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _elevation = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _azimuth = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1RelativeConfigChangedCallback) {
                                decoder->UnknownFeature1RelativeConfigChangedCallback (_distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, decoder->UnknownFeature1RelativeConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCb (_distance_is_default, _distance, _elevation_is_default, _elevation, _azimuth_is_default, _azimuth, ARCOMMANDS_Decoder_UnknownFeature1RelativeConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_RELATIVE_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_ANIM_RUN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1AnimRunCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1AnimRunCb))
                    {
                        eARCOMMANDS_UNKNOWN_FEATURE_1_ANIM_TYPE _type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_UNKNOWN_FEATURE_1_ANIM_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1AnimRunCallback) {
                                decoder->UnknownFeature1AnimRunCallback (_type, decoder->UnknownFeature1AnimRunCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1AnimRunCb (_type, ARCOMMANDS_Decoder_UnknownFeature1AnimRunCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SPIRAL_ANIM_CONFIG_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1SpiralAnimConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCb))
                    {
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _revolution_nb_is_default;
                        float _revolution_nb;
                        uint8_t _vertical_distance_is_default;
                        float _vertical_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _revolution_nb_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _revolution_nb = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1SpiralAnimConfigChangedCallback) {
                                decoder->UnknownFeature1SpiralAnimConfigChangedCallback (_speed_is_default, _speed, _revolution_nb_is_default, _revolution_nb, _vertical_distance_is_default, _vertical_distance, decoder->UnknownFeature1SpiralAnimConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCb (_speed_is_default, _speed, _revolution_nb_is_default, _revolution_nb, _vertical_distance_is_default, _vertical_distance, ARCOMMANDS_Decoder_UnknownFeature1SpiralAnimConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_SPIRAL_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SWING_ANIM_CONFIG_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1SwingAnimConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCb))
                    {
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _vertical_distance_is_default;
                        float _vertical_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1SwingAnimConfigChangedCallback) {
                                decoder->UnknownFeature1SwingAnimConfigChangedCallback (_speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, decoder->UnknownFeature1SwingAnimConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCb (_speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, ARCOMMANDS_Decoder_UnknownFeature1SwingAnimConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_SWING_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_BOOMERANG_ANIM_CONFIG_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1BoomerangAnimConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCb))
                    {
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _distance_is_default;
                        float _distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1BoomerangAnimConfigChangedCallback) {
                                decoder->UnknownFeature1BoomerangAnimConfigChangedCallback (_speed_is_default, _speed, _distance_is_default, _distance, decoder->UnknownFeature1BoomerangAnimConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCb (_speed_is_default, _speed, _distance_is_default, _distance, ARCOMMANDS_Decoder_UnknownFeature1BoomerangAnimConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_BOOMERANG_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_CANDLE_ANIM_CONFIG_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1CandleAnimConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCb))
                    {
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _vertical_distance_is_default;
                        float _vertical_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1CandleAnimConfigChangedCallback) {
                                decoder->UnknownFeature1CandleAnimConfigChangedCallback (_speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, decoder->UnknownFeature1CandleAnimConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCb (_speed_is_default, _speed, _vertical_distance_is_default, _vertical_distance, ARCOMMANDS_Decoder_UnknownFeature1CandleAnimConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_CANDLE_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_DOLLY_SLIDE_ANIM_CONFIG_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1DollySlideAnimConfigChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCb))
                    {
                        uint8_t _speed_is_default;
                        float _speed;
                        uint8_t _angle_is_default;
                        float _angle;
                        uint8_t _horizontal_distance_is_default;
                        float _horizontal_distance;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _speed = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _angle_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _angle = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal_distance_is_default = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal_distance = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1DollySlideAnimConfigChangedCallback) {
                                decoder->UnknownFeature1DollySlideAnimConfigChangedCallback (_speed_is_default, _speed, _angle_is_default, _angle, _horizontal_distance_is_default, _horizontal_distance, decoder->UnknownFeature1DollySlideAnimConfigChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCb (_speed_is_default, _speed, _angle_is_default, _angle, _horizontal_distance_is_default, _horizontal_distance, ARCOMMANDS_Decoder_UnknownFeature1DollySlideAnimConfigChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_DOLLY_SLIDE_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_FRAMING_POSITION_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->UnknownFeature1UserFramingPositionChangedCallback) || (!decoder && ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCb))
                    {
                        int8_t _horizontal;
                        int8_t _vertical;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _horizontal =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _vertical =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->UnknownFeature1UserFramingPositionChangedCallback) {
                                decoder->UnknownFeature1UserFramingPositionChangedCallback (_horizontal, _vertical, decoder->UnknownFeature1UserFramingPositionChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCb (_horizontal, _vertical, ARCOMMANDS_Decoder_UnknownFeature1UserFramingPositionChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_FACTORY_CMD_USER_FRAMING_POSITION_CHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_UNKNOWN_FEATURE_1 */
        case ARCOMMANDS_ID_FEATURE_WIFI:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_WIFI_CMD_SCAN:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiScanCallback) || (!decoder && ARCOMMANDS_Decoder_WifiScanCb))
                    {
                        uint8_t _band;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiScanCallback) {
                                decoder->WifiScanCallback (_band, decoder->WifiScanCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiScanCb (_band, ARCOMMANDS_Decoder_WifiScanCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_SCAN */
                case ARCOMMANDS_ID_WIFI_CMD_UPDATE_AUTHORIZED_CHANNELS:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiUpdateAuthorizedChannelsCallback) || (!decoder && ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCb))
                    {
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiUpdateAuthorizedChannelsCallback) {
                                decoder->WifiUpdateAuthorizedChannelsCallback (decoder->WifiUpdateAuthorizedChannelsCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCb (ARCOMMANDS_Decoder_WifiUpdateAuthorizedChannelsCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_UPDATE_AUTHORIZED_CHANNELS */
                case ARCOMMANDS_ID_WIFI_CMD_SET_AP_CHANNEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiSetApChannelCallback) || (!decoder && ARCOMMANDS_Decoder_WifiSetApChannelCb))
                    {
                        eARCOMMANDS_WIFI_SELECTION_TYPE _type;
                        eARCOMMANDS_WIFI_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_WIFI_SELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiSetApChannelCallback) {
                                decoder->WifiSetApChannelCallback (_type, _band, _channel, decoder->WifiSetApChannelCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiSetApChannelCb (_type, _band, _channel, ARCOMMANDS_Decoder_WifiSetApChannelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_SET_AP_CHANNEL */
                case ARCOMMANDS_ID_WIFI_CMD_SET_SECURITY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiSetSecurityCallback) || (!decoder && ARCOMMANDS_Decoder_WifiSetSecurityCb))
                    {
                        eARCOMMANDS_WIFI_SECURITY_TYPE _type;
                        char * _key = NULL;
                        eARCOMMANDS_WIFI_SECURITY_KEY_TYPE _key_type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_WIFI_SECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key_type = (eARCOMMANDS_WIFI_SECURITY_KEY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiSetSecurityCallback) {
                                decoder->WifiSetSecurityCallback (_type, _key, _key_type, decoder->WifiSetSecurityCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiSetSecurityCb (_type, _key, _key_type, ARCOMMANDS_Decoder_WifiSetSecurityCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_SET_SECURITY */
                case ARCOMMANDS_ID_WIFI_CMD_SET_COUNTRY:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiSetCountryCallback) || (!decoder && ARCOMMANDS_Decoder_WifiSetCountryCb))
                    {
                        eARCOMMANDS_WIFI_COUNTRY_SELECTION _selection_mode;
                        char * _code = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _selection_mode = (eARCOMMANDS_WIFI_COUNTRY_SELECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _code = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiSetCountryCallback) {
                                decoder->WifiSetCountryCallback (_selection_mode, _code, decoder->WifiSetCountryCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiSetCountryCb (_selection_mode, _code, ARCOMMANDS_Decoder_WifiSetCountryCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_SET_COUNTRY */
                case ARCOMMANDS_ID_WIFI_CMD_SET_ENVIRONMENT:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiSetEnvironmentCallback) || (!decoder && ARCOMMANDS_Decoder_WifiSetEnvironmentCb))
                    {
                        eARCOMMANDS_WIFI_ENVIRONMENT _environment;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _environment = (eARCOMMANDS_WIFI_ENVIRONMENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiSetEnvironmentCallback) {
                                decoder->WifiSetEnvironmentCallback (_environment, decoder->WifiSetEnvironmentCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiSetEnvironmentCb (_environment, ARCOMMANDS_Decoder_WifiSetEnvironmentCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_SET_ENVIRONMENT */
                case ARCOMMANDS_ID_WIFI_CMD_SCANNED_ITEM:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiScannedItemCallback) || (!decoder && ARCOMMANDS_Decoder_WifiScannedItemCb))
                    {
                        char * _ssid = NULL;
                        int16_t _rssi;
                        eARCOMMANDS_WIFI_BAND _band;
                        uint8_t _channel;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _ssid = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiScannedItemCallback) {
                                decoder->WifiScannedItemCallback (_ssid, _rssi, _band, _channel, _list_flags, decoder->WifiScannedItemCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiScannedItemCb (_ssid, _rssi, _band, _channel, _list_flags, ARCOMMANDS_Decoder_WifiScannedItemCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_SCANNED_ITEM */
                case ARCOMMANDS_ID_WIFI_CMD_AUTHORIZED_CHANNEL:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiAuthorizedChannelCallback) || (!decoder && ARCOMMANDS_Decoder_WifiAuthorizedChannelCb))
                    {
                        eARCOMMANDS_WIFI_BAND _band;
                        uint8_t _channel;
                        uint8_t _environment;
                        uint8_t _list_flags;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _environment = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _list_flags = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiAuthorizedChannelCallback) {
                                decoder->WifiAuthorizedChannelCallback (_band, _channel, _environment, _list_flags, decoder->WifiAuthorizedChannelCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiAuthorizedChannelCb (_band, _channel, _environment, _list_flags, ARCOMMANDS_Decoder_WifiAuthorizedChannelCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_AUTHORIZED_CHANNEL */
                case ARCOMMANDS_ID_WIFI_CMD_AP_CHANNEL_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiApChannelChangedCallback) || (!decoder && ARCOMMANDS_Decoder_WifiApChannelChangedCb))
                    {
                        eARCOMMANDS_WIFI_SELECTION_TYPE _type;
                        eARCOMMANDS_WIFI_BAND _band;
                        uint8_t _channel;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _type = (eARCOMMANDS_WIFI_SELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _band = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _channel = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiApChannelChangedCallback) {
                                decoder->WifiApChannelChangedCallback (_type, _band, _channel, decoder->WifiApChannelChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiApChannelChangedCb (_type, _band, _channel, ARCOMMANDS_Decoder_WifiApChannelChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_AP_CHANNEL_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_SECURITY_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiSecurityChangedCallback) || (!decoder && ARCOMMANDS_Decoder_WifiSecurityChangedCb))
                    {
                        char * _key = NULL;
                        eARCOMMANDS_WIFI_SECURITY_TYPE _key_type;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _key_type = (eARCOMMANDS_WIFI_SECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiSecurityChangedCallback) {
                                decoder->WifiSecurityChangedCallback (_key, _key_type, decoder->WifiSecurityChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiSecurityChangedCb (_key, _key_type, ARCOMMANDS_Decoder_WifiSecurityChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_SECURITY_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_COUNTRY_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiCountryChangedCallback) || (!decoder && ARCOMMANDS_Decoder_WifiCountryChangedCb))
                    {
                        eARCOMMANDS_WIFI_COUNTRY_SELECTION _selection_mode;
                        char * _code = NULL;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _selection_mode = (eARCOMMANDS_WIFI_COUNTRY_SELECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _code = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiCountryChangedCallback) {
                                decoder->WifiCountryChangedCallback (_selection_mode, _code, decoder->WifiCountryChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiCountryChangedCb (_selection_mode, _code, ARCOMMANDS_Decoder_WifiCountryChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_COUNTRY_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_ENVIRONMENT_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiEnvironmentChangedCallback) || (!decoder && ARCOMMANDS_Decoder_WifiEnvironmentChangedCb))
                    {
                        eARCOMMANDS_WIFI_ENVIRONMENT _environment;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _environment = (eARCOMMANDS_WIFI_ENVIRONMENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiEnvironmentChangedCallback) {
                                decoder->WifiEnvironmentChangedCallback (_environment, decoder->WifiEnvironmentChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiEnvironmentChangedCb (_environment, ARCOMMANDS_Decoder_WifiEnvironmentChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_ENVIRONMENT_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_RSSI_CHANGED:
                {
                    if (decoder) {
                        ARSAL_Mutex_Lock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Lock (&ARCOMMANDS_Decoder_Mutex);
                    }
                    if ((decoder && decoder->WifiRssiChangedCallback) || (!decoder && ARCOMMANDS_Decoder_WifiRssiChangedCb))
                    {
                        int16_t _rssi;
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            _rssi =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                            if (error == 1)
                            {
                                retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                            } // No else --> Do not modify retVal if read went fine
                        } // No else --> Processing block
                        if (retVal == ARCOMMANDS_DECODER_OK)
                        {
                            if (decoder && decoder->WifiRssiChangedCallback) {
                                decoder->WifiRssiChangedCallback (_rssi, decoder->WifiRssiChangedCustom);
                            } else {
                                ARCOMMANDS_Decoder_WifiRssiChangedCb (_rssi, ARCOMMANDS_Decoder_WifiRssiChangedCustom);
                            }
                        } // No else --> Processing block
                    }
                    else
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NO_CALLBACK;
                    }
                    if (decoder) {
                        ARSAL_Mutex_Unlock (&decoder->mutex);
                    } else {
                        ARSAL_Mutex_Unlock (&ARCOMMANDS_Decoder_Mutex);
                    }
                }
                break; /* ARCOMMANDS_ID_WIFI_FACTORY_CMD_RSSI_CHANGED */
                default:
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_WIFI */
        default:
            retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            break;
        }
    } // No else --> Processing block
    return retVal;
}

eARCOMMANDS_DECODER_ERROR
ARCOMMANDS_Decoder_DescribeBuffer (uint8_t *buffer, int32_t buffLen, char *resString, int32_t stringLen)
{
    eARCOMMANDS_ID_FEATURE commandFetaure = -1;
    int commandClass = -1;
    int commandId = -1;
    int32_t offset = 0;
    int32_t error = 0;
    int strOffset = 0;
    eARCOMMANDS_DECODER_ERROR retVal = ARCOMMANDS_DECODER_OK;
    if ((NULL == buffer) || (NULL == resString))
    {
        retVal = ARCOMMANDS_DECODER_ERROR;
    } // No else --> Arg check

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        if (ARCOMMANDS_Decoder_Init () == 0)
        {
            retVal = ARCOMMANDS_DECODER_ERROR;
        } // No else --> keep retVal to OK if init went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandFetaure = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandClass = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        commandId = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
        if (error == 1)
        {
            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
        } // No else --> Do not modify retVal if read went fine
    } // No else --> Processing block

    if (retVal == ARCOMMANDS_DECODER_OK && stringLen > 0)
    {
        resString[0] = '\0';
    }
    else
    {
        retVal = ARCOMMANDS_DECODER_ERROR;
    }

    if (retVal == ARCOMMANDS_DECODER_OK)
    {
        switch (commandFetaure)
        {
        case ARCOMMANDS_ID_FEATURE_GENERIC:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_GENERIC_CMD_DEFAULT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("generic.default:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_GENERIC_CMD_DEFAULT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("generic.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("generic.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_GENERIC */
        case ARCOMMANDS_ID_FEATURE_ARDRONE3:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_FLATTRIM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.FlatTrim:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_FLATTRIM */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_TAKEOFF:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.TakeOff:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_TAKEOFF */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_PCMD:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.PCMD:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | flag -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | roll -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | pitch -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | yaw -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | gaz -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | timestampAndSeqNum -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_LANDING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.Landing:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_LANDING */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_EMERGENCY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.Emergency:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_EMERGENCY */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_NAVIGATEHOME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.NavigateHome:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_NAVIGATEHOME */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_AUTOTAKEOFFMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.AutoTakeOffMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_AUTOTAKEOFFMODE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_MOVEBY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.moveBy:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dX -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dY -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dZ -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dPsi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_MOVEBY */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_USERTAKEOFF:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.UserTakeOff:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_USERTAKEOFF */
                case ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_CIRCLE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.Circle:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTING_CIRCLE_DIRECTION arg = (eARCOMMANDS_ARDRONE3_PILOTING_CIRCLE_DIRECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTING_CIRCLE_DIRECTION)ARCOMMANDS_ReadWrite_PrintI32 (" | direction -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTING_CMD_CIRCLE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Piloting.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANIMATIONS_CMD_FLIP:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Animations.Flip:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION arg = (eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION)ARCOMMANDS_ReadWrite_PrintI32 (" | direction -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANIMATIONS_CMD_FLIP */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Animations.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERA:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_CAMERA_CMD_ORIENTATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Camera.Orientation:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | tilt -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | pan -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERA_CMD_ORIENTATION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Camera.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERA */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTURE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.Picture:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTURE */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEO:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.Video:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD arg = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD)ARCOMMANDS_ReadWrite_PrintI32 (" | record -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEO */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTUREV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.PictureV2:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_PICTUREV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEOV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.VideoV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD arg = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_PrintI32 (" | record -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORD_CMD_VIDEOV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecord.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.PictureStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.VideoStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.PictureStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.VideoStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2 */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEORESOLUTIONSTATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.VideoResolutionState:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING)ARCOMMANDS_ReadWrite_PrintI32 (" | streaming -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING)ARCOMMANDS_ReadWrite_PrintI32 (" | recording -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDSTATE_CMD_VIDEORESOLUTIONSTATE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordEvent.PictureEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordEvent.VideoEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR arg = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaRecordEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLATTRIMCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.FlatTrimChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLATTRIMCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLYINGSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.FlyingStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_FLYINGSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.AlertStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_NAVIGATEHOMESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.NavigateHomeStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON arg = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON)ARCOMMANDS_ReadWrite_PrintI32 (" | reason -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_NAVIGATEHOMESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_POSITIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.PositionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_POSITIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_SPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.SpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speedX -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speedY -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speedZ -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_SPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ATTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.AttitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | roll -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | pitch -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | yaw -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ATTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.AutoTakeOffModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_AUTOTAKEOFFMODECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.AltitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_ALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_GPSLOCATIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.GpsLocationChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | latitude_accuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | longitude_accuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | altitude_accuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_GPSLOCATIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_LANDINGSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.LandingStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSTATE_CMD_LANDINGSTATECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGEVENT_CMD_MOVEBYEND:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingEvent.moveByEnd:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dX -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dY -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dZ -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | dPsi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR arg = (eARCOMMANDS_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGEVENT_CMD_MOVEBYEND */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGEVENT */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFISCAN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Network.WifiScan:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFISCAN */
                case ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFIAUTHCHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Network.WifiAuthChannel:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORK_CMD_WIFIAUTHCHANNEL */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Network.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORK */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFISCANLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.WifiScanListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFISCANLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFISCANCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.AllWifiScanChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFISCANCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.WifiAuthChannelListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | in_or_out -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.AllWifiAuthChannelChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXALTITUDE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.MaxAltitude:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXALTITUDE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXTILT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.MaxTilt:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXTILT */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_ABSOLUTCONTROL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.AbsolutControl:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | on -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_ABSOLUTCONTROL */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXDISTANCE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.MaxDistance:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MAXDISTANCE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_NOFLYOVERMAXDISTANCE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.NoFlyOverMaxDistance:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | shouldNotFlyOver -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_NOFLYOVERMAXDISTANCE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.setAutonomousFlightMaxHorizontalSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.setAutonomousFlightMaxVerticalSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.setAutonomousFlightMaxHorizontalAcceleration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALACCELERATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.setAutonomousFlightMaxVerticalAcceleration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXVERTICALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXROTATIONSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.setAutonomousFlightMaxRotationSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_SETAUTONOMOUSFLIGHTMAXROTATIONSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_BANKEDTURN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.BankedTurn:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_BANKEDTURN */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MINALTITUDE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.MinAltitude:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_MINALTITUDE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGDIRECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.CirclingDirection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_CIRCLINGDIRECTION_VALUE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_CIRCLINGDIRECTION_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_CIRCLINGDIRECTION_VALUE)ARCOMMANDS_ReadWrite_PrintI32 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGDIRECTION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGRADIUS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.CirclingRadius:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGRADIUS */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGALTITUDE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.CirclingAltitude:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_CIRCLINGALTITUDE */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_PITCHMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.PitchMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_PITCHMODE_VALUE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_PITCHMODE_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_PITCHMODE_VALUE)ARCOMMANDS_ReadWrite_PrintI32 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGS_CMD_PITCHMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.MaxAltitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.MaxTiltChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXTILTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_ABSOLUTCONTROLCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.AbsolutControlChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | on -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_ABSOLUTCONTROLCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXDISTANCECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.MaxDistanceChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MAXDISTANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_NOFLYOVERMAXDISTANCECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.NoFlyOverMaxDistanceChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | shouldNotFlyOver -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_NOFLYOVERMAXDISTANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.AutonomousFlightMaxHorizontalSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.AutonomousFlightMaxVerticalSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.AutonomousFlightMaxHorizontalAcceleration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALACCELERATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.AutonomousFlightMaxVerticalAcceleration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXVERTICALACCELERATION */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXROTATIONSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.AutonomousFlightMaxRotationSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_AUTONOMOUSFLIGHTMAXROTATIONSPEED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_BANKEDTURNCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.BankedTurnChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_BANKEDTURNCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MINALTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.MinAltitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_MINALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGDIRECTIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.CirclingDirectionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE)ARCOMMANDS_ReadWrite_PrintI32 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGDIRECTIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGRADIUSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.CirclingRadiusChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGRADIUSCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGALTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.CirclingAltitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_CIRCLINGALTITUDECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_PITCHMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.PitchModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE arg = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE)ARCOMMANDS_ReadWrite_PrintI32 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PILOTINGSETTINGSSTATE_CMD_PITCHMODECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PilotingSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PILOTINGSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXVERTICALSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.MaxVerticalSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXVERTICALSPEED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXROTATIONSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.MaxRotationSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXROTATIONSPEED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_HULLPROTECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.HullProtection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | present -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_HULLPROTECTION */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_OUTDOOR:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.Outdoor:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_OUTDOOR */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXPITCHROLLROTATIONSPEED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.MaxPitchRollRotationSpeed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGS_CMD_MAXPITCHROLLROTATIONSPEED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.MaxVerticalSpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXVERTICALSPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.MaxRotationSpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXROTATIONSPEEDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_HULLPROTECTIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.HullProtectionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | present -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_HULLPROTECTIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.OutdoorChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_OUTDOORCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXPITCHROLLROTATIONSPEEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.MaxPitchRollRotationSpeedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SPEEDSETTINGSSTATE_CMD_MAXPITCHROLLROTATIONSPEEDCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SpeedSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SPEEDSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettings.WifiSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISELECTION */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISECURITY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettings.wifiSecurity:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_TYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | key -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_KEYTYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_KEYTYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_KEYTYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | keyType -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGS_CMD_WIFISECURITY */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettingsState.WifiSelectionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettingsState.wifiSecurityChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettingsState.wifiSecurity:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | key -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE arg = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | keyType -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_NETWORKSETTINGSSTATE_CMD_WIFISECURITY */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.NetworkSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_NETWORKSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTMOTORVERSIONLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.ProductMotorVersionListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | motor_number -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTMOTORVERSIONLISTCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.ProductGPSVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_PRODUCTGPSVERSIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.MotorErrorStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | motorIds -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR arg = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | motorError -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORSOFTWAREVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.MotorSoftwareVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | version -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORSOFTWAREVERSIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORFLIGHTSSTATUSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.MotorFlightsStatusChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbFlights -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | lastFlightDuration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | totalFlightDuration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORFLIGHTSSTATUSCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORLASTERRORCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.MotorErrorLastErrorChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR arg = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | motorError -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_MOTORERRORLASTERRORCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_P7ID:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.P7ID:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serialID -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_P7ID */
                case ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_CPUID:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.CPUID:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_SETTINGSSTATE_CMD_CPUID */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.SettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_PICTUREFORMATSELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.PictureFormatSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_PICTUREFORMATSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_AUTOWHITEBALANCESELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.AutoWhiteBalanceSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_AUTOWHITEBALANCESELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_EXPOSITIONSELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.ExpositionSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_EXPOSITIONSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_SATURATIONSELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.SaturationSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_SATURATIONSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_TIMELAPSESELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.TimelapseSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | interval -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_TIMELAPSESELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOAUTORECORDSELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.VideoAutorecordSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOAUTORECORDSELECTION */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOSTABILIZATIONMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.VideoStabilizationMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOSTABILIZATIONMODE_MODE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOSTABILIZATIONMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOSTABILIZATIONMODE_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOSTABILIZATIONMODE */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORECORDINGMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.VideoRecordingMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORECORDINGMODE_MODE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORECORDINGMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORECORDINGMODE_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORECORDINGMODE */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOFRAMERATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.VideoFramerate:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOFRAMERATE_FRAMERATE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOFRAMERATE_FRAMERATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOFRAMERATE_FRAMERATE)ARCOMMANDS_ReadWrite_PrintI32 (" | framerate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEOFRAMERATE */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORESOLUTIONS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.VideoResolutions:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORESOLUTIONS_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORESOLUTIONS_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORESOLUTIONS_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGS_CMD_VIDEORESOLUTIONS */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_PICTUREFORMATCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.PictureFormatChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_PICTUREFORMATCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_AUTOWHITEBALANCECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.AutoWhiteBalanceChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_AUTOWHITEBALANCECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_EXPOSITIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.ExpositionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_EXPOSITIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_SATURATIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.SaturationChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_SATURATIONCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_TIMELAPSECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.TimelapseChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | interval -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | minInterval -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | maxInterval -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_TIMELAPSECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOAUTORECORDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.VideoAutorecordChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOAUTORECORDCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOSTABILIZATIONMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.VideoStabilizationModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOSTABILIZATIONMODECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORECORDINGMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.VideoRecordingModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORECORDINGMODECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOFRAMERATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.VideoFramerateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE)ARCOMMANDS_ReadWrite_PrintI32 (" | framerate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEOFRAMERATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORESOLUTIONSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.VideoResolutionsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PICTURESETTINGSSTATE_CMD_VIDEORESOLUTIONSCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PictureSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PICTURESETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOENABLE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreaming.VideoEnable:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOENABLE */
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOSTREAMMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreaming.VideoStreamMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIASTREAMING_VIDEOSTREAMMODE_MODE arg = (eARCOMMANDS_ARDRONE3_MEDIASTREAMING_VIDEOSTREAMMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIASTREAMING_VIDEOSTREAMMODE_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMING_CMD_VIDEOSTREAMMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreaming.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreamingState.VideoEnableChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED arg = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_PrintI32 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOSTREAMMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreamingState.VideoStreamModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE arg = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_MEDIASTREAMINGSTATE_CMD_VIDEOSTREAMMODECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.MediaStreamingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_MEDIASTREAMINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SETHOME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.SetHome:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SETHOME */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RESETHOME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.ResetHome:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RESETHOME */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SENDCONTROLLERGPS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.SendControllerGPS:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | horizontalAccuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | verticalAccuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_SENDCONTROLLERGPS */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_HOMETYPE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.HomeType:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE arg = (eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_HOMETYPE */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RETURNHOMEDELAY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.ReturnHomeDelay:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | delay -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGS_CMD_RETURNHOMEDELAY */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGS */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.HomeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RESETHOMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.ResetHomeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RESETHOMECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSFIXSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.GPSFixStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | fixed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSFIXSTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSUPDATESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.GPSUpdateStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE arg = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_GPSUPDATESTATECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMETYPECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.HomeTypeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_HOMETYPECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RETURNHOMEDELAYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.ReturnHomeDelayChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | delay -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSETTINGSSTATE_CMD_RETURNHOMEDELAYCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSETTINGSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERASTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_ORIENTATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.CameraState.Orientation:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | tilt -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | pan -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_ORIENTATION */
                case ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_DEFAULTCAMERAORIENTATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.CameraState.defaultCameraOrientation:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | tilt -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | pan -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_CAMERASTATE_CMD_DEFAULTCAMERAORIENTATION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.CameraState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_CAMERASTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_ELECTRICFREQUENCY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Antiflickering.electricFrequency:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY arg = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY)ARCOMMANDS_ReadWrite_PrintI32 (" | frequency -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_ELECTRICFREQUENCY */
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_SETMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Antiflickering.setMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE arg = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERING_CMD_SETMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.Antiflickering.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERING */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_ELECTRICFREQUENCYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.AntiflickeringState.electricFrequencyChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY arg = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY)ARCOMMANDS_ReadWrite_PrintI32 (" | frequency -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_ELECTRICFREQUENCYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_MODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.AntiflickeringState.modeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE arg = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_ANTIFLICKERINGSTATE_CMD_MODECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.AntiflickeringState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_ANTIFLICKERINGSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_NUMBEROFSATELLITECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSState.NumberOfSatelliteChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | numberOfSatellite -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_NUMBEROFSATELLITECHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPEAVAILABILITYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSState.HomeTypeAvailabilityChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | available -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPEAVAILABILITYCHANGED */
                case ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPECHOSENCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSState.HomeTypeChosenChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE arg = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_GPSSTATE_CMD_HOMETYPECHOSENCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.GPSState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_GPSSTATE */
            case ARCOMMANDS_ID_ARDRONE3_CLASS_PROSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_ARDRONE3_PROSTATE_CMD_FEATURES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PROState.Features:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | features -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_ARDRONE3_PROSTATE_CMD_FEATURES */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.PROState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_ARDRONE3_CLASS_PROSTATE */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("ARDrone3.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_ARDRONE3 */
        case ARCOMMANDS_ID_FEATURE_COMMON:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_COMMON_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_NETWORK_CMD_DISCONNECT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Network.Disconnect:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_NETWORK_CMD_DISCONNECT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Network.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_NETWORK */
            case ARCOMMANDS_ID_COMMON_CLASS_NETWORKEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_NETWORKEVENT_CMD_DISCONNECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.NetworkEvent.Disconnection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE arg = (eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE)ARCOMMANDS_ReadWrite_PrintI32 (" | cause -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_NETWORKEVENT_CMD_DISCONNECTION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.NetworkEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_NETWORKEVENT */
            case ARCOMMANDS_ID_COMMON_CLASS_SETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_ALLSETTINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.AllSettings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_ALLSETTINGS */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_RESET:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.Reset:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_RESET */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_PRODUCTNAME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.ProductName:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_PRODUCTNAME */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_COUNTRY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.Country:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | code -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_COUNTRY */
                case ARCOMMANDS_ID_COMMON_SETTINGS_CMD_AUTOCOUNTRY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.AutoCountry:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | automatic -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGS_CMD_AUTOCOUNTRY */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Settings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_SETTINGS */
            case ARCOMMANDS_ID_COMMON_CLASS_SETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.AllSettingsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_ALLSETTINGSCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_RESETCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ResetChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_RESETCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTNAMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ProductNameChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTNAMECHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ProductVersionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | software -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | hardware -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTVERSIONCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALHIGHCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ProductSerialHighChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | high -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALHIGHCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALLOWCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.ProductSerialLowChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | low -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_PRODUCTSERIALLOWCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_COUNTRYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.CountryChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | code -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_COUNTRYCHANGED */
                case ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_AUTOCOUNTRYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.AutoCountryChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | automatic -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_SETTINGSSTATE_CMD_AUTOCOUNTRYCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.SettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_SETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_COMMON:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_ALLSTATES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.AllStates:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_ALLSTATES */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTDATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.CurrentDate:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | date -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTDATE */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTTIME:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.CurrentTime:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | time -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_CURRENTTIME */
                case ARCOMMANDS_ID_COMMON_COMMON_CMD_REBOOT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.Reboot:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMON_CMD_REBOOT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Common.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_COMMON */
            case ARCOMMANDS_ID_COMMON_CLASS_COMMONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_ALLSTATESCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.AllStatesChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_ALLSTATESCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_BATTERYSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.BatteryStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | percent -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_BATTERYSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGESTATELISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.MassStorageStateListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGESTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOSTATELISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.MassStorageInfoStateListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | size -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | used_size -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | plugged -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | full -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | internal -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOSTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTDATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.CurrentDateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | date -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTDATECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTTIMECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.CurrentTimeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | time -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_CURRENTTIMECHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOREMAININGLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.MassStorageInfoRemainingListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | free_space -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | rec_time -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | photo_remaining -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGEINFOREMAININGLISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_WIFISIGNALCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.WifiSignalChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_WIFISIGNALCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_SENSORSSTATESLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.SensorsStatesListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME arg = (eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME)ARCOMMANDS_ReadWrite_PrintI32 (" | sensorName -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | sensorState -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_SENSORSSTATESLISTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_PRODUCTMODEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.ProductModel:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL arg = (eARCOMMANDS_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL)ARCOMMANDS_ReadWrite_PrintI32 (" | model -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_PRODUCTMODEL */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_COUNTRYLISTKNOWN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.CountryListKnown:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | listFlags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | countryCodes -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_COUNTRYLISTKNOWN */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_DEPRECATEDMASSSTORAGECONTENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.DeprecatedMassStorageContentChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbPhotos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbVideos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbPuds -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbCrashLogs -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_DEPRECATEDMASSSTORAGECONTENTCHANGED */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.MassStorageContent:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbPhotos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbVideos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbPuds -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbCrashLogs -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbRawPhotos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENT */
                case ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENTFORCURRENTRUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.MassStorageContentForCurrentRun:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | mass_storage_id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbPhotos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbVideos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | nbRawPhotos -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_COMMONSTATE_CMD_MASSSTORAGECONTENTFORCURRENTRUN */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CommonState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_COMMONSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_OVERHEAT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_SWITCHOFF:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeat.SwitchOff:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_SWITCHOFF */
                case ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_VENTILATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeat.Ventilate:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEAT_CMD_VENTILATE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeat.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_OVERHEAT */
            case ARCOMMANDS_ID_COMMON_CLASS_OVERHEATSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeatState.OverHeatChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATCHANGED */
                case ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATREGULATIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeatState.OverHeatRegulationChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | regulationType -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_OVERHEATSTATE_CMD_OVERHEATREGULATIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.OverHeatState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_OVERHEATSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CONTROLLER:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CONTROLLER_CMD_ISPILOTING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Controller.isPiloting:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | piloting -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CONTROLLER_CMD_ISPILOTING */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Controller.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CONTROLLER */
            case ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_WIFISETTINGS_CMD_OUTDOORSETTING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.WifiSettings.OutdoorSetting:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_WIFISETTINGS_CMD_OUTDOORSETTING */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.WifiSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGS */
            case ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_WIFISETTINGSSTATE_CMD_OUTDOORSETTINGSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.WifiSettingsState.outdoorSettingsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | outdoor -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_WIFISETTINGSSTATE_CMD_OUTDOORSETTINGSCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.WifiSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_WIFISETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_MAVLINK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_START:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Mavlink.Start:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | filepath -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_MAVLINK_START_TYPE arg = (eARCOMMANDS_COMMON_MAVLINK_START_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_MAVLINK_START_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_START */
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_PAUSE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Mavlink.Pause:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_PAUSE */
                case ARCOMMANDS_ID_COMMON_MAVLINK_CMD_STOP:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Mavlink.Stop:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINK_CMD_STOP */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Mavlink.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_MAVLINK */
            case ARCOMMANDS_ID_COMMON_CLASS_MAVLINKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKFILEPLAYINGSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.MavlinkState.MavlinkFilePlayingStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE arg = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | filepath -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE arg = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKFILEPLAYINGSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKPLAYERRORSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.MavlinkState.MavlinkPlayErrorStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR arg = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_MAVLINKSTATE_CMD_MAVLINKPLAYERRORSTATECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.MavlinkState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_MAVLINKSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CALIBRATION:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_MAGNETOCALIBRATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Calibration.MagnetoCalibration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | calibrate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_MAGNETOCALIBRATION */
                case ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_PITOTCALIBRATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Calibration.PitotCalibration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | calibrate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATION_CMD_PITOTCALIBRATION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Calibration.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CALIBRATION */
            case ARCOMMANDS_ID_COMMON_CLASS_CALIBRATIONSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.MagnetoCalibrationStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | xAxisCalibration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | yAxisCalibration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | zAxisCalibration -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | calibrationFailed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONREQUIREDSTATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.MagnetoCalibrationRequiredState:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | required -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONREQUIREDSTATE */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.MagnetoCalibrationAxisToCalibrateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS arg = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS)ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTARTEDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.MagnetoCalibrationStartedChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | started -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_MAGNETOCALIBRATIONSTARTEDCHANGED */
                case ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_PITOTCALIBRATIONSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.PitotCalibrationStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_STATE arg = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | lastError -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CALIBRATIONSTATE_CMD_PITOTCALIBRATIONSTATECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CalibrationState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CALIBRATIONSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CAMERASETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CAMERASETTINGSSTATE_CMD_CAMERASETTINGSCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CameraSettingsState.CameraSettingsChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | fov -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | panMax -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | panMin -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | tiltMax -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | tiltMin -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CAMERASETTINGSSTATE_CMD_CAMERASETTINGSCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.CameraSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CAMERASETTINGSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_GPS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_GPS_CMD_CONTROLLERPOSITIONFORRUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.GPS.ControllerPositionForRun:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_GPS_CMD_CONTROLLERPOSITIONFORRUN */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.GPS.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_GPS */
            case ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_AVAILABILITYSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanState.AvailabilityStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | AvailabilityState -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_AVAILABILITYSTATECHANGED */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_COMPONENTSTATELISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanState.ComponentStateListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT arg = (eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT)ARCOMMANDS_ReadWrite_PrintI32 (" | component -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | State -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_COMPONENTSTATELISTCHANGED */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_LOCKSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanState.LockStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | LockState -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANSTATE_CMD_LOCKSTATECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_STARTINGERROREVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanEvent.StartingErrorEvent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_STARTINGERROREVENT */
                case ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_SPEEDBRIDLEEVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanEvent.SpeedBridleEvent:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_FLIGHTPLANEVENT_CMD_SPEEDBRIDLEEVENT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.FlightPlanEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_FLIGHTPLANEVENT */
            case ARCOMMANDS_ID_COMMON_CLASS_ARLIBSVERSIONSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_CONTROLLERLIBARCOMMANDSVERSION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ARLibsVersionsState.ControllerLibARCommandsVersion:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | version -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_CONTROLLERLIBARCOMMANDSVERSION */
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_SKYCONTROLLERLIBARCOMMANDSVERSION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ARLibsVersionsState.SkyControllerLibARCommandsVersion:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | version -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_SKYCONTROLLERLIBARCOMMANDSVERSION */
                case ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_DEVICELIBARCOMMANDSVERSION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ARLibsVersionsState.DeviceLibARCommandsVersion:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | version -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ARLIBSVERSIONSSTATE_CMD_DEVICELIBARCOMMANDSVERSION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ARLibsVersionsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ARLIBSVERSIONSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_AUDIO:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_AUDIO_CMD_CONTROLLERREADYFORSTREAMING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Audio.ControllerReadyForStreaming:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | ready -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_AUDIO_CMD_CONTROLLERREADYFORSTREAMING */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Audio.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_AUDIO */
            case ARCOMMANDS_ID_COMMON_CLASS_AUDIOSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_AUDIOSTATE_CMD_AUDIOSTREAMINGRUNNING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AudioState.AudioStreamingRunning:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | running -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_AUDIOSTATE_CMD_AUDIOSTREAMINGRUNNING */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AudioState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_AUDIOSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_HEADLIGHTS_CMD_INTENSITY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Headlights.intensity:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | left -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | right -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_HEADLIGHTS_CMD_INTENSITY */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Headlights.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTS */
            case ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_HEADLIGHTSSTATE_CMD_INTENSITYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.HeadlightsState.intensityChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | left -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | right -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_HEADLIGHTSSTATE_CMD_INTENSITYCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.HeadlightsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_HEADLIGHTSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STARTANIMATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Animations.StartAnimation:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ANIMATIONS_STARTANIMATION_ANIM arg = (eARCOMMANDS_COMMON_ANIMATIONS_STARTANIMATION_ANIM)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ANIMATIONS_STARTANIMATION_ANIM)ARCOMMANDS_ReadWrite_PrintI32 (" | anim -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STARTANIMATION */
                case ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPANIMATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Animations.StopAnimation:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ANIMATIONS_STOPANIMATION_ANIM arg = (eARCOMMANDS_COMMON_ANIMATIONS_STOPANIMATION_ANIM)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ANIMATIONS_STOPANIMATION_ANIM)ARCOMMANDS_ReadWrite_PrintI32 (" | anim -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPANIMATION */
                case ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPALLANIMATIONS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Animations.StopAllAnimations:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONS_CMD_STOPALLANIMATIONS */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Animations.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONS */
            case ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ANIMATIONSSTATE_CMD_LIST:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AnimationsState.List:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ANIM arg = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ANIM)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ANIM)ARCOMMANDS_ReadWrite_PrintI32 (" | anim -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_STATE arg = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ERROR arg = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ANIMATIONSSTATE_CMD_LIST */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AnimationsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ANIMATIONSSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_ACCESSORY:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ACCESSORY_CMD_CONFIG:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Accessory.Config:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ACCESSORY_CONFIG_ACCESSORY arg = (eARCOMMANDS_COMMON_ACCESSORY_CONFIG_ACCESSORY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ACCESSORY_CONFIG_ACCESSORY)ARCOMMANDS_ReadWrite_PrintI32 (" | accessory -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORY_CMD_CONFIG */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Accessory.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ACCESSORY */
            case ARCOMMANDS_ID_COMMON_CLASS_ACCESSORYSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_SUPPORTEDACCESSORIESLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AccessoryState.SupportedAccessoriesListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY arg = (eARCOMMANDS_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY)ARCOMMANDS_ReadWrite_PrintI32 (" | accessory -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_SUPPORTEDACCESSORIESLISTCHANGED */
                case ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AccessoryState.AccessoryConfigChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY arg = (eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY)ARCOMMANDS_ReadWrite_PrintI32 (" | newAccessory -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR arg = (eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGCHANGED */
                case ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGMODIFICATIONENABLED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AccessoryState.AccessoryConfigModificationEnabled:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_ACCESSORYSTATE_CMD_ACCESSORYCONFIGMODIFICATIONENABLED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.AccessoryState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_ACCESSORYSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_CHARGER:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CHARGER_CMD_SETMAXCHARGERATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Charger.SetMaxChargeRate:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CHARGER_SETMAXCHARGERATE_RATE arg = (eARCOMMANDS_COMMON_CHARGER_SETMAXCHARGERATE_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CHARGER_SETMAXCHARGERATE_RATE)ARCOMMANDS_ReadWrite_PrintI32 (" | rate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGER_CMD_SETMAXCHARGERATE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.Charger.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CHARGER */
            case ARCOMMANDS_ID_COMMON_CLASS_CHARGERSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_MAXCHARGERATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ChargerState.MaxChargeRateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE arg = (eARCOMMANDS_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE)ARCOMMANDS_ReadWrite_PrintI32 (" | rate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_MAXCHARGERATECHANGED */
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CURRENTCHARGESTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ChargerState.CurrentChargeStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS arg = (eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS)ARCOMMANDS_ReadWrite_PrintI32 (" | status -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE arg = (eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE)ARCOMMANDS_ReadWrite_PrintI32 (" | phase -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CURRENTCHARGESTATECHANGED */
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_LASTCHARGERATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ChargerState.LastChargeRateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE arg = (eARCOMMANDS_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE)ARCOMMANDS_ReadWrite_PrintI32 (" | rate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_LASTCHARGERATECHANGED */
                case ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CHARGINGINFO:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ChargerState.ChargingInfo:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE arg = (eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE)ARCOMMANDS_ReadWrite_PrintI32 (" | phase -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_RATE arg = (eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_RATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_RATE)ARCOMMANDS_ReadWrite_PrintI32 (" | rate -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | intensity -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | fullChargingTime -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_CHARGERSTATE_CMD_CHARGINGINFO */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.ChargerState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_CHARGERSTATE */
            case ARCOMMANDS_ID_COMMON_CLASS_RUNSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_COMMON_RUNSTATE_CMD_RUNIDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.RunState.RunIdChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | runId -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_COMMON_RUNSTATE_CMD_RUNIDCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.RunState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_COMMON_CLASS_RUNSTATE */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("common.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_COMMON */
        case ARCOMMANDS_ID_FEATURE_CONTROLLER_INFO:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_CONTROLLER_INFO_CMD_GPS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("controller_info.gps:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | horizontal_accuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_accuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | north_speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | east_speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | down_speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | timestamp -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_CONTROLLER_INFO_CMD_GPS */
                case ARCOMMANDS_ID_CONTROLLER_INFO_CMD_BAROMETER:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("controller_info.barometer:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | pressure -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | timestamp -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_CONTROLLER_INFO_CMD_BAROMETER */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("controller_info.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("controller_info.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_CONTROLLER_INFO */
        case ARCOMMANDS_ID_FEATURE_DEBUG:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_DEBUG_CMD_GET_ALL_SETTINGS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("debug.get_all_settings:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DEBUG_CMD_GET_ALL_SETTINGS */
                case ARCOMMANDS_ID_DEBUG_CMD_SET_SETTING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("debug.set_setting:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DEBUG_CMD_SET_SETTING */
                case ARCOMMANDS_ID_DEBUG_CMD_SETTINGS_INFO:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("debug.settings_info:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | listFlags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | label -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_DEBUG_SETTING_TYPE arg = (eARCOMMANDS_DEBUG_SETTING_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_DEBUG_SETTING_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_DEBUG_SETTING_MODE arg = (eARCOMMANDS_DEBUG_SETTING_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_DEBUG_SETTING_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | range_min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | range_max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | range_step -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DEBUG_CMD_SETTINGS_INFO */
                case ARCOMMANDS_ID_DEBUG_CMD_SETTINGS_LIST:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("debug.settings_list:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DEBUG_CMD_SETTINGS_LIST */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("debug.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("debug.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_DEBUG */
        case ARCOMMANDS_ID_FEATURE_DRONE_MANAGER:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_DISCOVER_DRONES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.discover_drones:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_CMD_DISCOVER_DRONES */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.connect:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serial -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | key -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECT */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_FORGET:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.forget:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serial -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_CMD_FORGET */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_DRONE_LIST_ITEM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.drone_list_item:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serial -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | model -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | connection_order -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | active -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | visible -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_DRONE_MANAGER_SECURITY arg = (eARCOMMANDS_DRONE_MANAGER_SECURITY)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_DRONE_MANAGER_SECURITY)ARCOMMANDS_ReadWrite_PrintI32 (" | security -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | has_saved_key -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_CMD_DRONE_LIST_ITEM */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECTION_STATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.connection_state:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_DRONE_MANAGER_CONNECTION_STATE arg = (eARCOMMANDS_DRONE_MANAGER_CONNECTION_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_DRONE_MANAGER_CONNECTION_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serial -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | model -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECTION_STATE */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_AUTHENTICATION_FAILED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.authentication_failed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serial -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | model -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_CMD_AUTHENTICATION_FAILED */
                case ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECTION_REFUSED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.connection_refused:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | serial -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | model -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | name -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_DRONE_MANAGER_CMD_CONNECTION_REFUSED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("drone_manager.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_DRONE_MANAGER */
        case ARCOMMANDS_ID_FEATURE_MAPPER:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.grab:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | buttons -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | axes -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_GRAB */
                case ARCOMMANDS_ID_MAPPER_CMD_MAP_BUTTON_ACTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.map_button_action:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_BUTTON_ACTION arg = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_PrintI32 (" | action -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | buttons -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_MAP_BUTTON_ACTION */
                case ARCOMMANDS_ID_MAPPER_CMD_MAP_AXIS_ACTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.map_axis_action:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_AXIS_ACTION arg = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_PrintI32 (" | action -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | buttons -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_MAP_AXIS_ACTION */
                case ARCOMMANDS_ID_MAPPER_CMD_RESET_MAPPING:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.reset_mapping:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_RESET_MAPPING */
                case ARCOMMANDS_ID_MAPPER_CMD_SET_EXPO:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.set_expo:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_EXPO_TYPE arg = (eARCOMMANDS_MAPPER_EXPO_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_EXPO_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | expo -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_SET_EXPO */
                case ARCOMMANDS_ID_MAPPER_CMD_SET_INVERTED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.set_inverted:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | inverted -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_SET_INVERTED */
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB_STATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.grab_state:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | buttons -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | axes -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | buttons_state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_GRAB_STATE */
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB_BUTTON_EVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.grab_button_event:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | button -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_BUTTON_EVENT arg = (eARCOMMANDS_MAPPER_BUTTON_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_BUTTON_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_GRAB_BUTTON_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_GRAB_AXIS_EVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.grab_axis_event:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_GRAB_AXIS_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_BUTTON_MAPPING_ITEM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.button_mapping_item:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_BUTTON_ACTION arg = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_PrintI32 (" | action -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | buttons -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_BUTTON_MAPPING_ITEM */
                case ARCOMMANDS_ID_MAPPER_CMD_AXIS_MAPPING_ITEM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.axis_mapping_item:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_AXIS_ACTION arg = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_PrintI32 (" | action -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | buttons -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_AXIS_MAPPING_ITEM */
                case ARCOMMANDS_ID_MAPPER_CMD_APPLICATION_AXIS_EVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.application_axis_event:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_AXIS_ACTION arg = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_AXIS_ACTION)ARCOMMANDS_ReadWrite_PrintI32 (" | action -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_APPLICATION_AXIS_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_APPLICATION_BUTTON_EVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.application_button_event:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_BUTTON_ACTION arg = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_BUTTON_ACTION)ARCOMMANDS_ReadWrite_PrintI32 (" | action -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_APPLICATION_BUTTON_EVENT */
                case ARCOMMANDS_ID_MAPPER_CMD_EXPO_MAP_ITEM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.expo_map_item:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_MAPPER_EXPO_TYPE arg = (eARCOMMANDS_MAPPER_EXPO_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_MAPPER_EXPO_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | expo -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_EXPO_MAP_ITEM */
                case ARCOMMANDS_ID_MAPPER_CMD_INVERTED_MAP_ITEM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.inverted_map_item:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | uid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint16_t arg = ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU16 (" | product -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int32_t arg =  (int32_t)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI32 (" | axis -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | inverted -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_MAPPER_CMD_INVERTED_MAP_ITEM */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("mapper.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_MAPPER */
        case ARCOMMANDS_ID_FEATURE_POWERUP:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTING_CMD_PCMD:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Piloting.PCMD:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | flag -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | throttle -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | roll -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTING_CMD_PCMD */
                case ARCOMMANDS_ID_POWERUP_PILOTING_CMD_USERTAKEOFF:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Piloting.UserTakeOff:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTING_CMD_USERTAKEOFF */
                case ARCOMMANDS_ID_POWERUP_PILOTING_CMD_MOTORMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Piloting.MotorMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_PILOTING_MOTORMODE_MODE arg = (eARCOMMANDS_POWERUP_PILOTING_MOTORMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_PILOTING_MOTORMODE_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTING_CMD_MOTORMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Piloting.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTING */
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALERTSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingState.AlertStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED_STATE arg = (eARCOMMANDS_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALERTSTATECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_FLYINGSTATECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingState.FlyingStateChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED_STATE arg = (eARCOMMANDS_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_FLYINGSTATECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_MOTORMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingState.MotorModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSTATE_MOTORMODECHANGED_MODE arg = (eARCOMMANDS_POWERUP_PILOTINGSTATE_MOTORMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_PILOTINGSTATE_MOTORMODECHANGED_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_MOTORMODECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ATTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingState.AttitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | roll -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | pitch -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | yaw -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ATTITUDECHANGED */
                case ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALTITUDECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingState.AltitudeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSTATE_CMD_ALTITUDECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGS_CMD_SET:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingSettings.set:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSETTINGS_SET_SETTING arg = (eARCOMMANDS_POWERUP_PILOTINGSETTINGS_SET_SETTING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_PILOTINGSETTINGS_SET_SETTING)ARCOMMANDS_ReadWrite_PrintI32 (" | setting -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGS_CMD_SET */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGS */
            case ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGSSTATE_CMD_SETTINGCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingSettingsState.settingChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_SETTING arg = (eARCOMMANDS_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_SETTING)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_SETTING)ARCOMMANDS_ReadWrite_PrintI32 (" | setting -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | current -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | min -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | max -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_PILOTINGSETTINGSSTATE_CMD_SETTINGCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.PilotingSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_PILOTINGSETTINGSSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORD:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_PICTUREV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecord.PictureV2:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_PICTUREV2 */
                case ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_VIDEOV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecord.VideoV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORD_VIDEOV2_RECORD arg = (eARCOMMANDS_POWERUP_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORD_VIDEOV2_RECORD)ARCOMMANDS_ReadWrite_PrintI32 (" | record -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORD_CMD_VIDEOV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecord.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORD */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecordState.PictureStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE arg = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR arg = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_PICTURESTATECHANGEDV2 */
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecordState.VideoStateChangedV2:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE arg = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR arg = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDSTATE_CMD_VIDEOSTATECHANGEDV2 */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecordState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecordEvent.PictureEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT arg = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR arg = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_PICTUREEVENTCHANGED */
                case ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecordEvent.VideoEventChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT arg = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT)ARCOMMANDS_ReadWrite_PrintI32 (" | event -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR arg = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR)ARCOMMANDS_ReadWrite_PrintI32 (" | error -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIARECORDEVENT_CMD_VIDEOEVENTCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaRecordEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIARECORDEVENT */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORKSETTINGS_CMD_WIFISELECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkSettings.WifiSelection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_TYPE arg = (eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_BAND arg = (eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSETTINGS_CMD_WIFISELECTION */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGS */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkSettingsState.WifiSelectionChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE arg = (eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND arg = (eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSETTINGSSTATE_CMD_WIFISELECTIONCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSETTINGSSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORK:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFISCAN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Network.WifiScan:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_NETWORK_WIFISCAN_BAND arg = (eARCOMMANDS_POWERUP_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_NETWORK_WIFISCAN_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFISCAN */
                case ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFIAUTHCHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Network.WifiAuthChannel:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORK_CMD_WIFIAUTHCHANNEL */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Network.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORK */
            case ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFISCANLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkState.WifiScanListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_BAND arg = (eARCOMMANDS_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFISCANLISTCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFISCANCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkState.AllWifiScanChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFISCANCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkState.WifiAuthChannelListChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND arg = (eARCOMMANDS_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | in_or_out -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_WIFIAUTHCHANNELLISTCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkState.AllWifiAuthChannelChanged:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_ALLWIFIAUTHCHANNELCHANGED */
                case ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_LINKQUALITYCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkState.LinkQualityChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | quality -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_NETWORKSTATE_CMD_LINKQUALITYCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.NetworkState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_NETWORKSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMING:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIASTREAMING_CMD_VIDEOENABLE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaStreaming.VideoEnable:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIASTREAMING_CMD_VIDEOENABLE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaStreaming.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMING */
            case ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMINGSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaStreamingState.VideoEnableChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED arg = (eARCOMMANDS_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED)ARCOMMANDS_ReadWrite_PrintI32 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_MEDIASTREAMINGSTATE_CMD_VIDEOENABLECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.MediaStreamingState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_MEDIASTREAMINGSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_AUTORECORD:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.VideoSettings.Autorecord:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_AUTORECORD */
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_VIDEOMODE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.VideoSettings.VideoMode:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_VIDEOSETTINGS_VIDEOMODE_MODE arg = (eARCOMMANDS_POWERUP_VIDEOSETTINGS_VIDEOMODE_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_VIDEOSETTINGS_VIDEOMODE_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGS_CMD_VIDEOMODE */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.VideoSettings.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGS */
            case ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_AUTORECORDCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.VideoSettingsState.AutorecordChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_AUTORECORDCHANGED */
                case ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_VIDEOMODECHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.VideoSettingsState.VideoModeChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED_MODE arg = (eARCOMMANDS_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED_MODE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED_MODE)ARCOMMANDS_ReadWrite_PrintI32 (" | mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_VIDEOSETTINGSSTATE_CMD_VIDEOMODECHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.VideoSettingsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_VIDEOSETTINGSSTATE */
            case ARCOMMANDS_ID_POWERUP_CLASS_SOUNDS:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_SOUNDS_CMD_BUZZ:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Sounds.buzz:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_SOUNDS_CMD_BUZZ */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.Sounds.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_SOUNDS */
            case ARCOMMANDS_ID_POWERUP_CLASS_SOUNDSSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_POWERUP_SOUNDSSTATE_CMD_BUZZCHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.SoundsState.buzzChanged:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enabled -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_POWERUP_SOUNDSSTATE_CMD_BUZZCHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.SoundsState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_POWERUP_CLASS_SOUNDSSTATE */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("powerup.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_POWERUP */
        case ARCOMMANDS_ID_FEATURE_PRO:
        {
            switch (commandClass)
            {
            case ARCOMMANDS_ID_PRO_CLASS_PRO:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_PRO_PRO_CMD_BOUGHTFEATURES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.Pro.BoughtFeatures:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | features -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_PRO_PRO_CMD_BOUGHTFEATURES */
                case ARCOMMANDS_ID_PRO_PRO_CMD_RESPONSE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.Pro.Response:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | listFlags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | signedChallenge -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_PRO_PRO_CMD_RESPONSE */
                case ARCOMMANDS_ID_PRO_PRO_CMD_ACTIVATEFEATURES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.Pro.ActivateFeatures:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | features -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_PRO_PRO_CMD_ACTIVATEFEATURES */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.Pro.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_PRO_CLASS_PRO */
            case ARCOMMANDS_ID_PRO_CLASS_PROSTATE:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_PRO_PROSTATE_CMD_SUPPORTEDFEATURES:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.ProState.SupportedFeatures:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_PRO_PROSTATE_SUPPORTEDFEATURES_STATUS arg = (eARCOMMANDS_PRO_PROSTATE_SUPPORTEDFEATURES_STATUS)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_PRO_PROSTATE_SUPPORTEDFEATURES_STATUS)ARCOMMANDS_ReadWrite_PrintI32 (" | status -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | features -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_PRO_PROSTATE_CMD_SUPPORTEDFEATURES */
                case ARCOMMANDS_ID_PRO_PROSTATE_CMD_FEATURESACTIVATED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.ProState.FeaturesActivated:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | features -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_PRO_PROSTATE_CMD_FEATURESACTIVATED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.ProState.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_PRO_CLASS_PROSTATE */
            case ARCOMMANDS_ID_PRO_CLASS_PROEVENT:
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_PRO_PROEVENT_CMD_CHALLENGEEVENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.ProEvent.ChallengeEvent:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | challenge -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_PRO_PROEVENT_CMD_CHALLENGEEVENT */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.ProEvent.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            break; /* ARCOMMANDS_ID_PRO_CLASS_PROEVENT */
            default:
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("pro.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                break;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_PRO */
        case ARCOMMANDS_ID_FEATURE_RC:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_RC_CMD_MONITOR_CHANNELS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.monitor_channels:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | enable -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_MONITOR_CHANNELS */
                case ARCOMMANDS_ID_RC_CMD_START_CALIBRATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.start_calibration:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_RC_CALIBRATION_TYPE arg = (eARCOMMANDS_RC_CALIBRATION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_RC_CALIBRATION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_RC_CHANNEL_TYPE arg = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_START_CALIBRATION */
                case ARCOMMANDS_ID_RC_CMD_INVERT_CHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.invert_channel:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_RC_CHANNEL_TYPE arg = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | flag -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_INVERT_CHANNEL */
                case ARCOMMANDS_ID_RC_CMD_ABORT_CALIBRATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.abort_calibration:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_ABORT_CALIBRATION */
                case ARCOMMANDS_ID_RC_CMD_RESET_CALIBRATION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.reset_calibration:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_RESET_CALIBRATION */
                case ARCOMMANDS_ID_RC_CMD_RECEIVER_STATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.receiver_state:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_RC_RECEIVER_STATE arg = (eARCOMMANDS_RC_RECEIVER_STATE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_RC_RECEIVER_STATE)ARCOMMANDS_ReadWrite_PrintI32 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | protocol -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_RECEIVER_STATE */
                case ARCOMMANDS_ID_RC_CMD_CHANNELS_MONITOR_STATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.channels_monitor_state:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | state -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_CHANNELS_MONITOR_STATE */
                case ARCOMMANDS_ID_RC_CMD_CHANNEL_VALUE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.channel_value:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | id -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_RC_CHANNEL_TYPE arg = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | value -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_CHANNEL_VALUE */
                case ARCOMMANDS_ID_RC_CMD_CALIBRATION_STATE:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.calibration_state:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_RC_CALIBRATION_TYPE arg = (eARCOMMANDS_RC_CALIBRATION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_RC_CALIBRATION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_RC_CHANNEL_TYPE arg = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_RC_CHANNEL_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | supported -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | required -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | calibrated -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | neutral_calibrated -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint32_t arg = ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU32 (" | inverted -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_CALIBRATION_STATE */
                case ARCOMMANDS_ID_RC_CMD_RECEIVER_QUALITY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.receiver_quality:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | level -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_RC_CMD_RECEIVER_QUALITY */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("rc.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_RC */
        case ARCOMMANDS_ID_FEATURE_UNKNOWN_FEATURE_1:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_GEOGRAPHIC_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.geographic_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | elevation_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | elevation -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | azimuth_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | azimuth -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_GEOGRAPHIC_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RELATIVE_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.relative_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | elevation_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | elevation -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | azimuth_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | azimuth -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RELATIVE_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_LOOK_AT_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.look_at_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_LOOK_AT_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SPIRAL_ANIM_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.spiral_anim_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | revolution_nb_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | revolution_number -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | vertical_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SPIRAL_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SWING_ANIM_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.swing_anim_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | vertical_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SWING_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_BOOMERANG_ANIM_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.boomerang_anim_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_BOOMERANG_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_CANDLE_ANIM_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.candle_anim_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | vertical_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_CANDLE_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_DOLLY_SLIDE_ANIM_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.dolly_slide_anim_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | start -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | angle_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | angle -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | horizontal_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | horizontal_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_DOLLY_SLIDE_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_FRAMING_POSITION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.user_framing_position:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | horizontal -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | vertical -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_FRAMING_POSITION */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_GPS_DATA:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.user_GPS_data:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | latitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | longitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | altitude -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | horizontal_accuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_accuracy -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | north_speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | east_speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | down_speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | timestamp -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_GPS_DATA */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_BARO_DATA:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.user_baro_data:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | pressure -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        double arg = ARCOMMANDS_ReadWrite_ReadDoubleFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintDouble (" | timestamp -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_BARO_DATA */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_LYNX_DETECTION:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.lynx_detection:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | target_pan -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | target_tilt -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | change_of_scale -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | confidence_index -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | is_new_selection -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint64_t arg = ARCOMMANDS_ReadWrite_Read64FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU64 (" | timestamp -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_LYNX_DETECTION */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_AVAILABILITY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.availability:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_UNKNOWN_FEATURE_1_TYPES_AVAILABLE arg = (eARCOMMANDS_UNKNOWN_FEATURE_1_TYPES_AVAILABLE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_UNKNOWN_FEATURE_1_TYPES_AVAILABLE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_AVAILABILITY */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_UNKNOWN_FEATURE_1_TYPE arg = (eARCOMMANDS_UNKNOWN_FEATURE_1_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_UNKNOWN_FEATURE_1_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_GEOGRAPHIC_CONFIG_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.geographic_config_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | elevation_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | elevation -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | azimuth_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | azimuth -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_GEOGRAPHIC_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RELATIVE_CONFIG_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.relative_config_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | elevation_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | elevation -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | azimuth_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | azimuth -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_RELATIVE_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_ANIM_RUN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.anim_run:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_UNKNOWN_FEATURE_1_ANIM_TYPE arg = (eARCOMMANDS_UNKNOWN_FEATURE_1_ANIM_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_UNKNOWN_FEATURE_1_ANIM_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_ANIM_RUN */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SPIRAL_ANIM_CONFIG_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.spiral_anim_config_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | revolution_nb_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | revolution_nb -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | vertical_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SPIRAL_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SWING_ANIM_CONFIG_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.swing_anim_config_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | vertical_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_SWING_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_BOOMERANG_ANIM_CONFIG_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.boomerang_anim_config_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_BOOMERANG_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_CANDLE_ANIM_CONFIG_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.candle_anim_config_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | vertical_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | vertical_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_CANDLE_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_DOLLY_SLIDE_ANIM_CONFIG_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.dolly_slide_anim_config_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | speed_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | speed -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | angle_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | angle -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | horizontal_distance_is_default -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        float arg = ARCOMMANDS_ReadWrite_ReadFloatFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintFloat (" | horizontal_distance -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_DOLLY_SLIDE_ANIM_CONFIG_CHANGED */
                case ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_FRAMING_POSITION_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.user_framing_position_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | horizontal -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int8_t arg =  (int8_t)ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI8 (" | vertical -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_UNKNOWN_FEATURE_1_CMD_USER_FRAMING_POSITION_CHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("unknown_feature_1.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_UNKNOWN_FEATURE_1 */
        case ARCOMMANDS_ID_FEATURE_WIFI:
        {
            if (commandClass == ARCOMMANDS_ID_FEATURE_CLASS)
            {
                switch (commandId)
                {
                case ARCOMMANDS_ID_WIFI_CMD_SCAN:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.scan:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_SCAN */
                case ARCOMMANDS_ID_WIFI_CMD_UPDATE_AUTHORIZED_CHANNELS:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.update_authorized_channels:", resString, stringLen, strOffset) ;
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_UPDATE_AUTHORIZED_CHANNELS */
                case ARCOMMANDS_ID_WIFI_CMD_SET_AP_CHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.set_ap_channel:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_SELECTION_TYPE arg = (eARCOMMANDS_WIFI_SELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_SELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_BAND arg = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_SET_AP_CHANNEL */
                case ARCOMMANDS_ID_WIFI_CMD_SET_SECURITY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.set_security:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_SECURITY_TYPE arg = (eARCOMMANDS_WIFI_SECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_SECURITY_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | key -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_SECURITY_KEY_TYPE arg = (eARCOMMANDS_WIFI_SECURITY_KEY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_SECURITY_KEY_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | key_type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_SET_SECURITY */
                case ARCOMMANDS_ID_WIFI_CMD_SET_COUNTRY:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.set_country:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_COUNTRY_SELECTION arg = (eARCOMMANDS_WIFI_COUNTRY_SELECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_COUNTRY_SELECTION)ARCOMMANDS_ReadWrite_PrintI32 (" | selection_mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | code -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_SET_COUNTRY */
                case ARCOMMANDS_ID_WIFI_CMD_SET_ENVIRONMENT:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.set_environment:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_ENVIRONMENT arg = (eARCOMMANDS_WIFI_ENVIRONMENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_ENVIRONMENT)ARCOMMANDS_ReadWrite_PrintI32 (" | environment -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_SET_ENVIRONMENT */
                case ARCOMMANDS_ID_WIFI_CMD_SCANNED_ITEM:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.scanned_item:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | ssid -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_BAND arg = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_SCANNED_ITEM */
                case ARCOMMANDS_ID_WIFI_CMD_AUTHORIZED_CHANNEL:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.authorized_channel:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_BAND arg = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | environment -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | list_flags -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_AUTHORIZED_CHANNEL */
                case ARCOMMANDS_ID_WIFI_CMD_AP_CHANNEL_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.ap_channel_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_SELECTION_TYPE arg = (eARCOMMANDS_WIFI_SELECTION_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_SELECTION_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_BAND arg = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_BAND)ARCOMMANDS_ReadWrite_PrintI32 (" | band -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        uint8_t arg = ARCOMMANDS_ReadWrite_Read8FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintU8 (" | channel -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_AP_CHANNEL_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_SECURITY_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.security_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | key -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_SECURITY_TYPE arg = (eARCOMMANDS_WIFI_SECURITY_TYPE)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_SECURITY_TYPE)ARCOMMANDS_ReadWrite_PrintI32 (" | key_type -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_SECURITY_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_COUNTRY_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.country_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_COUNTRY_SELECTION arg = (eARCOMMANDS_WIFI_COUNTRY_SELECTION)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_COUNTRY_SELECTION)ARCOMMANDS_ReadWrite_PrintI32 (" | selection_mode -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset > 0)
                    {
                        char * arg = ARCOMMANDS_ReadWrite_ReadStringFromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintString (" | code -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_COUNTRY_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_ENVIRONMENT_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.environment_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        eARCOMMANDS_WIFI_ENVIRONMENT arg = (eARCOMMANDS_WIFI_ENVIRONMENT)ARCOMMANDS_ReadWrite_Read32FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = (eARCOMMANDS_WIFI_ENVIRONMENT)ARCOMMANDS_ReadWrite_PrintI32 (" | environment -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_ENVIRONMENT_CHANGED */
                case ARCOMMANDS_ID_WIFI_CMD_RSSI_CHANGED:
                {
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.rssi_changed:", resString, stringLen, strOffset) ;
                    if (strOffset > 0)
                    {
                        int16_t arg =  (int16_t)ARCOMMANDS_ReadWrite_Read16FromBuffer (buffer, buffLen, &offset, &error);
                        if (error == 0)
                        {
                            strOffset = ARCOMMANDS_ReadWrite_PrintI16 (" | rssi -> ", arg, resString, stringLen, strOffset);
                        }
                        else
                        {
                            retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_DATA;
                        }
                    } // No else --> If first print failed, the next if will set the error code
                    if (strOffset < 0)
                    {
                        retVal = ARCOMMANDS_DECODER_ERROR_NOT_ENOUGH_SPACE;
                    } // No else --> Do not modify retVal if no error occured
                }
                break; /* ARCOMMANDS_ID_WIFI_CMD_RSSI_CHANGED */
                default:
                    strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                    retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
                    break;
                }
            }
            else
            {
                strOffset = ARCOMMANDS_ReadWrite_WriteString ("wifi.UNKNOWN -> Unknown command", resString, stringLen, strOffset);
                retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            }
        }
        break; /* ARCOMMANDS_ID_FEATURE_WIFI */
        default:
            strOffset = ARCOMMANDS_ReadWrite_WriteString ("UNKNOWN -> Unknown command", resString, stringLen, strOffset);
            retVal = ARCOMMANDS_DECODER_ERROR_UNKNOWN_COMMAND;
            break;
        }
    } // No else --> Processing block
    return retVal;
}

// END GENERATED CODE
